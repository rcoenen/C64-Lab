<!-- TOC START -->
TABLE OF CONTENTS:
- Page 1: Commodore 64 tips book cover
- Page 2: Blank document page
- Page 3: Commodore 64 user guide tips
- Page 4: Book copyright page details
- Page 5: Technical disclaimer for amateur use
- Page 6: Blank document page
- Page 7: Commodore 64 programming manual table
- Page 8: Commodore 64 programming manual
- Page 9: Commodore 64 technical manual sections
- Page 10: Commodore 64 programming routines guide
- Page 11: Commodore 64 promotional book intro
- Page 12: Commodore 64 book preface
- Page 13: Commodore 64 graphics guide
- Page 14: Commodore 64 graphics tutorial
- Page 15: Commodore 64 programming instructions
- Page 16: BASIC program code snippet
- Page 17: Commodore 64 sprite programming guide
- Page 18: Commodore 64 3D graphics program
- Page 19: Graphic plotting program instructions
- Page 20: BASIC graphics programming code
- Page 21: BASIC graphics plotting program
- Page 22: BASIC programming code listing
- Page 23: Driver's license front and back
- Page 24: Machine program for colored bar charts
- Page 25: Assembly code listing
- Page 26: Assembly code listing
- Page 27: 6502 assembly code listing
- Page 28: 6502 assembly code listing
- Page 29: BASIC program data analysis
- Page 30: BASIC programming code example
- Page 31: Commodore 64 custom character guide
- Page 32: Character matrix definition guide
- Page 33: BASIC character definition program
- Page 34: Joystick-controlled character design guide
- Page 35: C64 character editor instructions
- Page 36: Retro computer sprite memory guide
- Page 37: 6502 assembly code snippet
- Page 38: C64 character generator documentation
- Page 39: Commodore 64 assembly program listing
- Page 40: BASIC game movement code snippet
- Page 41: BASIC program code listing
- Page 42: Commodore 64 raster interrupt guide
- Page 43: Assembly code for video controllers
- Page 44: Assembly code listing
- Page 45: BASIC program code example
- Page 46: BASIC raster interrupt program code
- Page 47: Commodore 64 programming guide
- Page 48: Technical document on soft scrolling
- Page 49: BASIC code scroll effect program
- Page 50: Commodore 64 keyboard technical manual
- Page 51: Commodore 64 keyboard mapping guide
- Page 52: Commodore keyboard remapping guide
- Page 53: ZX Spectrum keyboard remapping guide
- Page 54: BASIC key remapping program code
- Page 55: Commodore 64 cursor positioning guide
- Page 56: BASIC programming cursor control
- Page 57: Commodore 64 cursor control guide
- Page 58: BASIC programming code snippet
- Page 59: Commodore 64 repeat function guide
- Page 60: BASIC WAIT command documentation
- Page 61: Commodore BASIC WAIT command guide
- Page 62: Commodore 64 function key guide
- Page 63: BASIC function key programming guide
- Page 64: CBM 64 function key mapping
- Page 65: Keyboard function handling code
- Page 66: Assembly code listing with comments
- Page 67: BASIC program listing and notes
- Page 68: Program address modification instructions
- Page 69: Programming input routine guide
- Page 70: Programming input validation guide
- Page 71: Input routine documentation page
- Page 72: C64 input validation code snippet
- Page 73: Input routine code snippet
- Page 74: BASIC input validation routine
- Page 75: Article input program instructions
- Page 76: German programming tutorial snippet
- Page 77: Computer mouse technical explanation article
- Page 78: Computer mouse usage guide
- Page 79: Program variable and memory guide
- Page 80: Commodore 64 cursor control code
- Page 81: C64 joystick cursor control code
- Page 82: BASIC program listing code
- Page 83: BASIC joystick input routine
- Page 84: BASIC programming code snippet
- Page 85: Basic programming tutorial chapter
- Page 86: Programming guide for dynamic calculations
- Page 87: Basic program memory allocation guide
- Page 88: Machine code program listing
- Page 89: Commodore 64 BASIC machine code
- Page 90: BASIC programming instructions listing
- Page 91: BASIC calculator program code
- Page 92: Basic program generator explanation
- Page 93: Commodore 64 BASIC interpreter guide
- Page 94: BASIC ROM to RAM copy guide
- Page 95: Commodore 64 FRE function bug
- Page 96: BASIC interpreter code patch
- Page 97: BASIC programming return routine
- Page 98: Assembly code listing
- Page 99: BASIC machine code listing
- Page 100: BASIC interpreter programming guide
- Page 101: Assembly code modification guide
- Page 102: BASIC RESTORE routine modification
- Page 103: BASIC program listing snippet
- Page 104: MID$ command documentation
- Page 105: BASIC MID$ function documentation
- Page 106: Assembly code listing page
- Page 107: Assembly code snippet
- Page 108: 6502 assembly code listing
- Page 109: BASIC program code example
- Page 110: String transformation example
- Page 111: Commodore 64 BASIC string functions
- Page 112: BASIC programming examples and functions
- Page 113: Assembly code listing snippet
- Page 114: Assembly code listing
- Page 115: Assembly code listing
- Page 116: Assembly code listing
- Page 117: BASIC machine code loader program
- Page 118: Commodore 64 auto numbering guide
- Page 119: BASIC machine program listing
- Page 120: Assembly code listing
- Page 121: Assembly code listing
- Page 122: DEF FN function documentation
- Page 123: Function definition example document
- Page 124: Basic price calculation formula
- Page 125: Commodore 64 German error messages
- Page 126: 6502 assembly error handler code
- Page 127: Error message reference list
- Page 128: Error message code listing
- Page 129: Encoded text data document
- Page 130: Basic data validation script
- Page 131: Commodore 64 BASIC hardcopy routine
- Page 132: BASIC printer output program code
- Page 133: CBM64 clock program description
- Page 134: Program variable documentation
- Page 135: Real-time clock configuration guide
- Page 136: Program listing with timing logic
- Page 137: Vintage BASIC clock program code
- Page 138: Data processing code snippet
- Page 139: Time tracking document summary
- Page 140: Software copy protection analysis
- Page 141: Software protection guide introduction
- Page 142: BASIC floppy disk formatting code
- Page 143: Floppy disk protection guide
- Page 144: Basic copy protection demo code
- Page 145: Software protection instructions manual
- Page 146: Chapter 5: FORTH programming guide
- Page 147: FORTH programming language overview
- Page 148: Forth programming language documentation
- Page 149: Forth vs BASIC comparison guide
- Page 150: Stack operation documentation
- Page 151: Forth programming tutorial example
- Page 152: Forth programming language tutorial
- Page 153: FORTH programming tutorial example
- Page 154: BASIC programming code example
- Page 155: Forth vs BASIC benchmark test
- Page 156: Commodore 64 FORTH programming guide
- Page 157: Forth programming language benefits
- Page 158: Commodore 64 programming languages guide
- Page 159: Turtle Graphics programming example
- Page 160: Commodore 64 ADA programming guide
- Page 161: Basic multiplication program code
- Page 162: Chapter 6: CP/M on Commodore 64
- Page 163: CP/M compatibility and limitations
- Page 164: CP/M software compatibility guide
- Page 165: CP/M operating system components guide
- Page 166: BIOS function reference table
- Page 167: CP/M system call reference guide
- Page 168: CP/M function call documentation
- Page 169: CP/M BIOS/BDOS documentation
- Page 170: CP/M DIR command reference
- Page 171: CP/M command reference guide
- Page 172: CP/M command reference guide
- Page 173: CP/M standard programs guide
- Page 174: CP/M utility program descriptions
- Page 175: Commodore 64 CP/M STAT command guide
- Page 176: Floppy disk system documentation
- Page 177: Commodore ED text editor guide
- Page 178: CP/M adaptation guide for C-64
- Page 179: Z80 memory management guide
- Page 180: 6510/Z80 memory map table
- Page 181: CP/M disk management guide
- Page 182: CP/M disk layout documentation
- Page 183: Commodore disk formatting instructions
- Page 184: Commodore 64 CP/M processor cooperation
- Page 185: 6510/Z80 memory mapping guide
- Page 186: Commodore 64 CP/M BIOS listing
- Page 187: Z80 assembly bootloader code
- Page 188: Z80 assembly code snippet
- Page 189: Commodore 64 BIOS assembly code
- Page 190: Disk sector read/write code
- Page 191: 6502 assembly disk write routine
- Page 192: Z80 assembly printer control code
- Page 193: Disk formatting assembly code
- Page 194: CP/M disk operation code listing
- Page 195: 6502 assembly disk file code
- Page 196: Assembly code disk operations
- Page 197: Commodore keyboard code table
- Page 198: ASCII character encoding table
- Page 199: Commodore keyboard layout chart
- Page 200: Z80 boot routine documentation
- Page 201: Z80 assembly disk load code
- Page 202: Assembly code boot loader
- Page 203: CP/M 2.2 BIOS documentation
- Page 204: CP/M memory configuration code
- Page 205: Z80 assembly I/O configuration code
- Page 206: Floppy disk parameter table
- Page 207: Commodore 64 boot code listing
- Page 208: CP/M bootloader assembly code
- Page 209: Z80 assembly disk read code
- Page 210: CP/M system initialization code
- Page 211: Assembly code listing
- Page 212: Assembly code keyboard handling routine
- Page 213: Assembly code listing
- Page 214: Assembly code listing page
- Page 215: Assembly code console output routine
- Page 216: Assembly code listing
- Page 217: Commodore 64 assembly code
- Page 218: CP/M disk sector constants table
- Page 219: Assembly code disk selection
- Page 220: CP/M disk read/write assembly code
- Page 221: Assembly code for disk write
- Page 222: CP/M disk allocation code snippet
- Page 223: Assembly code snippet
- Page 224: Disk sector verification code
- Page 225: Assembly code data transfer
- Page 226: Assembly code error handling routine
- Page 227: Disk write subroutine code
- Page 228: Assembly code disk operation
- Page 229: Assembly code memory map
- Page 230: Memory allocation data structure
- Page 231: BIOS custom I/O function guide
- Page 232: CP/M BIOS input routine code
- Page 233: CP/M to Commodore 64 transfer guide
- Page 234: Commodore data transfer instructions
- Page 235: Commodore to CP/M data transfer guide
- Page 236: CP/M file transfer instructions
- Page 237: Commodore 64 technical manual chapter
- Page 238: Commodore 64 printer interface guide
- Page 239: Commodore 64 printer interface guide
- Page 240: Port definitions and initialization code
- Page 241: Assembly code for I/O operations
- Page 242: 6502 assembly file handling code
- Page 243: 6502 assembly code listing
- Page 244: BASIC assembly code listing
- Page 245: Hexadecimal or binary data dump
- Page 246: Userport to Centronics pinout guide
- Page 247: C64 data transfer guide
- Page 248: CBM8032 Userport technical documentation
- Page 249: Microcontroller user port documentation
- Page 250: C64/CBM8032 communication program guide
- Page 251: CBM8032 data transfer subroutine
- Page 252: CBM64 data transfer subroutine
- Page 253: Serial communication setup guide
- Page 254: Technical schematic diagram
- Page 255: CP/M cartridge technical documentation
- Page 256: C64 expansion port technical guide
- Page 257: Z80 bus control technical explanation
- Page 258: Z80 processor memory addressing guide
- Page 259: Z80 cartridge programming guide
- Page 260: C64 Z80 processor technical documentation
- Page 261: Technical hardware documentation page
- Page 262: Driver's license front side
- Page 263: C64 synthesizer stereo modification guide
- Page 264: Audio filter circuit instructions
- Page 265: Basic Commodore 64 assembly code
- Page 266: Commodore 64 file management guide
- Page 267: Database concepts explanation document
- Page 268: Address database example table
- Page 269: Commodore 64 cassette programming guide
- Page 270: Commodore 64 file commands guide
- Page 271: Commodore 64 disk storage guide
- Page 272: Cassette vs. floppy comparison analysis
- Page 273: Commodore 64 data tape guide
- Page 274: Commodore data transfer protocol
- Page 275: VC-20 to C64 tape transfer guide
- Page 276: Sequential file management guide
- Page 277: Commodore 64 data management guide
- Page 278: Commodore 64 disk file handling
- Page 279: Commodore 64 file management guide
- Page 280: Commodore 64 data storage program
- Page 281: Commodore 64 data read program
- Page 282: Commodore 64 data appending code
- Page 283: BASIC program data entry code
- Page 284: Commodore 64 disk writing routine
- Page 285: Floppy disk capacity explanation
- Page 286: Floppy disk data storage guide
- Page 287: Commodore 64 BASIC data program
- Page 288: CBM 64 file handling code
- Page 289: Sequential file description and usage
- Page 290: Commodore 64 file copying guide
- Page 291: BASIC file copy program code
- Page 292: Floppy disk file copy guide
- Page 293: BASIC program file editing
- Page 294: Commodore 64 relative file guide
- Page 295: Commodore 64 relative file guide
- Page 296: Data record positioning instructions
- Page 297: Data address calculation guide
- Page 298: Disk formatting instructions manual
- Page 299: VAT rate selection guide
- Page 300: Program instructions and guidelines
- Page 301: BASIC inventory management program
- Page 302: German inventory management program
- Page 303: Article management program code
- Page 304: BASIC data management program code
- Page 305: Basic input validation code
- Page 306: BASIC program code listing
- Page 307: Article list print program
- Page 308: BASIC data management program code
- Page 309: Invoice data output code
- Page 310: VAT calculation program code
- Page 311: Financial report summary section
- Page 312: VAT calculation program code
- Page 313: BASIC program error handling code
- Page 314: Direct access disk method guide
- Page 315: BASIC disk file allocation code
- Page 316: CBM 64 disk access code
- Page 317: Commodore 1541 floppy disk commands
- Page 318: Disk error recovery guide
- Page 319: Disk recovery program instructions
- Page 320: Floppy disk directory access code
- Page 321: Floppy disk file recovery guide
- Page 322: File recovery instructions and code
- Page 323: BASIC file handling code snippet
- Page 324: Block follower program documentation
- Page 325: BASIC error handling subroutine
- Page 326: BASIC program listing snippet
- Page 327: BASIC programsng reference guide
- Page 328: Program code block descriptions
- Page 329: Chapter 9: Machine code routines
- Page 330: Commodore 64 memory management guide
- Page 331: BASIC programming code snippet
- Page 332: String sorting algorithm guide
- Page 333: Assembly code listing page
- Page 334: 6502 assembly code listing
- Page 335: 6502 assembly and BASIC loader
- Page 336: BASIC program speed test
- Page 337: BASIC code for min/max
- Page 338: Assembly min/max function code
- Page 339: Assembly code snippet
- Page 340: Assembly code array processing
- Page 341: BASIC assembly code listing
- Page 342: BASIC array max/min function
- Page 343: BASIC programming code snippet
- Page 344: BASIC variable dump program
- Page 345: 6502 assembly code listing
- Page 346: 6502 assembly code listing
- Page 347: BASIC machine code program
- Page 348: BASIC programming code example
- Page 349: Commodore 64 PEEK function modification
- Page 350: Assembly code listing snippet
- Page 351: BASIC POKE commands tutorial
- Page 352: BASIC programming memory expansion
- Page 353: Commodore 64 multitasking explanation
- Page 354: Commodore 64 time display program
- Page 355: Assembly code memory map
- Page 356: Assembly code listing
- Page 357: Assembly code listing
- Page 358: Assembly code listing
- Page 359: 6502 assembly code listing
- Page 360: BASIC program clock display
- Page 361: Multitasking application programming guide
- Page 362: Commodore 64 interrupt programming guide
- Page 363: POKE commands memory addresses guide
- Page 364: Commodore 64 memory addresses guide
- Page 365: Text input control guide
- Page 366: BASIC code for text-to-number conversion
- Page 367: Commodore 64 text case handling
- Page 368: Bitwise operation code example
- Page 369: Formatted BASIC program listing tool
- Page 370: BASIC programming code listing
- Page 371: Program code listing and notes
- Page 372: Programming warm start guide
- Page 373: Programming warm start instructions manual
- Page 374: BASIC program tape save code
- Page 375: Retro database software advertisement
- Page 376: Commodore 64 machine language books
- Page 377: Commodore 64 programming guide books
- Page 378: Software product advertisement brochure
- Page 379: KONTOMAT accounting software brochure
- Page 380: FAKTUMAT invoicing software brochure
- Page 381: Commodore 64 programming tools guide
- Page 382: BASIC 64 compiler documentation
- Page 383: Junior mathematics learning program description
- Page 384: Software training book catalog
- Page 385: Blank document page
- Page 386: Commodore 64 programming guide
<!-- TOC END -->


<!-- TOC PAGE_01: Commodore 64 tips book cover -->===========================================================
                       PAGE 1 OF 386                        
===========================================================

Angerhausen · English
Gerits · Thrun

#64 Tips &amp; Tricks

VOLUME 1
The bestseller with
over 70,000
sell
specimens

A treasure trove for him
Commodore 64 users

A DATA BECKER BOOK

<!-- TOC PAGE_02: Blank document page -->

===========================================================
                       PAGE 2 OF 386                        
===========================================================

.

<!-- TOC PAGE_03: Commodore 64 user guide tips -->

===========================================================
                       PAGE 3 OF 386                        
===========================================================

Angerhausen · English
Gerits · Thrun

#64 Tips &amp; Tricks

![img-0.jpeg](img-0.jpeg)

A treasure trove for the Commodore 64 user

A DATA BECKER BOOK

<!-- TOC PAGE_04: Book copyright page details -->

===========================================================
                       PAGE 4 OF 386                        
===========================================================

ISBN 3-89011-001-0

4th expanded and revised edition

Copyright (C) 1984 DATA BECKER GmbH
Merowingerstr. 30
4000 Düsseldorf

All rights reserved. No part of this book may be reproduced in any form (print, photocopy or any other process) or processed, duplicated or distributed using electronic systems without the written permission of DATA BECKER GmbH.

<!-- TOC PAGE_05: Technical disclaimer for amateur use -->

===========================================================
                       PAGE 5 OF 386                        
===========================================================

Important note

The circuits, procedures and programs reproduced in this book are presented without regard to the patent situation. They are intended for amateur and educational purposes only and may not be used commercially.

All circuits, technical information and programs in this book were developed or compiled by the author with the greatest care and reproduced using effective control measures. Nevertheless, errors cannot be completely ruled out. DATA BECKER is therefore forced to point out that neither a guarantee nor legal responsibility or any liability can be assumed for consequences resulting from incorrect information. The author is always grateful to report any errors.

<!-- TOC PAGE_06: Blank document page -->===========================================================
                       PAGE 6 OF 386                        
===========================================================

^{}[]

<!-- TOC PAGE_07: Commodore 64 programming manual table -->

===========================================================
                       PAGE 7 OF 386                        
===========================================================

# TABLE OF CONTENTS

1. Preface 1

2. Graphics for advanced users

2.1 Graphics on the Commodore 64 3
2.2 3D graphics - BASIC program 8
2.3 Colored bar graph 14
2.4 Definition of your own character set 21
2.5 Modification of the character set with the joystick. 24
2.6 The split screen 32
2.7 Soft scrolling 38
2.8 The keyboard layout and its changes 40

3. Data entry with convenience

3.1 Cursor positioning and query of the cursor position 45
3.2 Switch cursor on and off 47
3.3 Repeat function for all buttons 49
3.4 The WAIT command: Waiting for a key press 50
3.5 The assignment of the function keys 52
3.6 A convenient INPUT routine 59
3.7 The “mouse” on the 64: Simulation with the joystick 67

<!-- TOC PAGE_08: Commodore 64 programming manual -->

===========================================================
                       PAGE 8 OF 386                        
===========================================================

4. BASIC for advanced users

4.1 Often tried, rarely successful:
Creating a BASIC line in BASIC . . . . . . . . . 75
4.2 Copying the BASIC interpreter into RAM. . . . . . 83
4.3 No more negative numbers in the FRE function. 85
4.4 Return to the BASIC program after LIST. . . . . . 87
4.5 GOTO, GOSUB and RESTORE
with calculated line numbers. . . . . . . . . . . 90
4.6 The MID$ command . . . . . . . . . . . . . . . . . . 94
4.7 INSTR and STRING$ function. . . . . . . . . . . 101
4.8 Automatic line numbering. . . . . . . . . . 108
4.9 DEF FN - the unknown being. . . . . . . . . 112
4.10 Your Commodore 64 speaks German. . . . . . . . . 115
4.11 Using a HARDCOPY routine for
commercial programs. . . . . . . . . . . . . . . . 121
4.12 Set theory on the CBM 64 using an example
using the Berlin Kufdamm clock
the real time clock and sprites. . . . . . . . . . . 123
4.13 A little copy protection. . . . . . . . . . . . . 130

5 The CBM 64 can't just do BASIC

5.1 Programming FORTH . . . . . . . . . . . 136
5.2 FORTH-BASIC comparison program. . . . . . . . . 139
5.3 Other languages: PASCAL, LOGO . . . . . . . . . . . 148
5.4 ADA for the Commodore 64. . . . . . . . . . . . . 150

6. CP/M on the Commodore 64

6.1 This is CP/M. . . . . . . . . . . . . . . . . . . . 152
6.2 Handling the individual CP/M programs. . . 163

<!-- TOC PAGE_09: Commodore 64 technical manual sections -->

===========================================================
                       PAGE 9 OF 386                        
===========================================================

6.3 The adaptation of CP/M standard software to the 64 .168
6.4 The memory management of the Z80 processor .169
6.5 Diskette management under CP/M .171
6.6 The cooperation of the processors 6510 - Z80 .174
6.7 Commented BIOS listing .176
6.8 Implementation of own input/output functions in the BIOS .221
6.9 Transferring programs and data from CP/M to Commodore-BASIC and vice versa .223

## 7. Connection and expansion options for the Commodore 64

7.1 A useful application of the USER port using the example of a Centronics printer .227
7.2 Data transfer from and to other computers using USER port .237
7.3 The expansion port: A case study with the CP/M cartridge .245
7.4 synthesizer in stereo .253

## 8 File management: No closed book 230

8.1 Cassette - Floppy Disk .259
8.2 The principle of file management: Sequential files .266
8.3 Copying files with one and two drives .280
8.4 How to do it faster: Relative files .284
8.5 Another method: direct access .304
8.6 Rescuing an improperly closed .308 file
8.7 The block chaser .314

<!-- TOC PAGE_10: Commodore 64 programming routines guide -->===========================================================
                       PAGE 10 OF 386                       
===========================================================

9. Poke's and other useful routines

9.1 The cassette buffer as program memory. . . . .319
9.2 Sorting string fields. . . . . . . . . . .322
9.3 Minimum and maximum of numeric fields. . .327
9.4 DUMP - Output of all variables
and their values. . . . . . . . . . . . . . . . . . .334
9.5 Modified PEEK function. . . . . . . . . . .339
9.6 Multitasking on the Commodore 64. . . . . . .343
9.7 POKE's and the zero page. . . . . . . . . . . .353
9.8 Control of text input via the keyboard. . .355
9.9 Formatted program listing. . . . . . . . . . .359
9.10 Saving variables and warm start. . . . . . .362

<!-- TOC PAGE_11: Commodore 64 promotional book intro -->

===========================================================
                       PAGE 11 OF 386                       
===========================================================

1

# FOREWORD

The Commodore 64 makes thousands of new friends around the world every day. This is not surprising, because the 64 not only offers excellent performance data, but also an excellent price/performance ratio. You can now get a Commodore 64 including a floppy disk drive for well under 2000 marks. If you add the new CP/M module, it's still under 2000 marks. And that for a complete computer system that not only includes the two most common processors 6502 and Z-80 but also the two most popular operating systems CP/M and COMMODORE BASIC. The Commodore 64 may have an entry-level price, but it's far too good just to get in and play. Rather, it offers the committed hobby programmer an almost limitless field of activity and can easily be used for smaller commercial and technical-scientific applications. Here 64 TIPS &amp; TRICKS, our second book on the Commodore 64. Our proven team of authors, consisting of Klaus Gerits, Lothar Englisch and Michael Angerhausen, have once again dug deep into their bag of tricks. Using countless examples and sample programs, the authors would like to give you suggestions for your own work with the Commodore 64. This book is also intended to help you get more out of your Commodore 64. All three authors know the 64 like the back of their hand. Klaus Gerits, for example, developed IEC-BUS 64 and MAXI 64, Lothar Englisch developed PROFI-MON 64 and PROFI-ASS 64. Both have dealt in detail with the technical and system-related properties of the 64. The results include, for example, projects with the user port and a detailed treatment of the CP/M module, of course with a detailed documented BIOS listing. Michael Angerhausen, our database specialist, dealt extensively with the 64 from the aspect of file management. Among other things, he shows how you can create relative files using BASIC 2.0.

Our authors would be happy to receive comments on this book and suggestions for further work. Here's an answer right away

<!-- TOC PAGE_12: Commodore 64 book preface -->

===========================================================
                       PAGE 12 OF 386                       
===========================================================

to the often asked question: Can you actually work on DATA BECKER books? - One can! We are happy to accept new authors, regardless of whether they just have a contribution or even a completely original book.

Have fun reading 64 TIPS &amp; TRICKS.

Foreword to the expanded and revised 2nd edition

Within a few months, the first 10,000 copies of 64 Tips &amp; Tricks out of stock. We took the opportunity of the new edition to revise this popular book and expand it in essential parts.

To all machine programs and routines from 64 TIPS &amp; TRICKS you will now also find a BASIC loader. With the help of these simple BASIC programs, all non-machine programmers can now easily enter and fully use the programs in machine language. The respective BASIC loader also checks the program for input errors.

Foreword to the expanded and revised 4th edition

Through our intensive work with the Commodore 64, we discovered a few interesting things that we don't want to withhold from you. New subject areas such as ADA, copy protection and block trackers were added by Mr. Frank Thrun.

Düsseldorf, October 1984

The authors

<!-- TOC PAGE_13: Commodore 64 graphics guide -->===========================================================
                       PAGE 13 OF 386                       
===========================================================

3

# CHAPTER 2: ADVANCED GRAPHICS

## 2.1 GRAPHICS ON THE COMMODORE 64

Every user of the Commodore 64 naturally wants to work with the built-in graphics of this computer sooner or later. Unfortunately, in the manual he only learns very briefly and briefly about the capabilities and options available with the Commodore 64.

At this point we would like to go into the graphic possibilities and special features in more detail.

First of all, with the Commodore 64 you have to differentiate between the normal graphics that can be accessed via the keyboard (i.e. the block or line graphics), the high-resolution graphics and the sprites. Only a few computers offer block graphics and high-resolution color graphics - but the SPRITES are a real innovation on the Commodore 64. These SPRITES are so far only known from the many slot machines. They know the fantastic games there, whether adventure, SPACE games or action games. And the Commodore 64 offers us exactly these options today.

On the next few pages we want to go into the three different graphics modes. Of course, the theory is again supported by examples.

<!-- TOC PAGE_14: Commodore 64 graphics tutorial -->

===========================================================
                       PAGE 14 OF 386                       
===========================================================

4

#1. The block or line graphics of the keyboard.

This option for creating graphics on the Commodore 64 is the simplest and most convenient way. There is no need to calculate any addresses or pay attention to different registers. You can create different symbols in the program from the keyboard and display them directly. To reach these symbols, two keys must be pressed. If you take a closer look at the keyboard of the Commodore 64, you will notice that almost every key on the device has two functions. The symbol or graphic symbol on the left side of the key is accessed by simultaneously pressing the C= (CBM) key and the corresponding key on which the symbol is located.

When entering a program, you can always enter these characters within a PRINT or INPUT statement. For example, you write:

#100 PRINT

and then press the C= and A keys. You will now see the upper right corner of a frame on the screen. To create an entire frame, the following additional entries are necessary (we are still on line 100):

Press the SHIFT and * keys 38 times. You will now see how to draw a straight line from the corner of the frame at the same height. You have also now learned that by pressing SHIFT and another key, the right character can be entered on that key. Now press the C= and S keys again and the upper part of a frame is finished. At the end of line 100, enter:

"; and press the RETURN button

<!-- TOC PAGE_15: Commodore 64 programming instructions -->===========================================================
                       PAGE 15 OF 386                       
===========================================================

You can now enter the next line as follows:

## 110 PRINT "

Then press: SHIFT and - once, the space bar 38 times and SHIFT and - again. Finally, enter again:

"; and press the RETURN button.

The second line of the frame is now finished. Now write the third and last line as follows:

## 120 PRINT "

and then 1 time C= and Z, 38 times SHIFT and * and 1 time C= and X. Now you have completed the entire frame, consisting of 3 lines. Now enter the following program lines:

```
99 PRINT CHR$(147);: REM CLEAR SCREEN
132 A$=" "
135 REM A$=PRESS SPACEBAR 38 TIMES
140 B$="THIS LINE FILLS OUR FRAME"
150 PRINT CHR$(19);
160 PRINT CHR$(17);CHR$(29);A$;
170 PRINT CHR$(19);
180 PRINT CHR$(17);CHR$(29);B$;
190 FOR I=1 TO 1000: NEXT
200 GOTO 150
```

All commercial programs today are made very clear and user-friendly through the use of such frameworks. As you can see, the Commodore 64 can also be programmed like the “big ones”.

Of course, there is also another way to enter such graphic symbols. These symbols can all also be accessed using the CHR$ function. For example in our program:

<!-- TOC PAGE_16: BASIC program code snippet -->

===========================================================
                       PAGE 16 OF 386                       
===========================================================

100 A1$=CHR$(176): A2$=CHR$(174)
101 REM THE LEFT AND RIGHT TOP CORNER
102 A3$=CHR$(173): A4$=CHR$(189)
103 REM THE LEFT AND RIGHT BOTTOM CORNER
104 H1$=CHR$(96)
105 REM THE HORIZONTAL LINE
106 H2$=CHR$(125)
107 REM THE VERTICAL LINE
108 H3$=CHR$(32)
109 REM THE SPACE
110 Z1$=A1$
111 FOR I=1 TO 38
112 Z1$=Z1$+H1$
113 NEXT I
114 Z1$=Z1$+A2$
115 REM 1ST LINE OF THE FRAME
116 Z2$=H2$
117 FOR I=1 TO 38
118 Z2$=Z2$+H3$
119 NEXT I
120 Z2$=Z2$+H2$
121 REM 2ND LINE OF THE FRAME
122 Z3$=A3$
123 FOR I=1 TO 38
124 Z3$=Z3$+H1$
125 NEXT I
126 Z3$=Z3$+A4$
127 REM 3RD LINE OF THE FRAME
128 PRINT Z1$;
129 PRINT Z2$;
130 PRINT Z3$;

When you enter these new lines and start the program, you will have the same result as before. The advantage is simply that programs written with such CHR$ functions are easier to read and modify.

6

<!-- TOC PAGE_17: Commodore 64 sprite programming guide -->===========================================================
                       PAGE 17 OF 386                       
===========================================================

7

#2. Using SPRITES

But your Commodore 64 can do more than just draw simple lines. As I said at the beginning, it offers you options that were previously reserved for large slot machines.

The Commodore 64 is able to independently manage up to 8 different “small graphics”. We call these small graphics SPRITES. You can move, delete, collide, and much more independently of each of these maximum 8 sprites using simple POKEs. However, in order to be able to work sensibly with SPRITES, you have to deal in detail with the corresponding registers of the Commodore 64. The complete register plans can be found in the book "64 intern". At this point we just want to briefly discuss the various options for sprite manipulation.

As already mentioned, we have different registers available for each sprite. It would be beneficial if you first experiment with the SPRITES, which you can find in the Commodore manual.

The most important address when using the sprites is the number 53248. This address indicates the start of the video controller. The built-in VIC (video controller) 6569 works with these addresses. In order to position a sprite, for example, we have to tell the VIC chip where to draw the sprite. The register for this is register 0 (or more precisely the address 53248). In this address we find the horizontal position and in register 1 (53249) the vertical position of the sprite.

POKE 53248,160: POKE 53249,120

So 2 POKEs are enough to place an entire small graphic at a specific screen position. Place the sprite in the center of the screen. Registers 0 and 1 serve sprite 1, registers 2 and 3 serve sprite 2, etc. Almost all other registers work according to the same principle. As already mentioned, you can find the most detailed information about working with the sprites in “64 internal”. On the next pages you will learn how you can create complex graphics without much effort.

<!-- TOC PAGE_18: Commodore 64 3D graphics program -->

===========================================================
                       PAGE 18 OF 386                       
===========================================================

2.2 3D GRAPHICS - BASIC PROGRAM

Right at the beginning of our book we would like to introduce you to a BASIC program that uses the high-resolution color graphics of the Commodore 64 to bring three-dimensional representations to the screen. The program uses the commands of Supergraphics 64; However, below you will find the necessary changes if you do not have this program.

The program represents a function that you can define on line 100 of the program. The function can be represented in three different ways:

- First, in a normal Cartesian (rectangular) coordinate system, just as you would plot the function on graph paper.
- Secondly, representation in polar coordinates (specification of radius and angle) is possible.
- The most interesting thing is undoubtedly the three-dimensional representation. To do this, the function is rotated around the (vertical) Y axis. However, because of the large number of points to be calculated, this type of representation takes the longest time. You can influence the display parameters as much as possible.

Now for the description of the program. First you can select the display type (lines 40-70). For the Cartesian and polar representation you will then be asked for the function increment (line 260). This is the value by which the horizontal axis parameter is increased after each calculated point. Lines 270 and 280 ask for the factor for the X and Y axes. This allows you to determine the scale ratio of the axes. To start, you can enter 1 both times. When moving horizontally and vertically

<!-- TOC PAGE_19: Graphic plotting program instructions -->===========================================================
                       PAGE 19 OF 386                       
===========================================================

(Lines 370-410) we can initially enter zero. In line 430 a switch is made to graphics mode. Lines 450 to 560 draw the axis cross and scaling. Lines 680 to 790 show the polar representation, lines 820 to 970 show the rectangular representation.

The three-dimensional representation starts from line 1010. First you can determine the scale and position of the display again; To start, enter the suggested values ​​of 20 or 90. For the three-dimensional representation, the function in line 100 must be calculated several tens of thousands of times; Depending on the function, the program requires around half an hour to several hours.

Run the program once with various functions; As a suggestion, here are a few functions that produce interesting representations.

$$
\begin{array}{l}
100 \text{ DEF FN R}(Q) = \text{COS } (2*Q) + \text{COS } ((Q + BB)/16) \\
100 \text{ DEF FN R}(Q) = \text{SQR } (\text{ABS}(.5*(16-Q*Q)) + 1/(Q+4) \\
100 \text{ DEF FN R}(Q) = \text{COS } (4*Q) + 20/(Q*Q + 3) \\
\end{array}
$$

If you don't have a supergraphic, you need to make the following changes and additions to the program:

- Line 5 POKE 56.32 : CLR
- Line 430 and 1400: GOSUB 2000 each
- Line 470 FOR A1=0 TO 199 : AX=F: AY=A1: GOSUB 3000 : NEXT
- Line 480 FOR A1=0 TO 319 : AX=A1: AY=E: GOSUB 3000 : NEXT
- Line 500 FOR A1=E-1 TO E+1: AX=XR: AY=A1: GOSUB 3000: NEXT
- Line 520 FOR A1=E-1 TO E+1: AX=XL: AY=A1: GOSUB 3000: NEXT
- Line 540 FOR A1=F-1 TO F+1: AX=A1: AY=YD: GOSUB 3000: NEXT
- Line 560 FOR A1=F-1 TO F+1: AX=A1: AY=YU: GOSUB 3000: NEXT
- Line 770 AX=XX: AY=YY: GOSUB 3000
- Line 900 AX=G: AY=YY: GOSUB 3000
- Line 1600 AX=X1: AY=Y1: GOSUB 3000

<!-- TOC PAGE_20: BASIC graphics programming code -->

===========================================================
                       PAGE 20 OF 386                       
===========================================================

Line 1620 GOSUB 4000 : RETURN

Line 2000 FOR A1=8192 TO 16191 : POKE A1,0 : NEXT

Line 2010 FOR A1=1024 TO 2023 : POKE A1,16: NEXT

Line 2020 POKE 53248+17, 27+32 : POKE 53248+24, 16+8

Line 2030 RETURN

Line 3000 OY=320*INT(AY/8)+(AYAND7)

Line 3010 OX=8*INT(AX/8)

Line 3020 MA=2↑((7-AX)AND7)

Line 3030 AV=8192+OY+OX

Line 3040 POKE AV,PEEK(AV) OR MA : RETURN

Line 4000 FOR A1=Y1+1 TO 199: AX=X1: AY=A1: GOSUB 5000: RETURN

Line 5000 OY=320*INT(AY/8)+(AYAND7)

Line 5010 OX=8*INT(AX/8)

Line 5020 MA=2↑((7-AX)AND7)

Line 5030 AV=8192+OY+OX

Line 5040 POKE AV,PEEK(AV) AND NOT MA : RETURN

By programming the graphics functions in BASIC, the program becomes significantly slower compared to programming with Supergraphics 64.

10 PRINT "GRAPHIC REPRESENTATION OF FUNCTIONS"

20 PRINT" DEFINED IN LINE 100%

40 PRINT" 1 - CARTESIC REPRESENTATION"

50 PRINT" 2 - POLAR COORDINATES"

60 PRINT" 3 - 3D REPRESENTATION"

70 INPUT" SELECTION: 100;PL

100 DEF FNR(Q)=COS(Q)+COS(2*Q)+COS(5*Q)

210 IFPL=3THEN1010

250 PRINT:PRINT

260 INPUT" FUNCTION INCREMENT =";IK

<!-- TOC PAGE_21: BASIC graphics plotting program -->

===========================================================
                       PAGE 21 OF 386                       
===========================================================

270 INPUT "FACTOR FOR X-AXIS =";S1
280 INPUT "FACTOR FOR Y-AXIS =";S2
370 PRINT "MOVE JUMP LEFT OR RIGHT"
380 INPUT "NUMBER FROM -130 TO 130";C
400 PRINT "MOVE JUMP UP OR DOWN"
410 INPUT "NUMBER FROM -90 TO 90";D
430 0.1:
450 E=100+D:F=160+C
470F,0TOF,199
480 0,E TO 319,E
490 FORXR=FTO319STEP19*S1
500XR,E-1TOXR,E+1
510 FORXL=FTO0STEP-19*S1
520 XL,E-1TOXL,E+1
530 FORYD=ETO199STEP15*S2
540 F-1,YDTOF+1,YU
550 FORYU=ETO0STEP-15*S2
560 F-1,YUTOF+1,YU
580 IFPL=1THEN820
610 REM POLAR PLOT
690 RD=/180:FORG=0TO360STEPIK:T=G*RD
710 X=FNR<t>*COS<t>;Y=FNR<t>*SIN<t>
730 XX=X*(19*S1)+F:YY=-Y*(15*S2)+E
740 IFXX&lt;0ORXX&gt;319THEN780
750IFYY&lt;0ORYY&gt;199THEN780
770XX,YY
780 NEXT
790 END
820 REM CARTESIAN PLOT
830 FORG=0TO319STEPIK
840 X=<g-f>/<19*s1>;Y=FNR<x>
850 YY=E-<y*15*s2>
860 IFYY&lt;0ORYY&gt;199THEN960
900G,YY
960 NEXT
970 END
1010 REM 3D PLOT
1020 PRINT "JURXVERTICAL SCALE"
1030 PRINT "XOBBJ-40 TO 40 2011111";:IN PUTN1
1040 PRINT "JURXVERTICAL LOCATION"
1050 PRINT "XOBBJ-50 TO 150 9011111";:IN PUTN2

11</y*15*s2></x></g-f></t></t>

<!-- TOC PAGE_22: BASIC programming code listing -->===========================================================
                       PAGE 22 OF 386                       
===========================================================

1260 REM CONSTANTS A,B,C,D,E,F,G
1280 A=144:B=2.25:C=N1:D=.0327:E=160:F=N
2:G=199
1400 0.1:
1410 FORH=-ATOASTEPB
1420 AA=INT(.5+SQR(A*A-H*H))
1430 FORBB=-AATOAA:CC=SQR(BB*BB+H*H)*D
1440 D1=FNR(CC):DD=D1*C:GOSUB1520:NEXT:N
EXT:END
1450 GOTO1450
1520 X=BB+H/B+E:Y=DD-H/B+F
1530 X1=INT(.85*X):Y1=INT(.9*(G-Y)):IFY&lt;
0ORY&gt;199THENRETURN
1600X1,Y1
1620 E X1,Y1+1TOX1,199:RETURN

On the next page you will find the results of this program.

12

<!-- TOC PAGE_23: Driver's license front and back -->

===========================================================
                       PAGE 23 OF 386                       
===========================================================

![img-1.jpeg](img-1.jpeg)

![img-2.jpeg](img-2.jpeg)

![img-3.jpeg](img-3.jpeg)

13

<!-- TOC PAGE_24: Machine program for colored bar charts -->

===========================================================
                       PAGE 24 OF 386                       
===========================================================

14

## 2.3 COLOR BAR GRAPHICS

The following machine program is used to draw horizontal or vertical colored bar graphics. This allows curves and tables to be clearly displayed graphically in color on the screen. Since the graphic is created with normal screen characters, the display can be mixed with text as desired, e.g. to label the graphics. The bars are each 8 pixels equal to one character wide and can resolve 320 points horizontally or 200 points vertically.

The machine program was designed so that length or height and the color can be specified. The bar graphic is drawn from the current cursor position. In order to simplify the display of complete graphics, the cursor is moved one to the right after a vertical bar (which is drawn from bottom to top) is output, so that the next bar can be drawn immediately (in a different color if necessary). For horizontal bar graphics, the cursor automatically moves down by one.

The call is made using an extended SYS command:

SYS H, L, C or
SYS V, L, C

where H and V are the start addresses of the horizontal and vertical graphics routines, L is the length of the graphic up to 320 and 200, respectively, and C is the color code (0 to 15).

The machine program is printed below:

<!-- TOC PAGE_25: Assembly code listing -->

===========================================================
                       PAGE 25 OF 386                       
===========================================================

15

100: c000 .opt p1
; colored bar graph
; hplot and vplot

130: c000 getcor = $b7eb
140: c000 scrout = $e716
150: c000 lbyt = $14
160: c000 hbyt = lbyt + 1
170: c000 curcol = $d3
180: c000 setcol = $ea24
190: c000 setchar = $ea1e
200: c000 illquan = $b248
205: c000 chkcom = $aefd
210: c000 code = $22
220: c000 tmp = code + 1
230: c000 xreg = tmp + 1
235: c000 tmp1 = xreg + 1
240: c000 color = $f3 ; pointer to color ram
250: c000 curright = $ab3b
260: c000 adr = $fd
270: c000 linelen = $d5
280: c000 charadr = $d1
290: c000 *= $c000
300: c000 20 fd ae hplot jsr chkcom ; comma
310: c003 20 eb b7 jsr getcor
315: c006 86 24 stx xreg
320: c008 a5 15 lda hbyt
330: c00a c9 02 cmp #2
340: c00c b0 42 bcs ill
350: c00e 0a asl
350: c00f 0a asl
350: c010 0a asl
350: c011 0a asl
350: c012 0a asl

<!-- TOC PAGE_26: Assembly code listing -->===========================================================
                       PAGE 26 OF 386                       
===========================================================

16

360: c013 85 23 sta tmp
370: c015 a5 14 lda lbyt
380: c017 48 pha
390: c018 4a lsr
390: c019 4a lsr
390: c01a 4a lsr ; through 8
400: c01b 18 clc
410: c01c 65 23 adc tmp
420: c01e 65 d3 adc curcol ; cursor column
430: c020 48 pha
440: c021 a8 tay
450: c022 c5 d3 cmp curcol
460: c024 f0 13 beq t1
470: c026 c9 27 cmp #39 ; &lt; 40
480: c028 90 02 bcc t2
490: c02a a0 27 ldy #39
500: c02c 20 24 ea t2 jsr setcol ; pointer to color ram
510: c02f a9 a0 lda #" " + $80 ; reverse blank
540: c031 20 1e ea jsr setchar ; set characters and colors
550: c034 88 dey
560: c035 c4 d3 cpy curcol
570: c037 10 f3 bpl t2
580: c039 68 t1 pla
590: c03a a8 tay
600: c03b 68 pla
610: c03c c0 28 cpy #40
620: c03e b0 0b bcs done
630: c040 29 07 and #7
640: c042 aa tax
650: c043 bd 53 c0 lda table,x
655: c046 a6 24 ldx xreg
660: c048 20 1e ea jsr setchar
670: c04b a9 11 done lda #17 ; cursor down
680: c04d 4c 16 e7 jmp scrout

<!-- TOC PAGE_27: 6502 assembly code listing -->

===========================================================
                       PAGE 27 OF 386                       
===========================================================

17

690: c050 4c 48 b2 ill jmp illquan
700: c053 20 65 74 table .byt $20,$65,$74,$75,$61,$f6,$ea,$e7
1000: c05b 20 fd ae vplot jsr chkcom
1010: c05e 20 eb b7 jsr getcor
1020: c061 a5 15 lda hbyt
1030: c063 d0 eb bne ill
1040: c065 86 24 stx xreg ; color
1050: c067 a5 14 lda lbyt
1060: c069 4a lsr
1060: c06a 4a lsr
1060: c06b 4a lsr ; through 8
1070: c06c 85 23 sta tmp
1080: c06e a5 14 lda lbyt
1090: c070 29 07 and #7
1100: c072 85 25 sta tmp1
1110: c074 a5 d1 lda charadr ; line address
1120: c076 18 clc
1130: c077 65 d3 adc curcol ; plus cursor column
1140: c079 85 fd sta adr
1150: c07b a5 d2 lda charadr + 1
1160: c07d 69 00 adc #0
1170: c07f 85 fe sta addr+1
1180: c081 a0 00 ldy #0
1190: c083 a6 23 ldx tmp
1200: c085 f0 20 beq t3
1210: c087 20 c7 c0 t4 jsr color ; Calculate color address
1270: c08a a9 a0 lda #" " + $80
1275: c08c 91 fd sta (adr),y
1280: c08e a5 24 lda xreg ; color
1290: c090 91 f3 sta (color),y ; set characters and colors
1300: c092 a5 fd lda addr
1310: c094 38 sec
1320: c095 e9 28 sbc #40 ; next line
1330: c097 85 fd sta adr

<!-- TOC PAGE_28: 6502 assembly code listing -->

===========================================================
                       PAGE 28 OF 386                       
===========================================================

18

|  1340: | c099 b0 08 | bcs | t5 |
| --- | --- | --- | --- |
|  1350: | c09b c6 fe | dec | addr+1 |
|  1360: | c09d a5 fe | lda | addr+1 |
|  1370: | c09f c9 04 | cmp | #4 ; Top line reached?  |
|  1380: | c0a1 90 12 | bcc | t6 |
|  1390: | c0a3 c6 23 t5 | dec | tmp |
|  1400: | c0a5 d0 e0 | bne | t4 |
|  1410: | c0a7 20 c7 c0 t3 | jsr | color |
|  1470: | c0aa a6 25 | ldx | tmp1 |
|  1480: | c0ac bd bf c0 | lda | tab2,x |
|  1485: | c0af 91 fd | sta | (adr),y |
|  1490: | c0b1 a5 24 | lda | xreg ; color |
|  1500: | c0b3 91 f3 | sta | (color),y |
|  1510: | c0b5 a5 d3 t6 | lda | curcol |
|  1520: | c0b7 c5 d5 | cmp | linelen ; cursor in last column?  |
|  1530: | c0b9 f0 03 | beq | * + 5 |
|  1540: | c0bb 4c 3b ab | jmp | curright ; cursor right |
|  1550: | c0be 60 | rts |   |
|  1560: | c0bf 20 64 6f tab2 | .byt | $20,$64,$6f,$79,$62,$f8,$f7,$e3 |
|  1570: | c0c7 a5 fd color | lda | addr |
|  1580: | c0c9 85 f3 | sta | color |
|  1590: | c0cb a5 fe | lda | addr+1 |
|  1600: | c0cd 4c 2a ea | jmp | setcol + 6 |

Here is a loading program in BASIC for those who do not have an assembler or monitor available.

100 for i = 49152 to 49359
110 read x : poke i,x : s=s+x : next
120 data 32,253,174, 32,235,183,134, 36,165, 21,201, 2
130 data 176, 66, 10, 10, 10, 10, 10,133, 35,165, 20, 72
140 data 74, 74, 74, 24,101, 35,101,211, 72,168,197,211
150 data 240, 19,201, 39,144, 2,160, 39, 32, 36,234,169

<!-- TOC PAGE_29: BASIC program data analysis -->===========================================================
                       PAGE 29 OF 386                       
===========================================================

160 data 160, 32, 30,234,136,196,211, 16,243,104,168,104
170 data 192, 40,176, 11, 41, 7,170,189, 83,192,166, 36
180 data 32, 30,234,169, 17, 76, 22,231, 76, 72,178, 32
190 data 101,116,117, 97,246,234,231, 32,253,174, 32,235
200 data 183,165, 21,208,235,134, 36,165, 20, 74, 74, 74
210 data 133, 35,165, 20, 41, 7,133, 37,165,209, 24,101
220 data 211,133,253,165,210,105, 0.133,254,160, 0.166
230 data 35,240, 32, 32,199,192,169,160,145,253,165, 36
240 data 145,243,165,253, 56,233, 40,133,253,176, 8,198
250 data 254,165,254,201, 4,144, 18,198, 35,208,224, 32
260 data 199,192,166, 37,189,191,192,145,253,165, 36,145
270 data 243,165,211,197,213,240, 3, 76, 59,171, 96, 32
280 data 100,111,121, 98,248,247,227,165,253,133,243,165
290 data 254, 76, 42,234
300 if s &lt;&gt; 26696 then print "error in datas!!" :end
310 print "ok!"

Now let's look at a possible application of the graphics routines. First we want to display sales statistics graphically.

100 rem in the data statement are the monthly sales figures
110 rem saved in a year
120 dim u(12)
130 rem reading the data
140 for i = 1 to 12 : read u(i) : next
150 rem determination of the maximum value
160 max = 0
170 for i = 1 to 12
180 if u(i) &gt; max then max = u(i)
190 next
200 v = 12*4096+5*16+11 : rem address of the machine routine
220 print chr$(147) : clear screen
230 for i = 1 to 21 : print chr$(17); : next : rem cursor

19

<!-- TOC PAGE_30: BASIC programming code example -->

===========================================================
                       PAGE 30 OF 386                       
===========================================================

240 rem drawing graphics
250 for i = 1 to 12
260 print spc(2); : sys v, u(i)/max * 180 , i
270 next
280 print : print
290 rem write month numbers
300 for i=1 to 12
310 print right$(" "+str$(i),3);
320 next
330 get a$ : if a$ ="" then 330
400 rem sales data
410 data 12000, 13500, 11000, 8000, 14000, 9000
420 data 13800, 14000, 12750, 14000, 13800, 17200

After the vertical bar graph example, let's look at a function with the horizontal bar graph.

The color code is entered in line 100. Then the screen is cleared, the background is switched to black and the cursor is moved to the second column. In lines 120 and 130, the function from -2.2 to 2.2 is calculated, brought to a representable size by multiplying by 300 and plotted with the SYS command.

100 input "color ";c:if c&lt;1 or c&gt;15 then 100
110 h=12*4096 : print chr$(147)tab(2); : poke53281.0
120 for i=-2.2 to 2.2 step .2
130 sys h,exp(-i*i)*300,c : next

20

<!-- TOC PAGE_31: Commodore 64 custom character guide -->

===========================================================
                       PAGE 31 OF 386                       
===========================================================

21

# 2.4 DEFINITION OF YOUR OWN CHARACTER SET

One of the special features of the Commodore 64 is the ability to put the character generator in RAM. This gives you the opportunity to define your own characters.

So how is a character defined?

Each character is determined by its so-called character matrix, which consists of 8 * 8 points. Each matrix point is determined by a bit in the character generator, totaling 64 bits or 8 bytes. If a bit is zero, the corresponding point in the matrix is ​​not set. A set bit means a set point in the character matrix. The following small program displays the matrix of a character on the screen. The program uses the modified PEEK function from Chapter 9.5 - so load or enter this program first before entering the program.

```txt
100 PRINT "INDEX"
110 INPUT "PLEASE ENTER CHARACTER";A$
120 PRINT "A$ :C=PEEK&lt;1024&gt;
130 PRINT:PRINT:PRINT:PRINT
140 CG = 13*4096 : REM START OF THE CHARACTER
GENERATORS
150 REM DETERMINATION OF SMALL/LARGE OR
GRAPHICS MODE
160 B = <peek(53248+24) 2="" and=""> * 1024
170 FOR I = 0 TO 7
180 Z = USR <cg+b+8*c+i> : REM: MATRIX ZE
GET IT BY WAY
190 FOR J=7 TO 0 STEP -1
200 A = Z AND 2↑J
210 IF A THEN PRINT "*"; GOTO 230
220 PRINT ",";
230 NEXT:PRINT:NEXT</cg+b+8*c+i></peek(53248+24)>

<!-- TOC PAGE_32: Character matrix definition guide -->===========================================================
                       PAGE 32 OF 386                       
===========================================================

The program asks for the character whose matrix you want to view. The character's screen code is fetched into variable B on line 120. Line 140 checks for large/small or large/graphics mode. In line 160 the starting position of the character matrix in the character generator is determined. Line 180 determines whether a matrix point is set or not. Depending on this, either a star or a point is drawn. If you enter a "T" you will get the following output:

```
. * * * * * .
... ** ...
... ** ...
... ** ...
... ** ...
... ** ...
```

Now that you have looked at the matrix of individual characters, we can start defining our own characters. To do this, we have to transfer the character generator from ROM to RAM and then tell the operating system where the new character generator is located. At the same time, the screen memory is moved to address $C400 (decimal from 50176 to 51175). This can be done from BASIC with a POKE loop. We use the USR function from Chapter 9.5 again.

```
100 FOR I=13*4096 TO 14*4096-1
110 POKE I+4096,USR(I) : NEXT
120 POKE 53272.24 : POKE 56576.148 : POKE 648.196
```

22

<!-- TOC PAGE_33: BASIC character definition program -->

===========================================================
                       PAGE 33 OF 386                       
===========================================================

After running this program, we can define our own characters using the following program. The program will write after the character you want to change. Then you can enter the character matrix; a star means a point has been set and a dot means no point has been set. If you want to end the program, please enter the word 'END' as the symbol.

```basic
100 REM CHARACTER DEFINITION
110 CG=14*4096: REM BASE OF CHARACTER GENE
ERATORS
200 INPUT "CHARACTERS ";A$:IFA$="END
E"THENEND
210 PRINT"A$
220 C=PEEK&lt;12*4096+1024&gt;
230 PRINT"01234567"
300 FOR I=0 TO 7
310 PRINTS; :INPUTA$&lt;I&gt;:IFLEN&lt;A$&lt;I&gt;&gt;&lt;&gt;8TH
ENPRINT"□":GOTO310
320 NEXT
400 B=&lt;PEEK&lt;53248+24&gt;AND2&gt;*1024 : REM GR
OSS/GRAPHICS MODE
405 AD=CG+B+C*8
410 FOR I=0 TO 7 : Z=0
420 FOR J=0 TO 7
430 Z=Z-<mid$<a$<i>,8-J,1)="*">*2↑J
440 NEXT
450 POKE AD+I,Z : REM CHARACTERS
460 POKE AD+1024+I,255-Z : REM RVS MARK
EN
470 NEXT
480 GOTO 200</mid$<i>

<!-- TOC PAGE_34: Joystick-controlled character design guide -->

===========================================================
                       PAGE 34 OF 386                       
===========================================================

24

# 2.5 MODIFICATION OF THE CHARACTER SET USING JOYSTICK

For certain purposes it is often desirable to have special characters and symbols available that appear immediately when a key is pressed. These include, for example, Greek letters, which are often used in mathematical formulas.

Small game characters are also conceivable, which can also be created with sprites, although this is a little more complex to create and handle.

If you are familiar with the appropriate procedures, you can first draw your figures as a grid representation on a piece of paper and then poke the determined values into the duplicate of the character generator, but that is definitely not for everyone.

We have therefore written a small program with which you can easily create the desired character on the screen and follow its development.

The only requirement for this is a joystick on control port 1.

The way the program works is that first two duplicates of the character generator are copied into RAM.

A character is taken from the first duplicate and displayed as a sprite, once in its original size and once in double size for better readability.

A flashing dot appears in the sprites, the so-called microcursor, which you can now move using the joystick.

You can select the desired action, namely draw a line, delete a line or just position it, by pressing the button on the joystick.

If the sign turns out to your satisfaction, so be it

<!-- TOC PAGE_35: C64 character editor instructions -->===========================================================
                       PAGE 35 OF 386                       
===========================================================

press the F1 key.

The new character is now applied to the displayed position of the alternative character set (2nd duplicate).

If you want the displayed character to remain unchanged, press the G key.

Now you can edit the next character.

After you have edited all 512 characters, the program exits.

Why 512 characters?

Well, for one operating mode, namely uppercase/graphics or uppercase/lowercase, there are 128 displayable characters. The same characters again in reverse representation makes 256. That makes a total of 512 for both operating modes.

The positions assigned to the characters in the character generator can be found on pages 132ff in the C64 operating manual.

Before we discuss the program in detail, you should know the meaning of the variables and memory addresses used.

First the variables:

- C Base address of the 1st duplicate of the character to be displayed next
- CD base address of the character to be transmitted in the 2nd duplicate
- CP character position counter in area O-511
- JB Condition of the button on the joystick
- JR joystick stick position
- JS address of control port 1
- MA counter for the operating status
- PO microcursor position within the addressed byte
- PP address within the sprite data where the microcursor is currently located
- PV instantaneous value of the byte of the sprite data, which is represented by

25

<!-- TOC PAGE_36: Retro computer sprite memory guide -->

===========================================================
                       PAGE 36 OF 386                       
===========================================================

the joystick is currently addressed

SB base address of the sprite data

V Base address of the video controller

X x position of the sprites on the screen

XJ x position of the microcursor controlled by the joystick

Y y position of the sprites on the screen

YJ y position of the microcursor controlled by the joystick

Now the addresses:

56 Higher byte of the pointer to the upper memory limit
648 Pointer to the start of the videoram
832 Start address of the cartridge buffer.

Since this is not needed elsewhere within the program, the machine program is stored here.

50169 Pointer for sprite 1
50170 Pointer for Sprite 2
53272 Pointer for videoram and character generator within the video controller
56576 Here are the two bits for defining the 16k range for the memory associated with the screen.

The step-by-step introduction to the program follows:

10 The memory upper limit is reduced because the first duplicate of the character set is to be stored here.
30-70 The sprites 1+2 are switched on and their color is set.

<!-- TOC PAGE_37: 6502 assembly code snippet -->

===========================================================
                       PAGE 37 OF 386                       
===========================================================

Now the sprite pointers are loaded and then sprite 2 is switched to double size.

The sprite data is first deleted and then the sprites are positioned approximately in the middle of the screen.

1000-1010 The machine program is here.

For those interested, below is the assembler notation:

|  be |  | Prevent interrupt |
| --- | --- | --- |
|  lda | #$33 | Character generator to- |
|  sta | 1 | make accessible |
|  lda | #0 |   |
|  sta | $5f | old block start lo |
|  sta | $5a | old block end lo |
|  sta | $58 | new block end lo |
|  lda | #$d0 |   |
|  sta | $60 | old block start hi |
|  lda | #$f0 |   |
|  sta | $59 | new block end hi |
|  lda | #$e0 |   |
|  sta | $5b | old block end hi |
|  jsr | $a3bf | Block move routine |
|  lda | #$37 |   |
|  sta | 1 |   |
|  cli |  | Allow interrupt |
|  rts |  | back to Basic |

1020-1040 The machine program is brought into the cassette buffer and executed, i.e. two duplicates are generated by the character generator.

1060 The operating system is modified

<!-- TOC PAGE_38: C64 character generator documentation -->===========================================================
                       PAGE 38 OF 386                       
===========================================================

conditions communicated.

The position of the character generator and (necessarily due to the hardware) videoram were changed. The characters you see on the screen now are from the 2nd duplicate.

2000-2360 The characters are now transferred one after the other into the sprite data and can be changed.

2380 After all characters have been processed, the option to save the new character set is offered.

4000-4070 The joystick is queried and branches depending on the position of the stick and button.

5000-12040 Depending on the position of the joystick, the cursor position is updated.

13000-13200 The position of the joystick is converted to the point position of the microcursor and this point is alternately switched on and off.

20000-20060 Here the character found to be good is transferred to the 2nd duplicate.

30000-30200 The newly created character set can be saved here on diskette (8) or cassette (1).

Another special feature of this program is that the modified character generator does not use any basic memory. It is located in the RAM under the operating system (this should be taken literally, as we know that the C64 has Ram and Rom overlapping).

The videoram now has the start address 49152, which you will want to take into account when poking into it. Unfortunately, due to the hardware of the C64, moving the character generator also means moving the video ram

28

<!-- TOC PAGE_39: Commodore 64 assembly program listing -->

===========================================================
                       PAGE 39 OF 386                       
===========================================================

takes place. You can find this problem explained in more detail in our book '64 intern'.

Finally the program listing:

10 poke56,144:clr:v=53248
30 pokev+21.6:pokev+40.1:pokev+41.1
40 poke50169,16:poke50170,16:pokev+23.4:pokev+29.4
50 fori=0to62:poke50176+i,0:next
60 x=150:y=100:pokev+4,x:pokev+2,x-40:pokev+16.0
70 pokev+5,y:pokev+3,y+19
1000 data120,169,51,133,1,169,0,133,95,133,90,133,88,169,208,133,96,169,240,133
1010 data89,169,224,133,91,32,191,163,169,55,133,1,88,96
1020 fori=832to832+33:reada:pokei,a:next
1040 sys832:poke850,160:sys832
1060 poke53272,8:poke56576,peek(56576)and252:poke648,192
1070 printchr$(147)
2000c=9*4096
2020 forcp=0to511:printchr$(19)cp:sb=50176
2040 fori=0to7:pokesb+3*i,peek(c+i):nexti
2360 c=c+8:gosub4000:nextcp
2380 pokev+21.0:goto 30000
4000 xj=0:yj=0:js=56321:sb=50176:pp=832
4020 jr=(255-peek(js))and15:jb=(255-peek(js))and16
4030 ifjbthenma=ma+1:ifma&gt;2thenma=0
4040 onjrgoto5000,6000,4020,7000,8000,9000,4020,10000,11000,12000
4045 ifpeek(203)&lt;&gt;4then4066
4050 printchr$(19)chr$(17)chr$(17)chr$(17)chr$(18) "save":gosub20000
4055 printchr$(19)chr$(17)chr$(17)chr$(17)chr$(17)" " :return
4066 ifma=1thenprintchr$(19)chr$(17)chr$(17)chr$(18)" set"

29

<!-- TOC PAGE_40: BASIC game movement code snippet -->

===========================================================
                       PAGE 40 OF 386                       
===========================================================

4067 ifma=2thenprintchr$(19)chr$(17)chr$(17)chr$(18)" clr"
4068 ifpeek(203)=26thenreturn
4069 ifma=0thenprintchr$(19)chr$(17)chr$(17)" "
4070 gosub13000:goto4020
5000 rem above
5020 yj=yj-1:ifyj&lt;0thenyj=0
5040 gosub13000:goto4020
6000 rem below
6020 yj=yj+1:ifyj&gt;7thenyj=7
6040 gosub13000:goto4020
7000 rem left
7020 xj=xj-1:ifxj&lt;0thenxj=0
7040 gosub13000:goto4020
8000 rem at the top left
8020 xj=xj-1:ifxj&lt;0thenxj=0
8040 goto5000
9000 rem bottom left
9020 xj=xj-1:ifxj&lt;0thenxj=0
9040 goto6000
10000 rem right
10020 xj=xj+1:ifxj&gt;7thenxj=7
10040 gosub13000:goto4020
11000 rem at the top right
11020 xj=xj+1:ifxj&gt;7thenxj=7
11040 goto5000
12000 rem bottom right
12020 xj=xj+1:ifxj&gt;7thenxj=7
12040 goto6000
13000 rem
13020 pp=sb+yj*3+int(xj/8):pv=peek(pp)
13040 po=xj-int(xj/8)*8
13060 ifpvand2↑(7-po)thenpokepp,(pvand(255-2↑(7-po))) :goto13100
13080 pokepp,(pvor(2↑(7-po)))

30

<!-- TOC PAGE_41: BASIC program code listing -->===========================================================
                       PAGE 41 OF 386                       
===========================================================

13100 ifma=1thenpv=(pvor(2↑(7-po)))
13120 ifma=2thenpv=(pvand(255-2↑(7-po)))
13200 fori=0to50:next:pokepp,pv:return
20000 rem new character transferred
20010 cd=c+20472
20020 fori=0to7
20040 pokecd+i,peek(sb+3*i):pokecd+i-20480,peek(sb+3*i)
20060 nexti:return
30000 input"save";r$
30020 if r$&lt;&gt;"j"then 30200
30040 input"name ";n$
30060 input "device address"; ad
30080 poke186,ad:poke781,0:poke782,160
30120 poke251,0:poke252,144:poke780,251
30140 poke183,len(n$):poke187,680and255:poke188,680/256
30160 fori=1tolen(n$)
30180 poke679+i,asc(mid$(n$,i,1)):next:sys65496
30200 poke56,160:clr

The following small program makes it possible to read in and activate the character set again.

Load 100 rem character set
110 input"name ";n$
120 input "device address";ad
130 poke186,ad:poke781,0:poke782,224
140 poke780,0:poke185,0:poke183,len(n$)
150 poke187,680and255:poke188,680/256
160 fori=1tolen(n$):poke679+i,asc(mid$(n$,i,1)):next
170 sys65493:rem load
180 poke53272,8:poke56576,peek(56576)and252:poke648,192
190 printchr$(147)

<!-- TOC PAGE_42: Commodore 64 raster interrupt guide -->

===========================================================
                       PAGE 42 OF 386                       
===========================================================

32

## 2.6 THE 'SPLIT' SCREEN

A feature of the video controller in the Commodore 64 that enables very nice effects has not yet been described or used much - the raster interrupt.

In order to explain to you what this is all about, we have to go a little further and understand how your computer's video controller creates a television image.

The television picture is made up of individual lines that you can clearly see if you take a closer look at the television picture. You can then clearly see that, for example, a letter is made up of eight lines. The video controller now has a register that always contains the number of the television line that is currently being displayed. This register has the number 18, so it can be reached at the address 53248+18 = 53266. Query the contents of this register,

**PRINT PEEK(53266)**

This will give you random values that indicate the currently displayed grid row. However, since 25 television images are displayed in one second, we cannot evaluate this quickly enough in BASIC. So we have to move on to programming in machine language. We also benefit from another feature of the video controller: The video controller is able to interrupt a running program when a specific grid line is currently being displayed. You can determine the number of this grid line by writing to the same register of the video controller. Such an automatic program interruption is called an 'interrupt'. Furthermore, the interrupt must be carried out by the

<!-- TOC PAGE_43: Assembly code for video controller -->===========================================================
                       PAGE 43 OF 386                       
===========================================================

Video controllers are permitted. This is done by writing the interrupt mask register. However, such programming is only possible in machine language. We have therefore written a small program for you that takes advantage of these possibilities for you.

|  10: | 033C |  | .OPT P1 |   |
| --- | --- | --- | --- | --- |
|  20: | 033C | IRQALT = | $EA31 |   |
|  25: | 033C | IRQVECT = | $314 |   |
|  35: | 033C | GRID = | $D012 ; grid row |   |
|  40: | 033C | IRQREG = | $D019 ; Video interrupt flag |   |
|  50: | 033C | MASK = | $D01A ; Video controller interrupt mask |   |
|  55: | 033C | FRAME = | $D020 ; Frame color |   |
|  60: | 033C | COLOR = | $D021 ; background color |   |
|  100: | 033C | ICR = | $DCOD ; Flag for timer interrupt |   |
|  110: | 033C | RETIRQ = | $FEBC ; Return from interrupt |   |
|  120: | O0FB |  | * = $FB |   |
|  130: | O0FC | LINE1 | * = *+1 |   |
|  140: | O0FD | LINE2 | * = *+1 |   |
|  150: | O0FE | COLOR1 | * = *+1 |   |
|  160: | O0FF | COLOR2 | * = *+1 |   |
|   |  | ; |  |   |
|  190: | 033C |  | * = 828 ; Cassette buffer |   |
|  200: | 033C 78 | SETUP | BE |   |
|  210: | 033D A9 5B |  | LDA #< IRQNEW |   |
|  220: | 033F 8D 14 03 |  | STA IRQVECT |   |
|  230: | 0342 A9 03 |  | LDA #> IRQNEW |   |
|  240: | 0344 8D 15 03 |  | STA IRQVECT+1 |   |
|  260: | 0347 A5 FB |  | LDA LINE1 |   |
|  270: | 0349 8D 12 DO |  | STA GRID ; Grid line for interrupt |   |
|  275: | 034C AD 11 DO |  | LDA RASTER-1 |   |
|  275: | 034F 29 7F |  | AND #$7F ; Delete high byte |   |
|  275: | 0351 8D 11 DO |  | STA RASTER-1 |   |
|  280: | 0354 A9 81 |  | LDA #$81 ; Allow IRQ through grid |   |

<!-- TOC PAGE_44: Assembly code listing -->

===========================================================
                       PAGE 44 OF 386                       
===========================================================

34

300: 0356 8D 1A DO STA MASK
310:0359 58 CLI
320: 035A 60 RTS

400: 035B AD 19 DO IRQNEW LDA IRQREG
400: 035E 8D 19 DO STA IRQREG ; Clear interrupt flag
410: 0361 29 01 AND #1
420: 0363 THUR 07 BNE SCREEN ; Interrupt by grid line?
430: 0365 AD OD DC LDA ICR ; Clear interrupt flag
430: 0368 58 CLI ; Allow grid interrupt
435: 0369 4C 31 EA JMP IRQALT

450: 036C AD 12 DO SCREEN LDA RASTER ; Read grid line
460: 036F C5 FC CMP LINE2
470: 0371 BO OD BCS SECOND ; greater than or equal to 2nd value?
480:0373 A5 FD LDA COLOR1
490: 0375 8D 20 DO STA FRAME ; Set color 1
500: 0378 8D 21 DO STA COLOR
510: 037B A5 FC LDA LINE2 ; next interrupt at 2nd value
520: 037D 4C 8A 03 JMP EXIT
560:0380 A5 FE SECOND LDA COLOR2
570: 0382 8D 20 DO STA FRAME ; Set color 2
580: 0385 8D 21 DO STA COLOR
590: 0388 A5 FB LDA LINE1 ; next interrupt
600: 038A 8D 12 DO EXIT STA RASTER ; at line 1
610:038D 4C BC FE JMP RETIRQ

Here is another loading program in BASIC. Enter this program first, save it and start it with 'RUN'.

<!-- TOC PAGE_45: BASIC program code example -->===========================================================
                       PAGE 45 OF 386                       
===========================================================

100 FOR I = 828 TO 911
110 READ X : POKE I,X : S=S+X : NEXT
120 DATA 120,169, 91,141, 20, 3,169, 3,141, 21, 3,165
130 DATA 251,141, 18,208,173, 17,208, 41,127,141, 17,208
140 DATA 169,129,141, 26,208, 88, 96,173, 25,208,141, 25
150 DATA 208, 41, 1,208, 7,173, 13,220, 88, 76, 49,234
160 DATA 173, 18,208,197,251,176, 13,165,253,141, 32,208
170 DATA 141, 33,208,165,252, 76,138, 3,165,254,141, 32
180 DATA 208,141, 33,208,165,251,141, 18,208, 76,188,254
190 IF S &lt;&gt; 10677 THEN PRINT "ERROR IN DATAS!!" :END
200 PRINT "OK"

As an example program, we have developed a program for you that allows you to give a screen area a different background color. This allows you to highlight one or more lines of the screen. To keep the program as universal as possible, you can specify the background colors of the area to be highlighted as well as those of the rest of the area using POKE commands. You can also determine the grid line at which the switch to the second background color should occur. Of course, this also applies to the number of the grid line, which switches back to the first color. While this may sound a bit complicated; However, try the following program once and you will see the effect.

This program allows you to move a colored bar the width of one screen line (8 grid lines) up or down one line at a time by pressing the 'cursor up' and 'cursor down' keys. Note that this does not happen all at once, but rather 8 grid lines one after the other. You can use the function keys to change the color of the bar and the rest of the background.

35

<!-- TOC PAGE_46: BASIC raster interrupt program code -->

===========================================================
                       PAGE 46 OF 386                       
===========================================================

100 Z1=251:Z2=Z1+1:F1=Z2+1:F2=F1+1
110 Z=50:SYS828:REM INITIALIZE INTERRUPT
120 POKEZ1,Z:POKEZ2,Z+8:POKEF1,6:POKEF2,8
150 GETA$:IFA$=""THEN150
160 IFA$=CHR$(17)THENGOSUB200
170 IFA$=CHR$(145)THENGOSUB300
180 IFA$=CHR$(133)THENGOSUB400
190 IFA$=CHR$(134)THENGOSUB500
195 GOTO150
200 IFZ&lt;240THENFORI=OTO7:Z=Z+1:POKEZ1,Z:POKEZ2,Z+8:NEXT
210 RETURN
300 IFZ&gt;50THENFORI=OTO7:Z=Z-1:POKEZ1,Z:POKEZ2,Z+8:NEXT
310 RETURN
400 POKEF1,PEEK(F1)+1AND15:RETURN
500 POKEF2,PEEK(F2)+1AND15:RETURN

You can modify the program for your purposes by sequentially poking into memory cells 251 to 254 the number of the grid line at which the switch to the second color should take place, then the grid line at which the switch back to the original color takes place. The next two addresses 253 and 254 contain the color code of the first and second colors. The following range applies to the grid lines:

Grid line 50 corresponds to the upper edge of the image (where the frame begins), while the beginning of the lower frame corresponds to grid line 250. One screen line is divided into 8 grid lines. This also allows you to place the border between two different colors in the middle of a screen line.

However, switching the background color is not the only effect you can achieve with the grid interrupt

36

<!-- TOC PAGE_47: Commodore 64 programming guide -->===========================================================
                       PAGE 47 OF 386                       
===========================================================

can. You can change all parameters of the video controller under interrupt control. Here are a few suggestions:

Display a line of text in a high-resolution graphic or switch between two graphic pages. You will then see, for example, a graphic image in the upper half of the screen and a second one in the lower half. By constantly changing the grid line that switches over, you can, for example, blend two graphic images from top to bottom, similar to the colored bar in our example. There are no limits to your imagination; maybe try different fonts in different parts of the screen!

With this technology you can also achieve effects that the Commodore 64 can't actually do, e.g. using the grid interrupt it is possible to display more than 8 sprites at the same time. To do this, you can display eight sprites in the upper half of the screen. When you reach a certain grid line, simply move the sprite pointers and coordinates and you can display another 8 sprites in the lower half. Of course, you can also split the screen into more than two parts.

37

<!-- TOC PAGE_48: Technical document on soft scrolling -->

===========================================================
                       PAGE 48 OF 386                       
===========================================================

38

#2.7 SOFT SCROLL - A THING FOR PERFECTIONISTS

You will probably know what scrolling means: the screen is rolled up one line. The top line disappears and a new line appears at the bottom of the screen.

By soft scroll we now mean the possibility of allowing a new line to slowly appear in the image while the old line slowly disappears. The video controller gives us this option. For this we use register 17. The lowest three bits allow moving a total of 8 grid lines, which corresponds to exactly one screen line. Now, to make a new line appear on the screen, we can instruct the video controller to display only 24 lines. This is the case when bit 3 of register 17 is deleted.

So we now proceed as follows: First we switch the screen to 24 lines and position the remaining screen content so that the top 24 lines are displayed. Now we can write something in the invisible 25th line and move the visible part of the screen up by 8 grid lines, one line at a time, whereby the top line disappears at the same time.

In addition to scrolling up (or down), the video controller also supports horizontal soft scrolling to the right or left. Register 22 is used for this purpose. The lowest three bits are again responsible for moving columns, while bit 3 enables the display of 38 columns.

The example program scrolls the screen up.

<!-- TOC PAGE_49: BASIC code scroll effect program -->

===========================================================
                       PAGE 49 OF 386                       
===========================================================

100 VIDEO = 53248
110 LINE = VIDEO + 17
115 X$=CHR$(19): FOR I=1 TO 24: X$=X$+CHR$(17): NEXT
120 POKE LINE ,PEEK(LINE) AND NOT 8
130 POKE LINE ,PEEK(ROW) AND 248 OR 7
140 N=N+1: A$="ROW"+STR$(N): GOSUB200: GOTO140
200 PRINT : PRINT X$ A$;
210 FOR I=7 TO 0 STEP-1
220 POKE LINE, PEEK(ROW) AND 248 OR I
230 FOR J=1 TO 100 : NEXT
240 NEXT: RETURN

115 A string consisting of one 'Cursor Home' and 24 times 'Cursor Down' is defined for positioning the cursor in the 25th line.
120 Bit 3 in register 17 of the video controller is deleted. This switches to 24 line display.
130 bits 0 to 2 are set. This means that the top 24 lines of the screen are displayed, while the 25th line at the bottom of the screen remains invisible.
140 The counter N is increased, the text to be output for the subprogram 200 is transferred to A$, which is then called.
200 The PRINT command moves the screen up one line. Then the text to be output is written in the last line of the screen.
210 -240 This loop moves the screen up eight grid lines. The delay loop determines the speed at which scrolling occurs.

39

<!-- TOC PAGE_50: Commodore 64 keyboard technical manual -->===========================================================
                       PAGE 50 OF 386                       
===========================================================

40

# 2.8 THE KEYBOARD LAYOUT AND THEIR CHANGES

The Commodore 64's keyboard is arranged as a matrix with 8 rows and 8 columns. The lines of the 8 lines are connected to port A (address $DCOO = 56320) of CIA 1 and the 8 columns are connected to port B (address $DCO1 = 56321) of CIA 1. With the keyboard query (address $FF9F = 65485), the keyboard is queried line by line by applying a signal to each line via port A one after the other. If a key is now pressed, you can query the column of the key you just pressed via port B. The key number between 0 and 63 is now calculated from the row and column numbers. 64 means no key pressed here. The assignment is shown in the table above. This value is stored in address $CB equal to 203 for every query; The number of the last key pressed is stored in $C5 = 197. The status of the special keys is saved in address $028D = 653 when the keyboard is queried. Bit 0 means SHIFT, bit 1 is reserved for COMMODORE and bit 2 stands for the CTRL key being pressed. The assignment of a specific character to a key is done using various tables that determine the ASCII code that is assigned to a specific key. Since all keys in the Commodore 64 can be assigned four times, there are 4 such tables. Also note the distinction between left and right shift keys. Shift Lock is connected to the left shift key.

<!-- TOC PAGE_51: Commodore 64 keyboard mapping guide -->

===========================================================
                       PAGE 51 OF 386                       
===========================================================

41

|  Column | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
|  line |  |  |  |  |  |  |  |   |
|  0 | DEL | RETURN | CURRIGHT | F7 | F1 | F3 | F5 | CURDOWN |
|  1 | 3 | W | A | 4 | Z | S | E | SHIFT LEFT |
|  2 | 5 | R | D | 6 | C | F | T | X |
|  3 | 7 | Y | G | 8 | B | H | U | V |
|  4 | 9 | I | J | O | M | K | O | N |
|  5 | + | P | L | - | . | : | ⊗ | , |
|  6 | POUND | * | ; | HOME SHIFT RIGHT = |   |   | ↑ | / |
|  7 | 1 | PFL | CTRL | 2 | EMPTY | C= | Q | STOP |

The first table gives the ASCII code when the key was pressed alone. The second table shows the code with the Shift key pressed, Table 3 applies to the Commodore key pressed and finally Table 4 is responsible for the Control key. An entry of $FF = 255 in this table marks an invalid entry. The 'Shift', 'Commodore' and 'CTRL' keys are treated separately; the corresponding entries in the first table are 1, 2 and 4. This status is also stored in $28D = 653. Bits 0, 1 and 2 correspond to these three keys.

If we now want to assign a different code to a key, we have to change the corresponding entry in the table. Since the table is in ROM, this is not easily possible. However, the Commodore 64 also has RAM in this memory area, so we can copy the operating system into the RAM 'below' and make the change there. This can be done with a small BASIC program. At the same time, the BASIC must also be copied into the RAM underneath.

<!-- TOC PAGE_52: Commodore keyboard remapping guide -->===========================================================
                       PAGE 52 OF 386                       
===========================================================

100 for i = 40960 to 49151: copy rem basic-rom
110 poke i, peek(i) : next
120 for i = 14*4096 to 65535 : copy rem operating system
130 poke i, peek(i) : next
140 poke 1, 53

Lines 100 to 130 copy the operating system and Basic from ROM to the RAM below. In line 140 the system then switches from ROM to RAM, so that the operating system now runs in RAM. Now we can go and change the codex of individual keys.

On the German keyboard, Y and Z are usually swapped compared to the American keyboard, i.e. Z is next to T and Y is next to X.

To do this we first need the addresses of the 4 tables:

Table 1 untraded $EB81 = 60289
Table 2 with shift $EBC2 = 60354
Table 3 with Commodore $EC03 = 60419
Table 4 with control $EC78 = 60536

If we now want to change a code, we have to determine the number of the keys that we want to change from the matrix table. The numbering runs from 0 at the top left to 63 at the bottom right. So Y has the number 25 and Z has the number 12. We now have to write the new code into these addresses.

150 t1 = 60289 : rem table 1 without shift
160 t2 = 60354 : rem table 2 with shift
170 t3 = 60419 : rem table 3 with commodore
180 t4 = 60536 : rem table 4 with control

42

<!-- TOC PAGE_53: ZX Spectrum keyboard remapping guide -->

===========================================================
                       PAGE 53 OF 386                       
===========================================================

200 poke t1+25, asc("z")
210 poke t1+12, asc("y")

If you now press the "Z" key, a "y" will appear on the screen and vice versa. To change lowercase and uppercase letters, you must also change the entries in Table 2:

220 poke t2+25, asc("Z")
230 poke t2+12, asc("Y")

If the corresponding control keys are required, you can change them too:

240 poke t4+25, asc("z")-64
250 poke t4+12, asc("y")-64

With the help of these 4 tables you can define 4*64 equal to 256 different characters. You cannot redefine the RESTORE button; it is connected directly to the NMI line of the processor. The keyboard definition remains until you press Stop/Restore. This switches back to the ROM. But you can also prevent this by changing the memory configuration value in RAM. This could happen in our program above, for example in line 190:

190 poke 64982, 53

<!-- TOC PAGE_54: BASIC key remapping program code -->

===========================================================
                       PAGE 54 OF 386                       
===========================================================

Instead of determining the number of the key from the matrix, you can also let the program determine it itself. A program with automatic number determination could look like this:

```txt
100 dim t(4): for i=1 to 4: read t(i): next
110 data 60289,60354,60419,60536
120 for i=14*4096 to 65535: poke i, peek(i): next
130 for i=40960 to 49151: poke i, peek(i): next
140 poke1, 53: poke64982, 53
1000 print "please press the key to change ";
1010 get a$: if a$="" then1010
1020 print a$
1030 a = asc(a$)
1040 for j=1 to 4: t=t(j)
1050 for i=0 to 63: if peek(t+i) &lt;&gt; a then next: next
1060 print "please specify desired occupancy";
1070 get a$: if a$="" then 1070
1080 print a$
1090 poke t+i, asc(a$): goto 1000
```

44

<!-- TOC PAGE_55: Commodore 64 cursor positioning guide -->===========================================================
                       PAGE 55 OF 386                       
===========================================================

45

# CHAPTER 3 DATA ENTRY WITH CONVENIENCE

## 3.1 CURSOR POSITIONING AND QUERY OF THE CURSOR POSITION

For convenient input and output on the screen, it would be very useful to be able to place the cursor directly on any desired position on the screen. The Commodore 64 only has commands for positioning the cursor in a line, the TAB command and the POS function for querying the column. With the TAB command, positioning to the front is only possible.

However, the operating system already has the routines for positioning the cursor ready. The row and column in which the cursor is currently located are located in two memory locations in the zero page. By querying these values ​​with PEEK we can find out the position at any time.

100 PRINT "THE CURSOR IS ON LINE" PEEK(214)
"COLUMN" PEEK(211)

If we want to set the cursor, it is not enough to POKE the corresponding values in addresses 214 and 211. The operating system still has to calculate the required pointers for screen and color RAM from the cursor position. However, there is a routine available in the operating system for this.

SET 100 REM CURSOR
110 INPUT "ROW ";Z
120 INPUT "COLUMN";p
130 POKE 214,Z
140 POKE 211, p
150 SYS 58640

<!-- TOC PAGE_56: BASIC programming cursor control -->

===========================================================
                       PAGE 56 OF 386                       
===========================================================

160 PRINT "TEST";

Calling this routine places the cursor at the desired location.

Combining these two methods opens up new programming possibilities. For example, you can provide a status line in your program in which instructions are issued to the operator on a case-by-case basis. In order not to disrupt the course of the normal output, first note the current position of the cursor and then place the cursor in the status line for output. Now output the message here. Then put the cursor back at the original position and continue with the program flow. A program excerpt then looks something like this:

```
300 Z=PEEK(214): REM LINE
310 S=PEEK(211): REM COLUMN
320 POKE 214.0: REM CURSOR IN LINE 0
330 POKE 211.10: REM CURSOR IN COLUMN 10
335 SYS 58640
340 PRINT "PLEASE INSERT DISK"
350 POKE 214,Z: RESTORE REM LINE
360 POKE 211,S: REM COLUMN
370 SYS 58640
```

The numbering of the rows and columns goes from 0 to 24 or from 0 to 39.

46

<!-- TOC PAGE_57: Commodore 64 cursor control guide -->

===========================================================
                       PAGE 57 OF 386                       
===========================================================

47

#3.2 TURN CURSOR ON AND OFF

The cursor for marking the current screen position on the Commodore 64 is automatically switched on whenever the computer expects input. This is the case, for example, when an INPUT command is used or when you are working in direct mode. But if you make an entry with GET, no cursor appears. Sometimes you want to avoid this so that the blinking cursor alerts the user to the required input.

However, the Commodore 64 has a memory location that works as a flag for the cursor. If the memory location contains the value one (or a value other than zero), the computer knows that the cursor is switched off and the corresponding program location in the operating system (during the interrupt) is skipped. A value of zero, on the other hand, means to the computer that the cursor is flashing.

We can take advantage of this fact if we want to switch the cursor on and off programmatically. For example, we can turn the cursor on before a GET command, then wait for the key to be pressed and then turn the cursor off again.

100 POKE 204.0: REM CURSOR ON
110 GET A$: IF A$ = "" THEN 110: REM WAIT FOR KEY PRESS
120 POKE 204.1: REM CURSOR OFF
130 PRINT A$;

It can happen that the cursor is switched off just when it is in the blinking phase. A white square will then remain on the screen. This can

<!-- TOC PAGE_58: BASIC programming code snippet -->===========================================================
                       PAGE 58 OF 386                       
===========================================================

You can avoid this if you check before switching off whether the cursor is currently in the flashing phase. There is also a storage location for this in the zeropage. We also add line 115.

115 IF PEEK(207) THEN 115: REM WAIT FOR CURSOR OFF

An application of this technique can be found in Chapter 3.6

48

<!-- TOC PAGE_59: Commodore 64 repeat function guide -->

===========================================================
                       PAGE 59 OF 386                       
===========================================================

49

#3.3 REPEAT FUNCTION FOR ALL BUTTONS

When working with your Commodore 64, you will probably have noticed that the cursor control keys and the space bar have a repeat function. If you press these buttons, they will be repeated automatically until you release the buttons again. This is particularly useful for cursor positioning and when editing programs. However, with a POKE command, the Commodore 64 can assign a repeat function to all keys. This is very useful for word processing, for example. The switchover can be carried out as desired in the program or in direct mode and can also be reversed again. The address for switching is 650. A value of 0 means that only the cursor keys are repeated automatically. Use POKE to write the value 128 into memory location 650, then all keys will be repeated. It is also possible to switch off the repeat function completely. To do this, the value 64 must be in address 650.

100 POKE 650,128: REM REPEAT FOR ALL BUTTONS
...
200 POKE 650.0: REM REPEAT ONLY FOR CURSOR
...
300 POKE 650.64: TURN OFF REM REPEAT COMPLETELY

The values until the button responds (repeat delay) and the repetition rate are in memory locations 651 and 652. However, these values are always reset by the operating system, so changes are only possible by moving the operating system to RAM (see also Chapters 2.8 and 4.2).

<!-- TOC PAGE_60: BASIC WAIT command documentation -->

===========================================================
                       PAGE 60 OF 386                       
===========================================================

50

# 3.4 THE WAIT COMMAND: WAIT FOR A KEYPRESS

A BASIC command that is rarely used is the WAIT command. How does this command work?

WAIT A,B

With this command the contents of memory cell A are fetched (as with the PEEK function). This value is linked to B via AND. If the result is zero, the whole thing is repeated again. If the value is not zero, the program continues. From this description it is clear that the value A must either be the address of an I/O port or another peripheral component or that the value of A must be changed by the interrupt routine. Otherwise the command would not wait at all or would wait indefinitely. You can find an application for data transfer between two computers in Chapter 7.2

The most interesting application is certainly waiting for certain key presses. The memory cell 653 contains, for example, information about whether the three special keys SHIFT, CONTROL or COMMODORE are pressed. You can use the WAIT command to wait until one of the three buttons has been pressed.

100 PRINT "PLEASE PRESS THE CONTROL BUTTON"
110 WAIT 653.4: REM WAIT FOR CTRL
120...

The program waits in line 110 until the control key is pressed. You can wait for the SHIFT and COMMODORE keys with the following WAIT commands:

<!-- TOC PAGE_61: Commodore BASIC WAIT command guide -->===========================================================
                       PAGE 61 OF 386                       
===========================================================

WAIT 653.1: REM WAIT FOR SIHFT

WAIT 653.2: REM WAIT FOR COMMODORE

If you want to wait for any key to be pressed, you can query memory location 203. If no key is pressed, the address contains the value 64, otherwise the matrix number of the key pressed is there (see also chapter 2.5). With

WAIT 203.64

the program waits as long as a key is pressed. With

WAIT 203.63

Waits for any key press. You can use this, for example, with the GET command to save the query for the empty string.

100 WAIT 203.63

110 GET A$: PRINT A$;

The WAIT command will only end if a key is pressed at that time. If there may already be data in the keyboard buffer, you can also make the number of keys pressed the basis of the WAIT query.

100 WAIT 198,255: REM DATA IN THE KEYBOARD BUFFER?

110 GET A$: PRINT A$;

120 GOTO 100

<!-- TOC PAGE_62: Commodore 64 function key guide -->

===========================================================
                       PAGE 62 OF 386                       
===========================================================

52

# 3.5 THE ASSIGNMENT OF THE FUNCTION KEYS OF THE COMMODORE 64

In addition to its alphanumeric keys, the Commodore 64 has 4 function keys that have double assignments. These keys can be used, for example, in the menu control to select certain parts of the program. To do this, you can query the keyboard with GET and branch depending on the key pressed. The function keys have the following ASCII codes:

F1 =&gt; 133
F3 =&gt; 134
F5 =&gt; 135
F7 =&gt; 136

If you hold down the shift key at the same time, the ASCII code increases by 4:

F2 =&gt; 137
F4 =&gt; 138
F6 =&gt; 139
F8 =&gt; 140

A function key query can be implemented like this:

100 GET A$ : IF A$="" THEN 100
110A = ASC(A$)
120 IF A = 133 THEN 1100 : REM F1
130 IF A = 134 THEN 1200 : REM F3
140 IF A = 135 THEN 1300 : REM F5
150 IF A = 136 THEN 1400 : REM F7
160 IF A = 137 THEN 1500 : REM F2
170 IF A = 138 THEN 1600 : REM F4

<!-- TOC PAGE_63: BASIC function key programming guide -->

===========================================================
                       PAGE 63 OF 386                       
===========================================================

180 IF A = 139 THEN 1700 : REM F6
190 IF A = 140 THEN 1800 : REM F8
200 GOTO 100

Depending on the function key pressed, the corresponding routine branches. This can be solved more elegantly with an ON .. GOTO jump distributor.

100 GET A$ : IF A$="" THEN 100
110 A = ASC (A$) : IF A&lt;133 OR A&gt;140 THEN 100
120 ON A-132 GOTO 1100,1200,1300,1400,1500,1600,1700,1800

You can use this technique within programs. However, we would now like to introduce you to a program that allows you to assign text to each function key that appears on the screen when the key is pressed. This allows you to make working with your computer more comfortable. The function keys will usually be assigned BASIC command words, e.g. RUN, LIST, PRINT, GOTO. It will also be possible to assign a word to a function key including the final RETURN key. This will then execute the above commands directly. For example, if the F1 key contains the text LIST and the code for RETURN, pressing the F1 key will list the program without having to press the key again. The maximum length of a text when assigning the function keys is 10 characters, the length of the keyboard input buffer.

A special feature of our program is that you can not only put 8 different texts on the function keys (double assignment - with and without shift key), but even 16. In addition to the shift key, the Commodore and Control keys are used to differentiate between them. We choose the following assignment to the keys:

53

<!-- TOC PAGE_64: CBM 64 function key mapping -->===========================================================
                       PAGE 64 OF 386                       
===========================================================

F1 =&gt; F1
F2 =&gt; F3
F3 =&gt; Q5
F4 =&gt; Q7
F5 =&gt; F1 plus SHIFT
F6 =&gt; F3 plus SHIFT
F7 =&gt; F5 plus SHIFT
F8 =&gt; F7 plus SHIFT
F9 =&gt; F1 plus COMMODORE
F10 =&gt; F3 plus COMMODORE
F11 =&gt; F5 plus COMMODORE
F12 =&gt; F7 plus COMMODORE
F13 =&gt; F1 plus CTRL
F14 =&gt; F3 plus CTRL
F15 =&gt; F5 plus CTRL
F16 =&gt; F7 plus CTRL

We will now introduce you to a machine program that allows you to assign any text to the function keys. These texts are stored as DATA's and can be up to 10 characters long.

; Function keys for cbm 64

190: 033c *= 828 ; Cassette buffer
200: 033c keyvec = $28f ; Keyboard decoding vector
210: 033c keypnt = $f5 ; Pointer to decoding table
220: 033c buffer = $277 ; Keyboard buffer
230: 033c nmbkeys = $c6 ; Number of characters in the keyboard buffer
240: 033c shift = $28d ; Flag for SHIFT/CBM/CTRL
250: 033c keyno = $cb ; Matrix number of the pressed key
260: 033c lastkey = $c5 ; Number of the last key

<!-- TOC PAGE_65: Keyboard function handling code -->

===========================================================
                       PAGE 65 OF 386                       
===========================================================

265: 033c temp = lastkey
270: 033c fmin = $85 ; Code of the lowest function key
280: 033c fmax = $88 ; Code of the highest function key
285: 033c setflag = $eb26
287: 033c oldkey = $eb48 ; old keyboard evaluation

300: 033c a9 47 init lda #<funktion ;="" auf="" beyo="" coutine="" de="" ebutine="" i="" ie="" new="" vector="" x="" xfunktion="" xcyvec="">
300: 033e a0 03 ldy #&gt;function
310: 0340 8d 8f 02 sta keyvec
310: 0343 8c 90 02 sty keyvec+1
310: 0346 60 rts

330: 0347 a4 cb function ldy keyno ; Number of the button
335: 0349 c4 c5 cpy lastkey ; same as before?
335: 034b f0 0a beq nofunc ; yes
340: 034d b1 f5 lda (keypnt),y ; Ascii code
350: 034f c9 89 cmp #fmax+1 ; Compare with highest function key

360: 0351 b0 04 bcs nofunc ; no function key?
370: 0353 c9 85 cmp #fmin
380: 0355 b0 03 bcs function
390: 0357 4c 48 eb nofunc jmp oldkey ; to the old keyboard evaluation
400: 035a e9 85 function sbc #fmin
400: 035c 85 c5 sta temp
410: 035e 0a asl
410: 035f 0a asl ; times 10
410: 0360 65 c5 adc temp
410: 0362 0a asl
420: 0363 ae 8d 02 ldx shift ; Flag SHIFT/CBM CTRL
430: 0366 e0 01 cpx #1 ; SHIFT?
430: 0368 f0 0e beq shift key
440: 036a e0 02 cpx #2 ; CBM?
440: 036c f0 07 beq cbmkey
450: 036e e0 04 cpx #4 ; CTRL?

55</function>

<!-- TOC PAGE_66: Assembly code listing with comments -->===========================================================
                       PAGE 66 OF 386                       
===========================================================

56

|  450: | 0370 | d0 | 09 |  | bne | nospec |   |
| --- | --- | --- | --- | --- | --- | --- | --- |
|  500: | 0372 | 18 |  | ctrlkey | clc |  |   |
|  500: | 0373 | 69 | 28 |  | adc | #40 |   |
|  510: | 0375 | 18 |  | cbmkey | clc |  |   |
|  510: | 0376 | 69 | 28 |  | adc | #40 | ; Pointer to next table |
|  520: | 0378 | 18 |  | shiftkey | clc |  |   |
|  520: | 0379 | 69 | 28 |  | adc | #40 |   |
|  530: | 037b | aa |  | nospec | taxes |  | ; Pointer as index |
|  540: | 037c | a0 | 00 |  | ldy | #0 |   |
|  550: | 037e | bd | 00 | cf getkey | lda | table,x ; Get occupancy from table |   |
|  550: | 0381 | f0 | 09 |  | beq | endkey |   |
|  560: | 0383 | 99 | 77 | 02 | sta | buffer,y ; and write to keyboard buffer |   |
|  570: | 0386 | e8 |  |  | inx |  |   |
|  570: | 0387 | c8 |  |  | iny |  |   |
|  570: | 0388 | c0 | 0a |  | cpy | #10 | ; already 10 characters?  |
|  580: | 038a | d0 | f2 |  | bne | getkey |   |
|  590: | 038c | 84 | c6 | endkey | sty | nmbkeys | ; Remember number of characters |
|  600: | 038e | a2 | ff |  | ldx | #$ff | ; Keyboard code invalid flag |
|  610: | 0390 | 4c | 26 | eb | jmp | setflag | ; Update flags |
|  615: | 0393 |  |  | table | = | $cf00 | ; Table with key assignments |

The following BASIC program generates the machine program and stores the texts for the 16 function keys in memory. The texts themselves are stored in the program as DATA starting from line 300 and can of course be changed according to your wishes. Please note, however, that texts with more than 10 characters are not permitted. If you want a command to be executed directly by pressing the function key, the final 'RETURN' must be included in the text. To do this, write '←' (arrow to the left) as the last character. This character is then exchanged for the RETURN code when loading (line 250). If you want to use quotation marks within the text, use instead

<!-- TOC PAGE_67: BASIC program listing and notes -->

===========================================================
                       PAGE 67 OF 386                       
===========================================================

whose an apostrophe: LOAD$',8 (line 260). If a comma occurs within a text, the entire text must be enclosed in apostrophes (see line 330).

```txt
100 for i = 828 to 914
110 read x : poke i, x : s=s+x : next
120 data 169, 71, 160, 3, 141, 143, 2, 140, 144, 2, 96, 164
130 data 203, 196, 197, 240, 10, 177, 245, 201, 137, 176, 4, 201
140 data 133, 176, 3, 76, 72, 235, 233, 133, 133, 197, 10, 10
150 data 101, 197, 10, 174, 141, 2, 224, 1, 240, 14, 224, 2
160 data 240, 7, 224, 4, 208, 9, 24, 105, 40, 24, 105, 40
170 data 24, 105, 40, 170, 160, 0, 189, 0, 207, 240, 9, 153
180 data 119, 2, 232, 200, 192, 10, 208, 242, 132, 198, 162, 255
190 data 76, 38, 235
200 if s &lt;&gt; 10591 then print "error in datas!!" :end
210 sys 828
```

```txt
Store 220 rem assignments in memory
230 ad = 12*4096+15*256 : rem $cf00
240 for i=0 to 7 : read x$ : for j=1 to len(x$)
250 a=asc(mid$(x$,j,1)) : if a=95 then a=13 : rem return
260 if a= 39 then a=34 : rem quotation marks
270 poke ad+10*i+j-1,a : next
280 if j&lt;&gt;11 then poke ad+i*10+j-1,0 : rem end criterion
290 next
300 data list, run, goto, chr$(
310 data ?fre(0), save, print, then
320 data poke, peek(, print#, input#
330 data "load$',8", next, gosub, return
```

The texts of the function keys are stored in the free RAM area starting at address $CFOO. Is this area occupied for you or do you want a different memory area for the keys?

<!-- TOC PAGE_68: Program address modification instructions -->===========================================================
                       PAGE 68 OF 386                       
===========================================================

texts, you must insert this address in line 230 and also change the address in the DATA statements in line 170. To do this, replace the fifth and fourth last elements (0 and 207) with the Lo and High bytes of the new address. If you want to use a different address, 160 bytes must be available there (16 keys by 10 characters).

If you want to change the function key assignment, it is sufficient to run the program with the correspondingly changed data from line 220.

Pressing RUN/STOP-RESTORE cancels the function key definition. With

SYS 828

In such a case, you can reactivate the assignments.

58

<!-- TOC PAGE_69: Programming input routine guide -->

===========================================================
                       PAGE 69 OF 386                       
===========================================================

59

#3.6 A CONVENIENT INPUT ROUTINE

You've probably often had the problem that your program "exited" after typing from the keyboard. There were definitely two main reasons for this:

Input in the form INPUT A

A program abort occurs if the input does not exclusively contain numeric characters.

Input in the form INPUT A$

The program is aborted if the RETURN key is pressed without prior alphanumeric entry.

The input using GET A$ is certainly syntactically more harmless, but many people shy away from the assembly of a string required if the input is to contain more than one character. In addition, no flashing cursor appears on the screen, which would, however, be desirable as a prompt for input.

If you have overcome all obstacles during input, errors can still creep in during further processing of the data obtained in this way, which do not necessarily lead to the program being terminated, but which do question the desired result.

A typical example of this is the numerical input via INPUT A$.

So you request numbers via the keyboard, which you intend to convert into a numeric variable using VAL(A$). You have probably avoided the possible conflict with INPUT A, but an incorrect entry still has the following effect:

<!-- TOC PAGE_70: Programming input validation guide -->

===========================================================
                       PAGE 70 OF 386                       
===========================================================

You answer the above INPUT with 123R56. In the following transfer with A=VAL(A$) you get the value 123 in A, which was certainly not what you intended.

You may now object that such input errors are not the rule and, moreover, incorrect calculation results in the programs generally created by amateur programmers (which does not mean any judgment) do not have far-reaching consequences.

However, we believe that your aim should be to create "safe" programs, also in view of the fact that you may well find yourself in the embarrassment of not writing programs just for your own use, and you can imagine what your client will then say about a program that is at risk of crashing.

We would now like to introduce you to a ready-to-use subprogram that largely eliminates the problems outlined above, including program terminations.

We will discuss this program in detail, which should allow you to customize certain parts to suit your specific needs.

First, the meaning of the variables and memory cells used in the program should be explained.

The following variables must be supplied when the routine starts:

- MN=0 A purely numerical entry is required
- MN=1 The input can be alphanumeric
- ML=0 The length specified in IL is mandatory
- ML=1 The maximum length is specified in IL
- IL Mandatory or maximum length of the input

60

<!-- TOC PAGE_71: Input routine documentation page -->===========================================================
                       PAGE 71 OF 386                       
===========================================================

Furthermore, the following are used in routine:

- CC Number of valid characters in IN$
- CS Current column position of the cursor
- CZ Current line position of the cursor
- CP Length of the input field created by INSERT
- MS Highest column position of the cursor during input
- G$ Contains characters of the last GET
- IN$ This returns the complete input

Storage locations used:

- 204=0 Switch on cursor
- 204=1 Switch off cursor
- 205 counter for flashing frequency of the cursor
- 207=0 Cursor in OFF phase
- 207=1 cursor in ON phase
- 211 column position of the cursor
- 214 line position of the cursor

Another prerequisite for the function of this INPUT routine is that the screen is opened with 'OPEN 1,3', since in line 35680 the generated input is read from the screen into a string variable using 'GET#1'.

Now to the individual program steps:

- 35020 Here the required variables are initialized and the cursor position is saved for the final GETü1 in line 35680.
- 35060 A character is fetched from the keyboard.
- 35080 If this character was a RETURN, the input is initially considered completed and the length is checked depending on the value in ML.
- 35100-35130 If the DELETE button was pressed, you must here

61

<!-- TOC PAGE_72: C64 input validation code snippet -->

===========================================================
                       PAGE 72 OF 386                       
===========================================================

the length and position counters are updated depending on whether the input field contains only valid characters (CP=0) or whether it has been inflated by INSERT (CP&lt;&gt;0).

35140 INSERT is only executed if the length specified in IL is not exceeded.

35160-35180 With CRSR RIGHT and LEFT it must be ensured that the cursor does not leave the input field.

35200 Start of the data filter depends on MN.

35220-35240 If the cursor is within the data field and a pure numerical value was entered, the character is accepted. You can vary the validity range, here defined by the values ​​47 and 58, according to your own ideas.

In our example, these values ​​limit the number range 0-9 they represent. Basically, you can get the values ​​for delimiting the scope by simply reading them from the C64 manual, page 135ff.

For our example this means that the 47 is below the character 0 and the 58 is above the character 9. All characters in between, i.e. 0-9, are valid.

35300-35380 The same applies here as above, but the scope has also been expanded to include letters.

35400 If the input does not have the prescribed length (ML=0), it cannot be completed.

35600-35690 The input field is now taken over from the screen to IN$ until either the length specified in IL is reached or there is no length

62

<!-- TOC PAGE_73: Input routine code snippet -->===========================================================
                       PAGE 73 OF 386                       
===========================================================

There is more data on the screen. Before that, however, the cursor is brought back to the position it had at the beginning of the routine so that the GETü1 also starts at the beginning of the field.

36000-36060 The cursor is turned off and the character in G$ is displayed on the screen.

The line numbering of the routine is chosen arbitrarily. Of course, the routine can also be used with line numbers. Start with 1000, 50000 or another number.

However, we recommend that you always place subroutines in the same place in all programs. This makes programming and building new programs from a block library much easier.

Here is the INPUT routine:

35000 rem input keyboard
35020 in$="":cc=0:cs=peek(211):cz=peek(214):cp=0:ms=0
35040 poke204,0:rem cursor on
35060 getg$:ifg$=""then35060
35080 g=asc(g$):ifg=13thenonml+1goto35400,35600
35100 ifg=20andcp&gt;0thencp=cp-1:gosub36000:goto35060
:rem delete
35120 ifg=20andcc&gt;0andpeek(211)&gt;csthencc=cc-1:ms=ms-1
:cp=cp-1:gosub36000:goto35060
35130 ifg=20andpeek(211)&gt;csthenms=ms-1:gosub36000:goto35060
35140 ifg=148andcp+ms<ilthencp=cp+1:ms=ms+1:gosub36000
:goto35060:rem insert
35160 ifg=29andpeek(211)&lt;=cs+il-1thengosub36000
:goto35060:rem cursor right
35180 ifg=157andpeek(211)&gt;csthengosub36000:goto35060
:rem cursor left

63</ilthencp=cp+1:ms=ms+1:gosub36000>

<!-- TOC PAGE_74: BASIC input validation routine -->

===========================================================
                       PAGE 74 OF 386                       
===========================================================

35200 onmngoto35300
35220 ifg&gt;47andg&lt;58andcc<ilandpeek(211)<=cs+il-1thencc=cc+1 :gosub36000:goto35360
35230 goto35360
35240 ifg&gt;47andg&lt;58andpeek(211)&lt;=cs+ilthengosub36000 :goto35360
35300 ifg&lt;48or(g&gt;57andg&lt;65)or(g&gt;90andg&lt;193)org&gt;218then35060
35320 ifcc<ilandpeek(211)<=cs+il-1thencc=cc+1 :gosub36000:goto35360
35340 ifpeek(211)<cs+ilthengosub36000 35360="" ifcp="">0thencp=cp-1
35380 goto35060
35400 ifcc&lt;&gt;ilthen35060
35600 poke205.2
35620 ifpeek(207)&lt;&gt;0then35620
35640 poke204.1
35660 poke211,cs:poke214,cz
35670 ifcc=0thenreturn
35680 get#1,g$:ifg$=chr$(13)then in$=left$(in$+" ",il):return
35682 in$=in$+g$
35684 iflen(in$)&lt;ilthen35680
35690 returns
36000 poke205.2
36020 ifpeek(207)&lt;&gt;0then36020
36040 printg$;:ifpeek(211)&gt;msthenms=peek(211)
36060 returns

Now how do you use the program?
Suppose you require the entry of an item number for inventory management, for example. This number must have a fixed length of 6 digits and should consist exclusively of numeric characters.
For this purpose the following must be programmed:

64</cs+ilthengosub36000></ilandpeek(211)<=cs+il-1thencc=cc+1>

<!-- TOC PAGE_75: Article input program instructions -->

===========================================================
                       PAGE 75 OF 386                       
===========================================================

10 open1,3

100 il=6:mn=0:ml=0

110 print "article number";:gosub35000

120 in=val(in$)

The desired article number is now available in IN and you can be sure that it has exactly 6 digits and only contains numbers.

For the previously entered article number. You will also need the name of the item when creating a new one. Since you have set up a file with fixed-length records, this label can contain a maximum of 10 characters, although this is not mandatory.

This is what the associated program lines should look like:

200 il=10:mn=1:ml=1

210 print "designation ";:gosub35000

The required name is now in IN$ and, if shorter, is padded with spaces to a length of 10 characters.

The price is of course also important. Of course, this also has a variable length, let's say up to 8 digits, and only contains numeric characters, so:

300 il=8:mn=0:ml=1

310 print "price";:gosub35000

320 in=val(in$)

The required maximum 8-digit number is now in IN and

65

<!-- TOC PAGE_76: German programming tutorial snippet -->===========================================================
                       PAGE 76 OF 386                       
===========================================================

You can now enter the quantity, etc.

We hope that we have given you a nice little routine that will help you forget your frustration with syntactically incorrect data.

The special features used here regarding cursor positioning and input from the screen (GET#1) may also have inspired you for other programs.

66

<!-- TOC PAGE_77: Computer mouse technical explanation article -->

===========================================================
                       PAGE 77 OF 386                       
===========================================================

3.7 THE “MOUSE” ON THE CBM64

A new buzzword has hit the world of personal computers: The "MOUSE"

What is behind this expression, which is somewhat unusual for the industry?

You are probably familiar with the so-called Spinball from video slot machines. Instead of joysticks or paddles, this is an actuator that allows you to move any characters across the screen.

In contrast to joysticks, whose levers can only be moved in eight directions, the Spinball allows you to rotate in all directions because it is a freely supported ball whose movement is transmitted to two angle encoders, one each for the X and Y axes.

In slot machines, this ball is usually set in motion with the palm of your hand.

The "mouse" consists of a similar spin ball, but it is built into a handy housing, which you place on the table, ball at the bottom, and can now roll back and forth with your hand.

Moving the housing on the table causes the ball to rotate due to the friction on the table surface.

The current status of the two angle encoders is transferred to the computer using a suitable interface.

The sensible name for this arrangement may well come from its resemblance to a wind-up mouse.

So how do you use the mouse in programs that can be described as serious?

To do this we have to go back a little:

If a program that is accessible to a wide range of users deserves the title 'user-friendly'

67

<!-- TOC PAGE_78: Computer mouse usage guide -->

===========================================================
                       PAGE 78 OF 386                       
===========================================================

should carry, it will usually be structured according to the so-called menu technology. This process has the advantage that it can be handled by almost any operator.

The activities required by the user are communicated to the user via the screen, either individually or to choose from a group of options.

The selection is made either by entering a code letter or by moving the cursor into a field created for this purpose on the screen.

Now experts who understand something about ergonomics have discovered that the selection process can be more comfortable and safer if you don't have to search for the appropriate letter on the keyboard using the eagle system, but the whole thing can be done leaning back in a soft armchair.

Of course, this assumes that the entire program can be handled in this way, i.e. all required inputs must be tailored to this system.

With the mouse, the movements of the cursor on the screen correspond to those of the device on the table surface. Reaching the desired field is signaled to the computer by pressing a button on the mouse.

So much for the application and history of the “mouse”.

In order to give you the opportunity to do your own experiments with this charming animal without purchasing an expensive spin ball, we have developed the following small program, which works with a normal joystick on control port 2 of your CBM64.

Of course, you can't achieve the same level of comfort as with a real mouse, but it is extremely useful for testing the principle.

According to a tried and tested method, we first want to give you the

68

<!-- TOC PAGE_79: Program variables and memory guide -->===========================================================
                       PAGE 79 OF 386                       
===========================================================

introduce the variables and memory addresses used and then discuss the program in detail.

First the variables:

RO$ sign for reverse on
RF$ sign for reverse off
A$ each character entered
After RETURN, B$ contains all characters entered up to that point
A Two-dimensional variable field which contains the ASC value of the character shown there for each position of the first four lines of the screen.
DR original value of the data direction register in 56322. This value must be poked back there when the program ends properly.
J value caused by the joystick at control port 2
JS column position of the joystick
JZ line position of the joystick
PS column position for PRINT
PZ line position for PRINT
S Column position of the joystick cursor for indexing A(y,x)
Z as above, but line position

Now the memory addresses:

56322 Data direction register for control port 2
58643 Operating system routine for querying the cursor position
58636 Operating system routine for positioning the cursor
781 Contents of the processor register X, which is loaded from or stored there with SYS commands

69

<!-- TOC PAGE_80: Commodore 64 cursor control code -->

===========================================================
                       PAGE 80 OF 386                       
===========================================================

782 as above, but processor register Y
204 =0 Switch on cursor
=1 Turn off cursor
205 Counter for flashing frequency of the cursor
207 =0 Cursor in OFF phase
&lt;&gt;0 Cursor in ON phase

The program is discussed step by step below:

1 Since the control ports and keyboard occupy the same peripheral modules in the C64, the keyboard is switched off here. At the end of your program you have to poke the value in DR back to 56322, otherwise the computer will no longer respond to the keyboard. From our example program, only STOP/RESTORE saves you.
10-50 The menu field is displayed on the screen here.
60-560 The array is filled with the ASC values ​​of the characters in screen lines 1-4. If the array is indexed with the row and column position, it returns the value of the character located at this location on the screen.
680 The character supplied by subprogram 5000 is brought to the screen.
700 The cursor position resulting from the PRINT is saved because the menu field is rebuilt in 720. This is necessary because when the screen is full the lines are scrolled up and the field can be destroyed.
760 The cursor that was moved when the field was rebuilt is brought back to the old position.
780 If the last character was RETURN, the

<!-- TOC PAGE_81: C64 joystick cursor control code -->

===========================================================
                       PAGE 81 OF 386                       
===========================================================

Input of a line aborted. If you wish to further use the data, you should remove it from B$ here.

800 Otherwise, the entered character is appended to B$.

5020-5140 The cursor is saved and turned off. Then the cursor is set to position 0 and switched on again.

5160 The value delivered by the joystick at control port 2 is brought to J.

5170 delay loop. This makes the cursor easier to control.

5180-5340 The cursor is moved according to the position of the joystick lever.

If the button on the joystick was pressed (5260), the character under the cursor (from 6010) is adopted to A$.

6010-6160 The cursor position of the joystick is used to address the array A(y,x) and the resulting character is brought to A$ (6060).

Since the C64 has a double-line organization, i.e. the column counter can include 80 positions even though a screen line only holds 40 characters, the column value is corrected in 6050 to correctly index the array.

Using this program is extremely easy.

After RUN, the cursor appears in the upper left corner of the screen.

You can now move this using the joystick, which you hopefully have plugged into control port 2.

If it now coincides with a character that you would like to transfer to B$, simply move the button.

71

<!-- TOC PAGE_82: BASIC program listing code -->===========================================================
                       PAGE 82 OF 386                       
===========================================================

As a confirmation, the selected character appears a few lines below. Now look for the next character.

After selecting RETURN, the line is completely in B$, from which you can now take the data.

Then continue in the same way with the next line.

We hope you enjoy the program and encourage you to try it yourself.

Finally, the program listing:

1 dr=peek(56322):poke56322,224:ro$=chr$(18):rf$=chr$(146)
5 printchr$(147):gosub10:goto60
10 printchr$(19)" , - . / 0 1 2 3 4 5 6 7 8 9
";
20 print" ☐ a b c d e f g h i j k l
";
30 print" m n o p q r s t u v w x y z
";
40 print" "ro$"ret"rf$" "ro$"del"rf$" "ro$"f1"rf$" " ro$"f3"rf$" "ro$"f5"rf$;
45 print" "ro$"f7"rf$"
50 returns
60 dima(4.40)
100 fori=0to13
120 a(0,i*2+1)=i+44
140 nexti
180 fori=0to12
200 a(1,i*2+2)=i+64
220 nexti
260 fori=0to13
280 a(2,i*2+1)=i+77
300 nexti
340 fori=1to3

72

<!-- TOC PAGE_83: BASIC joystick input routine -->

===========================================================
                       PAGE 83 OF 386                       
===========================================================

73

360 a(3,i)=13
380 nexti
420 fori=5to7
440 a(3,i)=20
460 nexti
500 fori=0to3
520 a(3,i*2+9)=i+133
540 a(3,i*2+9)=i+133
560 nexti
580 print:print
600 b$=""x=fre(0)
640 gosub5000: get rem characters
680 printa$;
700 sys58643:pz=peek(211):ps=peek(214)
720 gosub10
760 poke211,pz:poke214,ps:remsys58636
780 ifasc(a$)=13then600
800 b$=b$+a$
820 goto640
5000 rem
5001 rem *** joystick query ***
5002 rem
5020 sys58643:rem save print cursor
5060 pz=peek(781):ps=peek(782)
5070 poke205.3
5080 ifpeek(207)then5080
5090 poke204.1
5100 poke781,0:poke782,0:jz=0:js=0
5120 sys58636:set rem joystick cursor
5140 poke204,0: turn on rem cursor
5160 j=peek(56320):query rem joystick
5170 fori=0to50:nexti
5180 if(j and1)=0thenjz=jz-1
5200 if(j and2)=0thenjz=jz+1

<!-- TOC PAGE_84: BASIC programming code snippet -->

===========================================================
                       PAGE 84 OF 386                       
===========================================================

74

5220 if(j and4)=0thenjs=js-1
5240 if(j and8)=0thenjs=js+1
5260 if(j and16)=0then6000
5280 ifjz&lt;0thenjz=0
5281 ifjs&lt;0thenjs=0
5282 ifjs&gt;30thenjs=30
5283 ifjz&gt;3thenjz=3
5285 poke205.3
5290 ifpeek(207)then5290
5295 poke204.1
5300 poke781,jz:poke782,js:sys58636
5340 goto5140
6000 rem
6001 rem *** assignment to a character ***
6002 rem
6010 poke205.3
6015 ifpeek(207)then6015
6017 poke204.1
6020 sys58643: get rem cursor position
6040 z=peek(781):s=peek(782)
6050 ifs&gt;39thens=s-40
6060 a$=chr$(a(z,s))
6100 poke781,pz:poke782,ps
6120 sys58636:rem load print position
6160 returns

<!-- TOC PAGE_85: Basic programming tutorial chapter -->

===========================================================
                       PAGE 85 OF 386                       
===========================================================

CHAPTER 4 BASIC FOR ADVANCED PEOPLE

## 4.1 CREATE A BASIC LINE IN BASIC

Have you ever tried to write a truly universal computing program?

By universal we mean a program with which any arithmetic operations can be carried out with any variables or constants. The emphasis is on “any”.

Of course not, you will answer, because the essence of a program is to process the data according to predetermined algorithms.

Sure, but imagine that you want to write a computational word processor (there is such a thing).

In your text you have numeric fields that should be linked together arithmetically. This is the case, for example, when writing an invoice, where the price fields of the individual items are to be added up, the sum is then multiplied by the VAT rate and packaging and postage are also added.

You can of course write a version of the program outlined above that is specifically tailored to the needs of invoice writing.

Such a program is certainly quite useful if you know the prices of the individual items and can enter them accordingly.

However, a carpet dealer who sells carpeting from the roll has a much more difficult time with this program because the price of his goods depends on the number of square meters. He has to calculate this first and only afterwards

75

<!-- TOC PAGE_86: Programming guide for dynamic calculations -->===========================================================
                       PAGE 86 OF 386                       
===========================================================

multiplying by the price per square meter determines the value that it can provide to the billing program described.

No problem, you'll say, let's just write another version for the carpet dealer.

Sure, but how many versions should be created for how many retailers?

Wouldn't it be much more practical to have a single version that covers all types of calculations?

That's exactly what we want to teach you here, namely a procedure with which you can subsequently, i.e. during the program run, determine which variables should be linked to each other and how.

This is only possible if you can generate a basic line with the desired formula as often as you want while the program is running.

We now want to show you how this is done.

The program discussed below also contains a machine language part, but don't worry, this is also handled using Basic.

Before we go into more detail about the individual program steps, we will first introduce you to the variables and memory addresses used.

First the variables:

TM address of the end of memory
VL low-order byte of the address 'variable start'
VH as above, but higher byte
VT as above, but overall value
BU address from the area of the line input buffer
BC Run variable for filling the buffer

76

<!-- TOC PAGE_87: Basic program memory allocation guide -->

===========================================================
                       PAGE 87 OF 386                       
===========================================================

CA$ entered calculation rule

RE this is the result after the routine has been run

The storage locations used:

45-46 Pointer to start of variable
47-48 Pointer to start of arrays
49-50 Pointer to start of strings
56 high-order byte of the pointer to the end of the Basicram
40448 here is the generated basic line 50100
40704 from here is the routine that creates a basic line from the contents of the input buffer and brings it to 40448

Now the program step by step

1 The upper memory limit is reduced to 40448, since the machine routine and later also the generated basic line are located above this address.
2-6 The variable start pointer is incremented because connection line 50099 is inserted here.
10-14 Lines 50100 and 50110 are set up here in advance so that they are definitely present when they are jumped to without an operation having been previously stored there. The lines simply contain PRINT and RETURN.
20-30 The connection line 50099 is placed immediately after the basic program.
The continuation address of this line points to line 50100 at address 40449.
32-50 These lines contain the machine program, which will be discussed in more detail later.

77

<!-- TOC PAGE_88: Machine code program listing -->

===========================================================
                       PAGE 88 OF 386                       
===========================================================

60-70 The machine program is brought into memory starting at 40704.

50040 The basic line is read from the keyboard in CA$.

When entering, please take into account that only functions need to be entered. Before entering, imagine the statement 'RE=' as given.

50050 The input is brought from CA$ into the line input buffer (to 50075).

50080 The machine program for generating the basic line is started.

50095 The actual calculation starts here. The result is returned in RE.

For those who are interested, the machine program:

|  lda $7a | Save Basicpointer |
| --- | --- |
|  sta $9fff |   |
|  lda $7b |   |
|  sta $9ffe |   |
|  lda $14 |   |
|  sta $9ffd |   |
|  lda $15 |   |
|  sta $9ffc |   |
|  lda #$0b | Offset on input buffer |
|  sta $7a |   |
|  jsr $a579 | Calling the routine 'CRUNCH' |
|  ldx #0 |   |
|  XX lda $0200(x) | Transfer line to 40453 |
|  beq YY | Output when end |
|  sta $9e05(x) |   |
|  inx |   |
|  bne XX |   |

<!-- TOC PAGE_89: Commodore 64 BASIC machine code -->===========================================================
                       PAGE 89 OF 386                       
===========================================================

YY lda #$3a : behind the line
sta $9e05(x)
Append lda #$8e RETURN
sta $9e06(x)
lda #0 Mark end of line
sta $9e07(x)
sta $9e08(x)
sta $9e09(x)
lda $9fff Reload basic pointer
sta $7a
lda $9ffe
sta $7b
lda $9ffd
sta $14
lda $9ffc
sta $15
ret back to Basic

The program, which is listed below, consists of two parts:

The first part of lines 1 to 70 only needs to be jumped to once when the program starts. It is important that it is actually at the beginning of your program and is not transferred to other line numbers, otherwise your variables in lines 1 and 6 will be destroyed.

The second part finally produces a basic line from the calculation rule entered in CA$ and executes it. The result is in RE.

If the operation does not change continuously, you can of course also jump to line 50100 several times in a row.

Your program in which these routines are integrated can only go up to line 49999. The lines starting from 50000 must

79

<!-- TOC PAGE_90: BASIC programming instructions listing -->

===========================================================
                       PAGE 90 OF 386                       
===========================================================

definitely be the last in the program.

To use it, just say that you only need to enter functions in response to the input request (INPUT CA$), e.g. '75/2*V1-V2+SQR(V3)'.

The assignment of the result to RE is already given in line 50050.

**ATTENTION!** Once the program has already been started, it may no longer be changed. In this case you should enter NEW, reload the program and then change it. This is because the lines created are not immediately behind the rest of the program, but rather at the top of the memory. The operating system cannot manage such an arrangement when inserting or deleting a line.

Here is the program listing:

1. poke56,158:clr
2. ifpeek(45)+2&gt;255thenpoke45,2-(256-peek(45)):
poke46,peek(46)+1:goto6
4. poke45,peek(45)+2
6. poke47,peek(45):poke48,peek(46):poke49,peek(45):
poke50,peek(46)
8. tm=40448
10. poketm,0:poketm+1,7:poketm+2,158:poketm+3,180
poketm+4,195
12. poketm+5,153:poketm+6,0:poketm+7,13:poketm+8,158:
poketm+9,190
14. poketm+10,195:poketm+11,142:poketm+12,0:
poketm+13.0:poketm+14.0
20. vl=peek(45):vh=peek(46):vt=vh*256+vl
30. pokevt-4.1:pokevt-3.158:pokevt-2.179:pokevt-1.195

80

<!-- TOC PAGE_91: BASIC calculator program code -->

===========================================================
                       PAGE 91 OF 386                       
===========================================================

32 data165,122,141,255,159,165,123,141,254,159,165,20, 141,253,159,165,21
33 data141,252,159,169,11,133,122,32,121,165
34 data162,0,189,0,2,240,6,157,5,158,232,208,245,169, 58,157,5,158
36 data169,142,157,6,158,169,0,157,7,158,157,8,158, 157,9,158
40 data173,255,159,133,122,173,254,159
50 data133,123,173,253,159,133,20,173,252,159,133,21,96
60 fori=40704to40785
70 read mc:pokei,mc:nexti
50000 rem calculator
50040 bu=523:input"calc";ca$
50050 pokebu,asc("r"):pokebu+1,asc("e"):
pokebu+2,asc("="):bu=bu+2
50060 fori=1tolene(ca$)
50070 pokebu+i,asc(mid$(ca$,i,1)):nexti
50073 bc=len(ca$)+1
50075 pokebu+bc,0:pokebu+bc+1,0:pokebu+bc+2,0
50080 sys40704
50095 gosub50100
50097 returns

At the (hopefully) good end, a suggestion for 'incubation':
Imagine that you have found a process that generates the basic line required for the solution from a problem that needs to be specifically formulated. Imagine further that this procedure is so universal that it is able to generate a series of basic lines from a chain of tasks, including all loops and jumps.
The only problem that remains is putting these lines in one after the other

81

<!-- TOC PAGE_92: Basic program generator explanation -->===========================================================
                       PAGE 92 OF 386                       
===========================================================

to bring the memory. Although the method described above can only create one basic line, it could be expanded to be suitable for multiple lines.

It should be noted that the machine program does not always transfer the generated line to the same location, but must increase the start address according to the length of the previously generated line.

In addition, the line sequence pointers (these are the first two bytes at the beginning of each basic line) would have to be supplied accordingly, which we neglected in our example because the return command is in the generated line itself.

Maybe you can use this suggestion to build a really good program generator, because that's basically what it is. Program generators are programs that are entrusted with certain tasks from a specific topic and use them to create a program in a known programming language (it doesn't always have to be Basic), i.e. a kind of macro interpreter.

82

<!-- TOC PAGE_93: Commodore 64 BASIC interpreter guide -->

===========================================================
                       PAGE 93 OF 386                       
===========================================================

83

#4.2 COPYING THE BASIC INTERPRETER TO RAM

The Commodore 64 has the advantage over other Commodore computers in that the entire address space of the processor - 64 Kbytes - is equipped with RAM. This means you can equip the Commodore 64 with a completely new operating system and a new BASIC interpreter without replacing any ROM components. All you need to do is load or transfer the new or modified operating system or BASIC interpreter into RAM and then tell the computer to turn off the ROM and activate the corresponding RAM. This can be achieved using POKE commands.

If you don't want to load a completely new BASIC, but only want to change some properties of the BASIC interpreter, e.g. implementing your own functions or modifying existing functions or commands, you simply copy the BASIC interpreter into RAM, make the changes there and then switch to RAM.

A little more about the memory management of the Commodore 64. When you switch on the computer, the operating system ROM and the BASIC ROM are switched on and started. If you now read this memory area with a PEEK command, you will get the value back from the ROM (you can find out how to get to the RAM in Chapter 9.5). However, if you write to the memory area with POKE, it will always be written to the RAM, regardless of whether ROM or RAM is selected. We can exploit this property if we want to copy the entire operating system or the BASIC ROM into the underlying RAM in order to manipulate it in the RAM for our purposes. Copying can be done like this

<!-- TOC PAGE_94: BASIC ROM to RAM copy guide -->===========================================================
                       PAGE 94 OF 386                       
===========================================================

in a BASIC loop.

FOR I=A TO E : POKE I, PEEK(I) : NEXT

A means the start address and E means the end address. For BASIC these are the addresses 40960 ($A000) and 49151 ($BFFF); the operating system ranges from 57344 ($E000) to 65535 ($FFFF).

This POKE loop copies the contents of the ROM into the RAM underneath. However, the BASIC still runs in ROM. We first have to tell the computer that the RAM should be selected.

Memory location 1, the processor port that serves the memory allocation, is used for this purpose. Normally this memory cell contains the value 55. If you want to put the BASIC in the RAM, you have to select the RAM with POKE 1, 54. Attention: You may only carry out this POKE once you have copied the BASIC from 40960 to 49151 into the RAM using the above loop, otherwise your computer will 'crash'! If you also want to put the operating system in the RAM, this is only possible together with the BASIC ROM, since when you select this RAM, the RAM under the BASIC ROM is automatically selected (see also Chapter 2.8). The POKE command for this is POKE 1.53. If you want to manipulate your BASIC interpreter in this way, first copy the ROM, make the desired changes and first save the program with which you made the changes and then switch over with POKE 0,.... If you have made a mistake, your computer may say goodbye and you will have to start all over again. This way you can load the program again, correct the errors and run it again until things work the way you imagined.

84

<!-- TOC PAGE_95: Commodore 64 FRE function bug -->

===========================================================
                       PAGE 95 OF 386                       
===========================================================

85

# 4.3 NO MORE NEGATIVE NUMBERS IN THE FRE FUNCTION

Have you also noticed that your Commodore 64 responds to the command with 38,911 bytes free when you switch it on?

## PRINT FRE(O)

but answers with -26627?

If you have received a negative number, you first have to add 2 to the power of 16 equal to 65536 to get the correct value. This is not tragic, but annoying. Now what is the reason for this?

To do this, we have to look at the relevant location in the ROM listing. (Address $B37D: 64 internal). After the strings that are no longer needed are removed and their storage space is released again (garbage collection), the free storage space is calculated: start of the strings ($33/$34) minus the end of the arrays ($31/$32). This 16-bit integer value is now converted into floating point format and returned. Now here lies the error. The integer value is treated as a signed number, analogous to the integer variables (%), which can only have values ​​from -32768 to 32767. However, if these numbers are considered positive values, they can range from 0 to 65535. On the early Commodore computers the free memory was never larger than 32767 bytes, so this error never occurred. We now have to change the FRE routine so that the conversion to floating point numbers assumes a positive integer value, as is the case, for example, with the output of line numbers, which, as we know

<!-- TOC PAGE_96: BASIC interpreter code patch -->

===========================================================
                       PAGE 96 OF 386                       
===========================================================

can be larger than 32767.

These are the changes that are needed. Here we went and placed the additional code into an unused area of ​​the BASIC interpreter.

|  B38D | 4C 55 BF | JMP $BF55 |
| --- | --- | --- |
|  B390 | EA | NOP |
|  BF55 | A5 34 | LDA $34 |
|  BF57 | E5 32 | SBC $32 |
|  BF59 | A2 00 | LDX #$00 |
|  BF5B | 86 0D | STX $0D |
|  BF5D | 85 62 | STA $62 |
|  BF5F | 84 63 | STY $63 |
|  BF61 | A2 90 | LDX #$90 |
|  BF63 | 4C 49 BC | JMP $BC49 |

The values ​​can be set with a small POKE loop.

100 FOR I=40960 TO 49151
110 POKE I, PEEK(I) : NEXT
120A=11*4096+3*256+8*16+13
130 FOR I=A TO A+3
140 READ X : POKE I,X :NEXT
150A=11*4096+15*256+5*16+5
160 FOR I=A TO A+16
170 READ X : POKE I,X : NEXT
180 POKE 1.54
200 DATA 76,85,191,234
210 DATA 165,52,229,50,162,0,134,13,133,98,132,99
220 DATA 162,144,76,73,188

86

<!-- TOC PAGE_97: BASIC programming return routine -->===========================================================
                       PAGE 97 OF 386                       
===========================================================

87

# 4.4 RETURN TO BASIC PROGRAM AFTER A LIST COMMAND

If you include a LIST command in a BASIC program, the program always jumps back to direct mode after executing the LIST command. This is annoying if, for example, you want to output lines that contain a function definition with DEF FN in order to display the respective function on the screen. Likewise, you could not output a program listing from a program multiple times, nor in direct mode in a loop, e.g.

FOR I=1 TO 2 : LIST : NEXT

The remedy here is as follows: At the end of the LIST function, replace the jump to the BASIC warm start with a return command. In addition, you must save the pointer to the program text before calling the LIST function, as it will be changed during the LIST function.

To do this we need a small routine that carries out these tasks and jumps back to the BASIC interpreter. Since this requires a small machine program anyway, we'll also include copying the BASIC ROM into RAM. This saved us the slow BASIC-POKE loop.

We put the little routine in the cassette buffer. After entering or loading it is called once with SYS 828 and from now on the LIST command can be used without aborting the program.

<!-- TOC PAGE_98: Assembly code listing -->===========================================================
                       PAGE 98 OF 386                       
===========================================================

88

105:033c
* = 828 ; Cassette buffer
110:033c
chrptr = $7a ; Program pointer
112:033c
chrgot = $79 ; gets last character
114:033c
list = $a69c ; LIST routine
115:033c
lstvec = $a042 ; Pointer to LIST routine
116:033c
nextst = $a8f8 ; sets program pointer
; on the next statement
117:033c
crlf = $aad7 ; outputs CR
119: 033c a2 20
ldx #32 ; Copy 32 Pages
120: 033e a9 a0
lda #&gt;$a000 ; Pointer to start of BASIC
120:0340a000
ldy #0
120: 0342 84 22
sty $22
120: 0344 85 23
sta $23
121:0346 b1 22
loop
lda ($22),y ; Transfer loop
121: 0348 91 22
sta ($22),y
121:034a c8
iny
122: 034b d0 f9
bne loop
122: 034d e6 23
inc $23
122: 034f approx
dex
122:0350 d0 f4
bne loop
123: 0352 a9 60
lda #$60 ; RTS code
123: 0354 8d 14 a7
sta $a714
123: 0357 a9 ea
lda #$ea ; NOP code
123: 0359 8d bb a6
sta $a6bb
123: 035c 8d bc a6
sta $a6bc
125: 035f a9 6d
lda #<newlst-1 ;="" 125:="" 42="" a0="" a6="" a9="" a6bb="" a6bc="" a9="" a96d="" a6b="" a0="" a9:newlst-1="" a9:newlst-10="" a9:newlst-11="" a9:newlst-12="" a9:ok="" a9:osm="" a9:sw="" a9:xt="" a9:y="" a9:z="" a9:z4="" a9:z5="" a9:z6="" a9:z8="" a9:z9="" a9:z90="" a9:z91="" a9:z92="" a9:z94="" a9:z95="" a9:z96="" a9:z98="" a9:z99="" a9:z9a="" a9:z9b="" a9:z9c+1="" a9:z9c+10="" a9:z9c+12="" a9:z9c+13="" a9:z9c+14="" a9:z9c+15="" a9:z9c+16="" a9:z9c+17="" a9:z9c+18="" a9:z9c+19="" a9:z9c+20="" a9:z9c+21="" a9:z9c+22="" a9:z9c+23="" a9:z9c+24="" a9:z9c+25="" a9:z9c+26="" a9:z9c+27="" a9:z9c+28="" a9:z9c+29="" a9:z9c+30="" a9:z9c+31="" a9:z9c+32="" a9:z9c+33="" a9:z9c+34="" a9:z9c+35="" a9:z9c+36="" a9:z9c+37="" a9:z9c+38="" a9:z9c+39="" a9:z9c+40="" a9:z9c+41="" a9:z9c+42="" a9:z9c+43="" a9:z9c+44="" a9:z9c+45="" a9:z9c+46="" a9:z9c+47="" a9:z9c+48="" a9:z9c+49="" a9:z9c+50="" a9:z9c+51="" a9:z9c+52="" a9:z9c+53="" a9:z9c+54="" a9:z9c+55="" a9:z9c+56="" a9:z9c+57="" a9:z9c+58="" a9:z9c+59="" a9:z9c+60="" a9:z9c+61="" a9:z9c+62="" a9:z9c+63="" a9:z9c+64="" a9:z9c+65="" a9:z9c+66="" a9:z9c+67="" a9:z9c+68="" a9:z9c+69="" a9:z9c+70="" a9:z9c+71="" a9:z9c+72="" a9:z9c+73="" a9:z9c+74="" a9:z9c+75="" a9:z9c+80="" a9:z9c+81="" a9:z9c+82="" a9:z9c+83="" a9:z9c+84="" a9:z9c+85="" a9:z9c+86="" a9:z9c+87="" a9:z9c+88="" a9:z9c+89="" a9:z9c+90="" a9:z9c+91="" a9:z9c+92="" a9:z9c+93="" a9:z9c+94="" a9:z9c+95="" a9:z9c+96="" a9:z9c+97="" a9:z9c+98="" a9:z9c+99="" a9:z9c+10="" a9:z9c+11="" a9:z9c+12="" a9:z9c+13="" a9:z9c+14="" a9:z9c+15="" a9:z9c+16="" a9:z9c+17="" a9:z9c+18="" a9:z9c+19="" a9:z9c+20="" a9:z9c+21="" a9:z9c+22="" a9:z9c+23="" a9:z9c+24="" a9:z9c+25="" a9:z9c+26="" a9:z9c+27="" a9:z9c+28="" a9:z9c+29="" a9:z9c+30="" a9:z9c+31="" a9:z9c+32="" a9:z9c+33="" a9:z9c+34="" a9:z9c+35="" a9:z9c+36="" a9:z9c+37="" a9:z9c+38="" a9:z9c+39="" a9:z9c+40="" a9:z9c+41="" a9:z9c+42="" a9:z9c+43="" a9:z9c+44="" a9:z9c+45="" a9:z9c+46="" a9:z9c+47="" a9:z9c+48="" a9:z9c+49="" a9:z9c+50="" a9:z9c+51="" a9:z9c+52="" a9:z9c+53="" a9:z9c+54="" a9:z9c+55="" a9:z9c+56="" a9:z9c+57="" a9:z9c+58="" a9:z9c+59="" a9:z9c+60="" a9:z9c+61="" a9:z9c+62="" a9:z9c+63="" a9:z9c+64="" a9:z9c+65="" a9:z9c+66="" a9:z9c+67="" a9:z9c+68="" a9:z9c+69="" a9:z9c+70="" a9:z9c+71="" a9:z9c+72="" a9:z9c+73="" a9:z9c+80="" a9:z9c+81="" a9:z9c+82="" a9:z9c+83="" a9:z9c+84="" a9:z9c+85="" a9:z9c+86="" a9:z9c+87="" a9:z9c+88="" a9:z9c+89="" a9:z9c+90="" a9:z9c+91="" a9:z9c+92="" a9:z9c+93="" a9:z9c+94="" a9:z9c+95="" a9:z9c+96="" a9:z9c+97="" a9:z9c+98="" a9:z9c+99="" a9:z9c+00="" a9:z9c+10="" a9:z9c+11="" a9:z9c+12="" a9:z9c+120="" a9:z9c+121="" a9:z9c+122="" a9:z9c+123="" a9:z9c+124="" a9:z9c+125="" a9:z9c+126="" a9:z9c+127="" a9:z9c+128="" a9:z9c+129="" a9:z9c+130="" a9:z9c+131="" a9:z9c+14="" a9:z9c+15="" a9:z9c+16="" a9:z9c+17="" a9:z9</newlst-1>

<!-- TOC PAGE_99: BASIC machine code listing -->===========================================================
                       PAGE 99 OF 386                       
===========================================================

89

130: 0370 48 pha ; Save program pointer
140: 0371 a5 7b lda chrptr+1
150: 0373 48 pha
160: 0374 20 79 00 jsr chrgot ; get last character
170: 0377 20 9c a6 jsr list ; Run LIST
175: 037a 20 d7 aa jsr crlf ; 'CR' output
180: 037d 68 pla
190: 037e 85 7b sta chrptr+1
200: 0380 68 pla ; Retrieve program pointer
210: 0381 85 7a sta chrptr
220: 0383 20 f8 a8 jsr nextst ; Pointer to next statement
230: 0386 4c 79 00 jmp chrgot ; get last character

Here again the loading program in BASIC.

100 for i = 828 to 904
110 read x : poke i,x : s=s+x : next
120 data 162, 32,169,160,160, 0.132, 34,133, 35,177, 34
130 data 145, 34,200,208,249,230, 35,202,208,244,169, 96
140 data 141, 20,167,169,234,141,187,166,141,188,166,169
150 data 109,141, 66,160,169, 3,141, 67,160,169, 54,133
160 data 1, 96,165,122, 72,165,123, 72, 32,121, 0, 32
170 data 156,166, 32,215,170,104,133,123,104,133,122, 32
180 data 248,168, 76,121, 0
190 if s &lt;&gt; 9613 then print "error in datas!!" :end
200 print "ok!"

If you run the following small BASIC program once without and then after calling SYS 828, you will see the difference.

100 PRINT “LIST TEST”
110 LIST 120
120 GOTO 100

<!-- TOC PAGE_100: BASIC interpreter programming guide -->

===========================================================
                      PAGE 100 OF 386                       
===========================================================

90

# 4.5 CALCULATED LINE NUMBERS IN GOTO, GOSUB AND RESTORE

Let us now look at a very useful change to the BASIC interpreter.

If you want to call a program branch or a subprogram, you must enter the line number as a number. However, for more convenient programming, it would be desirable if the line number could be calculated, e.g. B. as the following small program assumes.

```
100 INPUT "LINE NUMBER";Z
110 GOTO Z
...
```

This could replace an extensive ON .. GOTO series. The same applies to the GOSUB command. Here too we want to allow calculated line numbers.

A RESTORE line number would also be a significant advance. For example, if you have several different related data blocks that you want to read multiple times, you could previously only reset the READ-DATA pointer to the beginning of the program and then you may have had to read over large amounts of data until you got to the desired data. A RESTORE line number now allows you to set the DATA pointer specifically to any line.

Changing the GOTO command can be accomplished with a few POKEs. All we need to do is replace the line number fetch call with a routine that fetches an arbitrary numeric expression and converts it to the required address format. Have the GOSUB command

<!-- TOC PAGE_101: Assembly code modification guide -->

===========================================================
                      PAGE 101 OF 386                       
===========================================================

This is modified at the same time, since the GOTO routine is called by GOSUB.

A8AO 20 CO 02 JSR $02CO

02CO 20 8A AD JSR $AD8A

02C3 4C F7 B7 JMP $B7F7

Here we have placed the additional code at the address $02CO (704), which is normally free as long as you are not using Sprite 11.

The code can be brought into memory with a few pokes

100 FOR I=40960 TO 49151
110 POKE I, PEEK(I) : NEXT
120A=10*4096+8*256+10*16
130 FOR I=A TO A+2
140 READ X : POKE I,X :NEXT
150A=704
160 FOR I=A TO A+5
170 READ X : POKE I,X :NEXT
200 DATA 32,192.2
210 DATA 32,138,173,76,247,183

We have now covered the GOTO and GOSUB commands. The RESTORE command requires a little more since no line number is normally allowed. So we have to distinguish whether it is a RESTORE command with or without a line number. However, this is not difficult.

02C6 DO 03 BNE $02CB ; are there any more characters?
02C8 4C 1D A8 JMP $A81D ; to the old RESTORE command
02CB 20 CO 02 JSR $02CO ; Get line number

91

<!-- TOC PAGE_102: BASIC RESTORE routine modification -->===========================================================
                      PAGE 102 OF 386                       
===========================================================

02CE 20 13 A6 JSR $A613 ; Calculate address of line number

02D1 38 SEC

02D2 A5 5F LDA $5F ; Address low

02D4 E9 01 SBC #$01 ; deduct one

02D6 A4 60LDY $60 ; Address high

02D8 4C 24 A8 JMP $A824 ; continue as old RESTORE command

We can enter the code again using pokes.

300A=2*256+12*16+6

310 FOR I=A TO A+20

320 READ X : POKE I,X : NEXT

330 DATA 208,3,76,29,168,32,192,2,32,19,166

340 DATA 56,165,95,233,1,164,96,76,36,168

Now we have to tell the interpreter where the new RESTORE routine is:

400 POKE 40996, 197 : POKE 40997, 2

410 POKE 1.54

Line 410 switches back to RAM. From now on you can use the RESTORE command in three variants:

Once without a line number as before, then with a line number and an expression that is evaluated and results in the line number. In this case, the next READ command reads the DATA element that is next from this line number. If the line number does not exist, there is no error message 'undef'd statement', but the pointer is automatically set to the next line. Now, for example, the following programming would be possible.

100 GOTO 200

...

<!-- TOC PAGE_103: BASIC program listing snippet -->

===========================================================
                      PAGE 103 OF 386                       
===========================================================

200 RESTORE 10
500 RESTORE
800 GOSUB A*2+100
900 RESTORE X*100+500

93

<!-- TOC PAGE_104: MID$ command documentation -->

===========================================================
                      PAGE 104 OF 386                       
===========================================================

94

# 4.6 THE MID$ COMMAND

I'm sure you all know the MID$ function, which can be used to isolate a part of a string. The following program example

```txt
100 A$ = "TEST STRING"
110 B$ = MID$(A$,5,3)
120 PRINT B$
```

leads to expression

## STR

Below you will find an extension of the MID$ command that not only allows you to READ parts of a string, but also REPLACE parts of a string. With the new command, the following programming is possible, for example:

```txt
100 A$ = "TEST STRING"
110 MID$(A$,5,3) = "123"
120 PRINT A$
```

Here 3 characters from position 5 are replaced by the character string "123"; arises as a result

## TEST123ING

Without the MID$ command, you would have to break the string into individual parts and reassemble them:

```txt
100 A$ = "TEST STRING"
110 A$ = LEFT$(A$,4) + "123" + MID$(A$,7,3)
```

<!-- TOC PAGE_105: BASIC MID$ function documentation -->

===========================================================
                      PAGE 105 OF 386                       
===========================================================

95

#120 PRINT A$

This command is very useful, for example, if you want to replace individual parts (data fields) in a data record. To do this, define a string the length of the data record and replace the values ​​of the individual data fields with the new MID$ command.

The command is again implemented with a small machine program.

```asm
90:033c.opt p1
; mid$ as a pseudo variable
;
; mid$(string variable, position, length) = string expression
; mid$(stringvariable,position) = stringexpression
;
200: 033c midcode = $approx
210: 033c execute = $308 ; vector for statement execute
220: 033c chrget = $73
230:033c chrgot = chrget + 6
240: 033c execold = $a7e7
250: 033c varnam = $45
255: 033c varadr = $49
260: 033c descrpt = $64
270: 033c teststr = $ad8f
280: 033c getvar = $b08b
290: 033c setstr = $aa52
300: 033c chkauf = $aefa ; clip on
310: 033c chkzu = $aef7 ; clamp closed
320: 033c chkcom = $aefd ; comma
325: 033c test = $aeff
330: 033c getbyt = $b79e
340: 033c frmevl = $ad9e
350: 033c illquan = $b248
```

<!-- TOC PAGE_106: Assembly code listing page -->===========================================================
                      PAGE 106 OF 386                       
===========================================================

96

352: 033c frestr = $b6a3
355: 0003 *= 3
360: 0004 length *= *+1
370: 0005 position *= *+1
372: 0007 varstr *= *+2
375: 0007 equals = $b2
378: 0007 show2 = $50

390: 033c *= 828
400: 033c a9 47 init lda #<midtest !="" !)="" 033e="" 0340="" 0343="" 0346="" 0347="" 034e="" 0351="" 0354="" 0357="" 0360="" 0361="" 0362="" 0363="" 0365="" 0366="" 0370="" 0372="" 0374="" 0375="" 0376="" 0380:="" 0386="" 0387="" 0390:="" 0392="" 0394="" 0396="" 0398="" 0399:="" 0400:="" 0401="" 0402="" 0403="" 0404="" 0405="" 0406="" 0407="" 0408="" 0409="" 0410:="" 0411="" 0412="" 0413="" 0414="" 0415="" 0416="" 0417="" 0418="" 0419="" 0420:="" 0421="" 0422="" 0423="" 0424="" 0425="" 0426="" 0427="" 0428="" 0429="" 0430:="" 0431="" 0432="" 0433="" 0434="" 0435="" 0436="" 0437="" 0438="" 0439="" 0440="" 0441="" 0442="" 0443="" 0444="" 0445="" 0446="" 0447="" 0448="" 0449="" 0450="" 0451="" 0452="" 0453="" 0454="" 0455="" 0456="" 0457="" 0458="" 0459="" 0460="" 0461="" 0462="" 0463="" 0464="" 0465="" 0466="" 0467="" 0468="" 0469="" 0470:="" 0471="" 0472="" 0473="" 0474="" 0475="" 0480:="" 0481="" 0482="" 0483="" 0484="" 0485="" 0486="" 0487="" 0488="" 0489="" 0490:="" 0491="" 0492="" 0493="" 0494="" 0495="" 0496="" 0497="" 0498="" 0499="" 0500:="" 0501="" 0502="" 0503="" 0504="" 0505="" 0506="" 0507="" 0508="" 0509="" 0510="" 0511="" 0512="" 0513="" 0514="" 0515="" 0516="" 0517="" 0518="" 0519="" 0520:="" 0521="" 0522="" 0523="" 0524="" 0525="" 0526="" 0527="" 0528="" 0529="" 0530="" 0531="" 0532="" 0533="" 0534="" 0535="" 0536="" 0537="" 0538="" 0539="" 0540:="" 0541="" 0542="" 0543="" 0544="" 0545="" 0546="" 0547="" 0548="" 0549="" 0550="" 0551="" 0552="" 0553="" 0554="" 0555="" 0556="" 0557="" 0558="" 0559="" 06="" 06a="" 06b="" 06c="" 06c:="" 06c:pt="" 06c:pt+1="" 07="" 079="" 080:="" 080:="" 081="" 082="" 082a="" 082b="" 083="" 083c="" 083d="" 083e="" 083f="" 083g="" 083h="" 083i="" 083j="" 084="" 084r="" 084s="" 084t="" 084u="" 084v="" 084w="" 084x="" 084y="" 084z="" 084z:="" 084z:pt+1="" 085="" 0856="" 0857="" 0858="" 0860="" 0861="" 0862="" 0863="" 0864="" 0865="" 0866="" 0867="" 0868="" 0869="" 0870:="" 0871="" 0872="" 0873="" 0874="" 0875="" 0876="" 0880:="" 0881="" 0882="" 0883="" 0884="" 0885="" 0886="" 0887="" 0888="" 089="" 0899:="" 1="" 1da="" 1da:="" 1de="" 1de:="" 1de:trr="" 1de:trr:="" 1de:td:="" 1de:td:="" 1de:td:1="" 1de:td:2="" 1de:td:3="" 1de:td:4="" 1de:td:5="" 1de:td:6="" 1de:td:7="" 1de:td:8="" 1de:td:9="" 1de:td:10="" 1de:td:11="" 1de:td:2="" 1de:td:3="" 1de:td:49="" 1de:td:50="" 1de:td:51="" 1de:td:52="" 1de:td:53="" 1de:td:54="" 1de:td:55="" 1de:td:56="" 1de:td:57="" 1de:td:58="" 1de:td:59="" 1de:td:60="" 1de:="" <="" <table="" <table="" <table="" <table>

<!-- TOC PAGE_107: Assembly code snippet -->

===========================================================
                      PAGE 107 OF 386                       
===========================================================

97

560: 0376 85 05 sta varstr ; Remember variable address
570: 0378 c8 iny
570: 0379 b1 49 lda (varadr),y
570: 037b 85 06 sta varstr+1
600: 037d 20 fd ae jsr chkcom
610: 0380 20 9e b7 jsr getbyt ; get position
620: 0383 8a txa
630: 0384 f0 17 beq ill
650: 0386 ca dex
650: 0387 86 04 stx position
660: 0389 20 79 00 jsr chgrot
660: 038c c9 29 cmp #")" ; expression over?
665: 038e d0 04 bne next
665: 0390 a9 ff lda #$ff ; max. length
665: 0392 d0 0c bne store
670: 0394 20 fd ae next jsr chkcom
670: 0397 20 9e b7 jsr getbyt ; get length
680: 039a 8a txa
690: 039b d0 03 bne "+5
700: 039d 4c 48 b2 ill jmp illquan
710: 03a0 85 03 store sta length
715: 03a2 68 pla
715: 03a3 38 sec
715: 03a4 e5 04 sbc position
717: 03a6 c5 03 cmp length
717: 03a8 b0 02 bcs ok
717: 03aa 85 03 sta longitude
720: 03ac 20 f7 ae ok jsr chkzu ; clamp closed
730: 03af a9 b2 lda #same
770: 03b1 20 ff ae jsr test
780: 03b4 20 9e ad jsr frmevl ; get expression
790: 03b7 20 a3 b6 jsr frestr
800: 03ba a0 02ldy #2
800: 03bc b1 64 lda (descript),y

<!-- TOC PAGE_108: 6502 assembly code listing -->===========================================================
                      PAGE 108 OF 386                       
===========================================================

98

|  800: | 03be 85 51 |  | sta | show2+1 |
| --- | --- | --- | --- | --- |
|  800: | 03c0 88 |  | dey |   |
|  800: | 03c1 b1 64 |  | lda | (descript),y |
|  800: | 03c3 85 50 |  | sta | show2 |
|  810: | 03c5 88 |  | dey |   |
|  810: | 03c6 b1 64 |  | lda | (descript),y |
|  820: | 03c8 f0 d3 |  | beq | ill ; null, then error |
|  840: | 03ca c5 03 |  | cmp | length |
|  850: | 03cc b0 02 |  | bcs | ok1 |
|  860: | 03ce 85 03 |  | sta | length |
|  870: | 03d0 a5 05 | ok1 | lda | varstr |
|  880: | 03d2 18 |  | clc |   |
|  880: | 03d3 65 04 |  | adc | position |
|  910: | 03d5 85 05 |  | sta | varstr |
|  910: | 03d7 90 02 |  | bcc | *+4 |
|  920: | 03d9 e6 06 |  | inc | varstr+1 |
|  940: | 03db a4 03 |  | ldy | length |
|  950: | 03dd 88 | loop | dey |   |
|  950: | 03de b1 50 |  | lda | (show2),y ; character from string expression |
|  960: | 03e0 91 05 |  | sta | (varstr),y ; transferred to string variable |
|  970: | 03e2 c0 00 |  | cpy | #0 |
|  970: | 03e4 d0 f7 |  | bne | loop |
|  980: | 03e6 4c ae a7 |  | jmp | $a7ae ; to the interpreter's sheet |

After entering the program, you can use the command SYS 828

Initialize your command extension. The BASIC loading program shown below does this initialization automatically.

<!-- TOC PAGE_109: BASIC program code example -->

===========================================================
                      PAGE 109 OF 386                       
===========================================================

100 for i = 828 to 1000
110 read x : poke i,x : s=s+x : next
120 data 169, 71,160, 3,141, 8, 3,140, 9, 3, 96, 32
130 data 115, 0,201,202,240, 6, 32,121, 0, 76,231,167
140 data 32,115, 0, 32,250,174, 32,139,176,133,100,132
150 data 101,133, 73,132, 74, 32,163,182,160, 0,177,100
160 data 72,240, 46, 32, 82,170,160, 1,177, 73,133, 5
170 data 200,177, 73,133, 6, 32,253,174, 32,158,183,138
180 data 240, 23,202,134, 4, 32,121, 0.201, 41,208, 4
190 data 169,255,208, 12, 32,253,174, 32,158,183,138,208
200 data 3, 76, 72,178,133, 3,104, 56,229, 4,197, 3
210 data 176, 2,133, 3, 32,247,174,169,178, 32,255,174
220 data 32,158,173, 32,163,182,160, 2,177,100,133, 81
230 data 136,177,100,133, 80,136,177,100,240,211,197, 3
240 data 176, 2,133, 3,165, 5, 24,101, 4,133, 5,144
250 data 2,230, 6,164, 3,136,177, 80,145, 5,192, 0
260 data 208,247, 76,174,167
270 if s &lt;&gt; 19273 then print "error in datas!!" :end
280 sys 828 : print "ok!"

The following program can serve as an example and test for the new function:

100 DIM A$(10)
110 FOR I = 1 TO 10
120 A$(I) = "TEST STRING"
130 NEXT
140 FOR I = 1 TO 10
150 MID$ (A$(I),I,1) = MID$("1234567890",I,1)
160 NEXT
170 FOR I = 1 TO 10
180 PRINT A$(I)
190 NEXT

<!-- TOC PAGE_110: String transformation example -->

===========================================================
                      PAGE 110 OF 386                       
===========================================================

As a result you get 10 strings, where in the first string the first character has been replaced by a "1", in the second string the second character is a "2" etc.:

1ESTSTRING
T2STSTRING
TE3TSTRING
TES4STRING
TEST5TRING
TESTS6RING
TESTST7ING
TEST STR8NG
TEST STRI9G
TEST STRINO

100

<!-- TOC PAGE_111: Commodore 64 BASIC string functions -->===========================================================
                      PAGE 111 OF 386                       
===========================================================

101

# 4.7 INSTR AND STRING$ FUNCTION

Many other basic calculators have two very useful string functions that the 64 lacks. One function, usually called STRING$, uses a command to create a string of any length with a given ASCII code, the other function, often called INSTR, checks whether one string is contained in another.

With knowledge of the basic interpreter and the string management of the Commodore 64, it is now possible to implement these functions on the 64. As a designation we use the existing command words 'POS' and 'STR$' of the 64, which we prefix with a "!" to distinguish them. mark.

The INSTR function then has the following syntax:

I = !POS(A$,B$,P)

Where A$ is the string you want to search, B$ is the string whose occurrence in A$ you want to check and P is the position from which to search in the string A$. The result is assigned to the variable I and is zero if the searched string was not found. If the second string occurs in the first, I contains the position at which it was found. Specifying the position P is optional; If it is not specified, the search is carried out from the beginning. Instead of variables, you can use expressions anywhere or use the function itself in expressions, e.g. a print list.

Here are some examples for use:

<!-- TOC PAGE_112: BASIC programming examples and functions -->

===========================================================
                      PAGE 112 OF 386                       
===========================================================

PRINT !POS("ABCDEFGHIJK","D")
4

IF !POS(A$, "J") THEN PRINT "FOUND"

A$ = "TEST STRING"
PRINT !POS(A$, "T")
1

X = !POS(A$, "T", 5) : PRINT X
6

The STRING$ function is used as follows:

A$ = !STR$ (L,B)
or
A$ = !STR$ (L,B$)

Here A$ is the string you want to create. L is the length that the generated string should have and B is the ASCII code of the string. If a string is used instead of B, the ASCII code of the first character of this string is used. The following examples demonstrate the application:

PRINT !STR$(20.65)
AAAAAAAAAAAAAAAAAAA

A$ = !STR$(10,"*") : PRINT A$
***

The machine program is stored in the free RAM area and starts at address 51200.

102

<!-- TOC PAGE_113: Assembly code listing snippet -->

===========================================================
                      PAGE 113 OF 386                       
===========================================================

103

100: c800 .opt p1 ; instring function ;

135: c800 *= $c800
140: c800 chkauf = $aefa
150: c800 chkzu = $aef7
160: c800 chkcom = $aefd
170: c800 frmevl = $ad9e
180: c800 chkstr = $ad8f
190: c800 frestr = $b6a3
200: c800 yfac = $b3a2
205: c800 chrget = $73
210: c800 chrgot = chrget+6
220: c800 getbyt = $b79b
226: c800 integer = $b1aa
229: c800 descrpt = $64
230: c800 stradr = $62
231: c800 addr2 = $fb
232: c800 addr1 = $fb+2
233: c800 len1 = 3
234: c800 len2 = 4
235: c800 number = 5
236: c800 start = 6
237: c800 typeflag = 13
238: c800 strcode = $c4
240: c800 illquan = $b248
241: c800 syntax = $af08
242: c800 poscode = $b9
243: c800 vector = $30a
245: c800 temp = len1
248: c800 a9 0b lda #<testin !="" !d="" a9="" b="" c800="" c802="" data="" e="" ldy="" m="" not="" c804="" c807="" data="" e)testin="" e)c="" e)c800="" est="" estn="" f)testin="" g0="" i)testin="" l="" o)="" p0="" q0="" q9="" qt="" t="" testin="" tespin="" tststin="" tststin:="" tststin:="" tstsin="" tststin:="" tststin:="" tse="" tse:="" tse:="" tse:="" tse:="" tse:="" tse:="" tse:="" tse:="" tse:="" tse:="" tse:="" tse:="" tse:="" tse:="" tse:="" tse:="" tse:="" tse:="" tse:="" tse:="" tse:

<!-- TOC PAGE_114: Assembly code listing -->===========================================================
                      PAGE 114 OF 386                       
===========================================================

104

250: c80d 85 0d sta type flag
250: c80f 20 73 00 jsr chrget
251: c812 c9 21 cmp #"!"
251: c814 f0 06 beq test2
251: c816 20 79 00 jsr chrgot
251: c819 4c 8d ae jmp $ae8d
252: c81c 20 73 00 test2 jsr chrget
252: c81f c9 b9 cmp #poscode
252: c821 f0 0a beq instr
252: c823 c9 c4 cmp #strcode
252: c825 d0 03 bne *+ 5
253: c827 4c b1 c8 jmp string
253: c82a 4c 08 af jmp syntax
300: c82d 20 73 00 instr jsr chrget
300: c830 20 fa ae jsr chkauf ; clip on
310: c833 20 9e ad jsr frmevl ; get expression
320: c836 20 8f ad jsr chkstr ; test string
330: c839 a5 64 lda descrpt
330: c83b 48 pha ; string address on stack
340: c83c a5 65 lda descrpt+1
340: c83e 48 pha
350: c83f 20 fd ae jsr chkcom ; comma
360: c842 20 9e ad jsr frmevl ; second string
380: c845 20 a3 b6 jsr frestr
390: c848 f0 64 beq ill ; length = 0
400: c84a 85 04 sta len2
410: c84c 86 fb stx addr2
420: c84e 84 fc sty addr2+1
430: c850 68 pla
430: c851 a8 tay
440: c852 68 pla ; first string address
450: c853 20 aa b6 jsr frestr+7
460: c856 f0 56 beq ill
470: c858 85 03 sta len1
480: c85a 86 fd stx addr1
490: c85c 84 fe sty addr1+1

<!-- TOC PAGE_115: Assembly code listing -->

===========================================================
                      PAGE 115 OF 386                       
===========================================================

105

500: c85e a2 00
510: c860 20 79 00
520: c863 c9 2c
530: c865 d0 07
540: c867 20 9b b7
550: c86a 8a
560: c86b f0 41
570: c86d approx
580: c86e 86 06 11
590: c870 20 f7 ae
600: c873 a5 03
610:c875 38
620: c876 e5 04
630:c878 90 28
640: c87a 69 00
650: c87c 85 05
660: c87e a5 06
660:c880 18
670: c881 65 fd
670: c883 85 fd
680:c885 90 02
690: c887 e6 fe
700: c889 a0 00 12
710: c88b b1 fb 13
720: c88d d1 fd
730: c88f d0 0b
740: c891 c8
740: c892 c4 04
750: c894 90 f5
760: c896 a4 06
770: c898 c8
780: c899 4c a2 b3 14
790: c89c e6 06 15
800: c89e c6 05
810: c8a0 d0 04
820: c8a2 a0 00 end

ldx #0 ; default for 3rd parameter
jsr chrgot
cmp #","
bne 11
jsr getbyt
txa ; starting position
beq ill
dex
stx start ; starting position in the string
jsr chkzu
lda len1
sec ; len2 &gt; len1
sbc len2
bcc end ; result 0?
adc #0
sta number ; of the shifts
lda start
clc ; address 1 plus start position
adc addr1
sta addr1
bcc *+4
inc addr1+1
ldy #0
lda (adr2),y
cmp (adr1),y ; compare characters
bne 15 ; search from the next position
iny
cpy len2 ; Have you already tested all characters in string2?
bcc 13
ldy start
iny
jmp yfac ; result
inc start
dec number
bne 16 ; not finished yet?
ldy #0 ; not found, null

<!-- TOC PAGE_116: Assembly code listing -->

===========================================================
                      PAGE 116 OF 386                       
===========================================================

106

830: c8a4 f0 f3 beq 14
840: c8a6 e6 fd 16 inc addr1
850: c8a8 d0 df bne 12 ; increase string2 address
860: c8aa e6 fe inc addr1+1
870: c8ac d0 db bne 12
880: c8ae 4c 48 b2 ill jmp illquan

;

; string$ function

;

900: c8b1 20 73 00 string jsr chrget
900: c8b4 20 fa ae jsr chkauf ; clip on
910: c8b7 20 9e b7 jsr getbyt+3
920: c8ba 8a txa
920: c8bb 48 pha ; remember length
930: c8bc 20 fd ae jsr chkcom
940: c8bf 20 9e ad jsr frmevl
950: c8c2 24 0d bit type flag
960: c8c4 30 0c bmi str ; string
970: c8c6 20 aa b1 jsr integer
980: c8c9 a5 64 lda descrpt ; highbyte
990: c8cb d0 e1 bne ill ; &gt; 255
1000: c8cd a5 65 lda descrpt+1 ; low byte, length
1010: c8cf 4c db c8 jmp str2
1020: c8d2 20 82 b7 str jsr $b782 ; setstr, typeflag in numeric
1030: c8d5 f0 d7 beq ill ; length zero
1040: c8d7 a0 00 ldy #0
1050: c8d9 b1 22 lda ($22),y ; first character
1060: c8db 85 03 str2 sta temp
1070: c8dd 68 pla ; length
1080: c8de 20 7d b4 jsr $b47d ; Frestr
1090: c8e1 a8 tay
1100: c8e2 f0 07 beq str3
1110: c8e4 a5 03 lda temp
1120: c8e6 88 loop dey
1120: c8e7 91 62 sta (stradr),y ; create string
1130: c8e9 d0 fb bne loop

<!-- TOC PAGE_117: BASIC machine code loader program -->===========================================================
                      PAGE 117 OF 386                       
===========================================================

1140: c8eb 20 ca b4 str3 jsr $b4ca ; put string in descriptor stack
1150: c8ee 4c f7 ae jmp chkzu

Here again for 'non-machine programmers' is a loading program in BASIC, which also takes care of the initialization.

100 for i = 51200 to 51440
110 read x : poke i,x : s=s+x : next
120 data 169, 11, 160, 200, 141, 10, 3, 140, 11, 3, 96, 169
130 data 0.133, 13, 32.115, 0.201, 33.240, 6, 32.121
140 data 0, 76, 141, 174, 32, 115, 0, 201, 185, 240, 10, 201
150 data 196,208, 3, 76,177,200, 76, 8,175, 32,115, 0
160 data 32,250,174, 32,158,173, 32,143,173,165,100, 72
170 data 165,101, 72, 32,253,174, 32,158,173, 32,163,182
180 data 240,100,133, 4,134,251,132,252,104,168,104, 32
190 data 170,182,240, 86,133, 3,134,253,132,254,162, 0
200 data 32,121, 0.201, 44,208, 7, 32,155,183,138,240
210 data 65,202,134, 6, 32,247,174,165, 3, 56,229, 4
220 data 144, 40,105, 0.133, 5,165, 6, 24,101,253,133
230 data 253,144, 2,230,254,160, 0,177,251,209,253,208
240 data 11,200,196, 4,144,245,164, 6,200, 76,162,179
250 data 230, 6,198, 5,208, 4,160, 0,240,243,230,253
260 data 208,223,230,254,208,219, 76, 72,178, 32,115, 0
270 data 32,250,174, 32,158,183,138, 72, 32,253,174, 32
280 data 158,173, 36, 13, 48, 12, 32,170,177,165,100,208
290 data 225,165,101, 76,219,200, 32,130,183,240,215,160
300 data 0.177, 34.133, 3.104, 32,125,180,168,240, 7
310 data 165, 3,136,145, 98,208,251, 32,202,180, 76,247
320 data 174
330 if s &lt;&gt; 30119 then print "error in datas!!" :end
340 sys 51200 : print "ok!"

107

<!-- TOC PAGE_118: Commodore 64 auto-numbering guide -->

===========================================================
                      PAGE 118 OF 386                       
===========================================================

108

#4.8 AUTOMATIC LINE NUMBERING

In this section we would like to introduce you to a useful command for your Commodore 64 that can make entering programs much easier. The 'AUTO' command automatically specifies the number of the next line after each program line that you have entered. You can determine the increment yourself, i.e. the number by which the current line number is increased. Using the new command is very simple:

If you want to switch on automatic line numbering, enter the following command:

SYS 828, start number, increment

e.g. SYS 828, 100, 10

The increment can take values up to 255. After entering the SYS command, the start number is output and the cursor is behind the line number. You can now enter the program line directly and accept it with RETURN. The next line number is now automatically specified, in our example 110.

100 INPUT "INPUT"; A$

110

To exit AUTO mode, simply press RETURN without any further input. If you want to enter additional program lines later, just enter

SYS 828

<!-- TOC PAGE_119: BASIC machine program listing -->===========================================================
                      PAGE 119 OF 386                       
===========================================================

without further information. It will then automatically continue with the next line number at which it was previously aborted. Of course, you can change the start value and increment at any time by specifying these values ​​in the SYS command.

What follows is the listing of the machine program that is stored in the cassette buffer and then a loading program in BASIC.

|  150: | 033C |  | * = 828 ; Cassette buffer |   |
| --- | --- | --- | --- | --- |
|  152: | 033C | LO | = $14 |   |
|  154: | 033C | HI | = LO+1 |   |
|  156: | 033C | FAC | = $62 ; Floating point battery |   |
|  158: | 033C | CR | = 13 ; carriage return |   |
|  160: | 033C | LINE | = 251 ; line |   |
|  162: | 033C | INCR | = LINE +2 ; increment |   |
|  164: | 033C | INTFLOAT | = $BC49 ; Integer to floating point |   |
|  166: | 033C | FLOATASCI= | $BDDD ; Floating point to ASCII |   |
|  170: | 033C | VECTOR | = $302 ; LINE ENTRY |   |
|  172: | 033C | INPUT | = $FFCF |   |
|  174: | 033C | PRINT | = $FFD2 |   |
|  176: | 033C | BUFFER1 | = $101 |   |
|  178: | 033C | BUFFER2 | = $200 |   |
|  180: | 033C | MAINLOOP | = $A486 |   |
|  182: | 033C | GOON | = $A569 |   |
|  183: | 033C | CONTINUE | = $A576 |   |
|  184: | 033C | CHRGOT | = $79 |   |
|  186: | 033C | OLDVEC | = $A483 |   |
|  187: | 033C | GETPAR | = $B7EB |   |
|  189: | 033C | CHKCOM | = $AEFD |   |
|  190: | 033C 20 79 00 |  | JSR CHRGOT ; more characters? |   |
|  190: | 033F FO 10 |  | BEQ LO ; no |   |

<!-- TOC PAGE_120: Assembly code listing -->

===========================================================
                      PAGE 120 OF 386                       
===========================================================

110

200: 0341 20 FD AE JSR CHKCOM ; Comma?
200: 0344 20 EB B7 JSR GETPAR ; Get parameters
210: 0347 86 FD STX INCR
220: 0349 A5 14 LDA LO ; and save
220: 034B 85 FB STA LINE
230: 034D A5 15 LDA HI
230: 034F 85 FC STA LINE+1
240:0351 A9 5C LO LDA #&lt; CAR
240: 0353 8D 02 03 STA VECTOR ; Set input vector
250:0356 A9 03 LDA #&gt; CAR
250: 0358 8D 03 03 STA VECTOR+1
260:035B 60 RTS

300: 035C 20 62 03 AUTO JSR AUTONUM
310:035F4C86A4 JMP MAINLOOP

330: 0362 A5 FB AUTONUM LDA LINE
330: 0364 A6 FC LDX LINE+1
340: 0366 85 63 STA FAC+1 ; Line number
340: 0368 86 62 STX FAC
340: 036A A2 90LDX #$90
340:036C 38 SEC
350: 036D 20 49 BC JSR INTFLOAT; after floating point
360: 0370 20 DD BD JSR FLOATASCI ; to ASCII
370: 0373 A2 00 LDX #0
380: 0375 BD 01 01 L1 LDA BUFFER1,X ; Get digits
390: 0378 F0 09 BEQ L2
400: 037A 9D 00 02 STA BUFFER2,X ; in BASIC buffer
400: 037D 20 D2 FF JSR PRINT ; and spend
410:0380 E8 INX
410: 0381 D0 F2 BNE L1
420: 0383 A5 FB L2 LDA LINE ; Line number
420: 0385 18 CLC ; increase
420: 0386 65 FD ADC INCR

<!-- TOC PAGE_121: Assembly code listing -->

===========================================================
                      PAGE 121 OF 386                       
===========================================================

420: 0388 85 FB STA LINE
420: 038A 90 02 BCC L3
420: 038C E6 FC INC LINE+1
425: 038E A9 20 L3 LDA #" " ; Output spaces
425:0390 20 D2 FF JSR PRINT
425: 0393 20 CF FF JSR INPUT
430: 0396 C9 OD CMP #CR ; empty input
440: 0398 F0 03 BEQ L4 ; yes
450: 039A 4C 69 A5 JMP GOON ; carry on
460: 039D A5 FB L4 LDA LINE
460: 039F E5 FD SBC INCR ; Line number for next
460: 03A1 85 FB STA LINE ; Degrade access
470: 03A3 BO 02 BCS L5
470: 03A5 C6 FC DEC LINE +1
480:03A7 A9 83 L5 LDA #&lt; OLDVEC
480:03A9 A0 A4 LDY #&gt; OLDVEC
490: 03AB 8D 02 03 STA VECTOR ; old vector
490: 03AE 8C 03 03 STY VECTOR+1 ;restore
500: 03B1 4C 76 A5 JMP CONTINUE

100 FOR I = 828 TO 947
110 READ X : POKE I,X : S=S+X : NEXT
120 DATA 32,121, 0.240, 16, 32,253,174, 32,235,183,134
130 DATA 253,165, 20,133,251,165, 21,133,252,169, 92,141
140 DATA 2, 3,169, 3,141, 3, 3, 96, 32, 98, 3, 76
150 DATA 134,164,165,251,166,252,133, 99,134, 98,162,144
160 DATA 56, 32, 73,188, 32,221,189,162, 0.189, 1, 1
170 DATA 240, 9,157, 0, 2, 32,210,255,232,208,242,165
180 DATA 251, 24,101,253,133,251,144, 2,230,252,169, 32
190 DATA 32,210,255, 32,207,255,201, 13,240, 3, 76,105
200 DATA 165,165,251,229,253,133,251,176, 2,198,252,169
210 DATA 131,160,164,141, 2, 3,140, 3, 3, 76,118,165
220 IF S &lt;&gt; 15495 THEN PRINT "ERROR IN DATAS!!" :END
230 PRINT "OK"

<!-- TOC PAGE_122: DEF FN function documentation -->===========================================================
                      PAGE 122 OF 386                       
===========================================================

4.9 DEF FN X(Y) - THE UNKNOWN BEING

Many programmers prefer to enter a few more program lines, often subroutines, instead of this actually convenient function - admittedly, it is usually described imperfectly (sometimes incomprehensibly) in the manuals.

In addition to the aforementioned poor documentation, there must be another reason for this: The function does not seem to be very powerful, at least not at first glance (which unfortunately often decides whether it is usable or unusable), since obviously only one argument can be passed to the function.

In this section we would like to show you how to use this function and show that even quite complex formula structures with several variables can be solved by nesting several DEF FNX(Y) (this is actually possible).

A function definition is structured as follows:

DEF FN name (function variable) = arithmetic expression

e.g.

$$
\text{DEF FN A}(X) = 2*X + B
$$

Our function has the name A and the function variable X. If the function is now called, the value that is passed during the call is used instead of the X. Any existing variables named X and A remain there

112

<!-- TOC PAGE_123: Function definition example document -->

===========================================================
                      PAGE 123 OF 386                       
===========================================================

unchanged. The function variable X only serves as a placeholder for the current value when calling the function. In contrast, B refers to the variable B defined previously. The function variable is also often called a dummy variable. The result of a function must always be numeric; a string expression is not permitted.

To get you in the mood, let's use a simple, often-used example: commercial rounding. As you probably know, the third decimal place of a DM amount is treated in such a way that values ​​less than 5 are rounded down and values ​​greater than 4 are rounded down.

Most programmers implement this rounding directly where it is created in the form

$$
A = \text{INT} (B \times 100 + .5) / 100
$$

through. If this happens often, you can replace this formula

$$
A = FNX(B)
$$

save a lot of space. Specifically, the whole thing looks like this:

$$
\begin{array}{l}
10 \text{ DEF FN K}(B) = \text{INT}(B \times 100 + .5) / 100 \\
\ldots \\
100 A = \text{FNK}(B)
\end{array}
$$

You can now use the command in line 100 as often as necessary instead of the longer formula, whereby variable B should contain the unrounded value.

113

<!-- TOC PAGE_124: Basic price calculation formula -->

===========================================================
                      PAGE 124 OF 386                       
===========================================================

Now an example of nesting functions. Here, the sales price should be determined based on the net purchase price, taking into account the desired trading margin and the VAT rate.

C is the purchase price

H is the trading range in % “from above”

M is the VAT rate in %

10 DEF FN V(C) = (C/(1-H/100)*(1+M/100)

20 DEF FN K(B) = INT (FN V(C)*100+.5)/100

...

100 A = FN K(C)

A contains the sales price after line 100, rounded and including VAT. Of course, functions can be nested even deeper. A maximum of 10-fold nesting is possible. If you try to nest even deeper, you will get an 'OUT OF MEMORY ERROR' because the intermediate results are stored in the stack, which only has a limited size. If subprograms (GOSUB) or loops (FOR-NEXT) that also require the stack are still active during the FN call, only a correspondingly smaller nesting is possible, but this should still be sufficient for practical applications.

114

<!-- TOC PAGE_125: Commodore 64 German error messages -->===========================================================
                      PAGE 125 OF 386                       
===========================================================

4.10 YOUR COMMODORE 64 SPEAKS GERMAN

Does it actually bother you that your Commodore 64 'speaks' English to you? - Then teach him German!

If you start the following program on your 64, your computer will cause all error messages to be displayed in German. The program contains a list of error messages in German. The error messages are numbered from 1 to 29, for example the first error message would be 'too many files'. This table can be found in '64 intern'. We simply replace the error messages in this table with our own German texts. If you have an assembler for the 64 and perhaps want to enter other texts yourself, please note that the end of a text is always marked by a character with bit 7 set. You can do this simply by shifting the last letter of each text. For the 'BASIC-only programmers' we have printed another loading program.

```asm
100: c000 .opt p1
;
; German error messages c64
;
140: c000 errvec = $300 ; vector for error messages
150: c000 erradr = $22 ; pointer to error messages
160: c000 olderr = $a445
;
180: c000 *= $c000
190: c000 a9 0b init lda #<newerr 200:="" c002="" ldy="" a0="" c0}="" #=""

<!-- TOC PAGE_126: 6502 assembly error handler code -->

===========================================================
                      PAGE 126 OF 386                       
===========================================================

116

210: c004 8d 00 03 sta errvec
220: c007 8c 01 03 sty errvec+1
230: c00a 60 rts

250: c00b 8a newerr txa ; error number
260: c00c 10 03 bpl err1
270: c00e 4c 43 c0 jmp ready
280: c011 0a err1 asl a ; times 2
290: c012 aa tax ; as an index
300: c013 bd 48 c0 lda errtab-2,x
310: c016 85 22 sta erradr
320: c018 bd 49 c0 lda errtab-1,x
330: c01b 85 23 sta erradr+1
340: c01d 20 cc ff jsr $ffcc ; clrch
350: c020 a9 00 lda #0
360: c022 85 13 sta $13 ; i/o flag
370: c024 20 d7 aa jsr $aad7 ; new line
380: c027 20 45 ab jsr $ab45 ; "?" output
390: c02a a0 00ldy #0
400: c02c b1 22 loop lda (erradr),y
400: c02e 48 pha
400: c02f 29 7f and #$7f
410: c031 20 47 from jsr $from47
420: c034 c8 iny
420: c035 68 pla
420: c036 10 f4 bpl loop
430: c038 20 7a a6 jsr $a67a ; lock cont
440: c03b a4 3a ldy $3a
440: c03d c8 iny
440: c03e f0 03 beq ready
450: c040 20 c2 bd jsr $bdc2 ; in line number
460: c043 a9 bb ready lda #&lt; finished
470: c045 a0 c2 ldy #&gt; finished
480: c047 20 78 a4 jsr $a478 ; as usual

<!-- TOC PAGE_127: Error message reference list -->

===========================================================
                      PAGE 127 OF 386                       
===========================================================

490: c04a 86 c0 96 errtab .word f1,f2,f3,f4,f5,f6,f7,f8
500: c05a 13 c1 2b .word f9,f10,f11,f12,f13,f14,f15
510: c068 89 c1 9f .word f16,f17,f18,f19,f20,f21,f22
520: c076 15 c2 29 .word f23,f24,f25,f26,f27,f28,f29,f30

540: c086 5a 55 20 f1 .asc "too many files"
550: c096 44 41 54 f2 .asc "file open"
560: c0a1 44 41 54 f3 .asc "file not open"
570: c0b2 44 41 54 f4 .asc "file not found"
580: c0c6 47 45 52 f5 .asc "device not presentN"
590: c0dc 4b 45 49 f6 .asc "no input file"
600: c0ee 4b 45 49 f7 .asc "no output file"
610: c100 46 45 48 f8 .asc "missing filename"
620: c113 55 4e 47 f9 .asc "invalid device number"
630: c12b 27 4e 45 f10 .asc "'next' without 'for"
640: c13b a7 .byt " ' +$80
650: c13c 53 59 4e f11 .asc "syntax error"
660: c149 27 52 45 f12 .asc "'return' without 'gosub"
670: c15d a7 .byt " ' +$80
680: c15e 5a 55 20 f13 .asc "too few 'datas"
690: c16d a7 .byt " ' +$80
700: c16e 55 4e 5a f14 .asc "illegal value"
710: c180 55 45 42 f15 .asc "overflow"
720: c189 5a 55 20 f16 .asc "not enough storage space"
730: c19f 46 45 48 f17 .asc "missing line"
740: c1ad 55 4e 47 f18 .asc "invalid indeX"
750: c1be 46 45 4c f19 .asc "field already dimensioned"
760: c1d8 44 49 56 f20 .asc "division by zeroL"
770: c1eb 44 49 52 f21 .asc "direct mode forbidden"
780: c200 46 41 4c f22 .asc "wrong variable type"
790: c215 5a 45 49 f23 .asc "string too long"
800: c229 46 45 48 f24 .asc "incorrect data from fileI"
810: c244 53 54 52 f25 .asc "string expression too complicated"
820: c261 46 4f 52 f26 .asc "not possible to continue"

117

<!-- TOC PAGE_128: Error message code listing -->===========================================================
                      PAGE 128 OF 386                       
===========================================================

830: c27b 4e 49 43 f27 .asc "undefined function"

840: c294 4b 45 49 f28 .asc "no match"

850: c2aa 4c 41 44 f29 .asc "loading error"

860: c2b4 41 42 42 f30 .asc "abort"

870: c2bb 0d ready .byt 13 ; crlf

880: c2bc 46 45 52 .asc "done."

890: c2c3 0d 00 .byt 13.0

100 for i = 49152 to 49860

110 read x : poke i,x : s=s+x : next

120 data 169, 11, 160, 192, 141, 0, 3, 140, 1, 3, 96, 138

130 data 16, 3, 76, 67, 192, 10, 170, 189, 72, 192, 133, 34

140 data 189, 73, 192, 133, 35, 32, 204, 255, 169, 0, 133, 19

150 data 32, 215, 170, 32, 69, 171, 160, 0, 177, 34, 72, 41

160 data 127, 32, 71, 171, 200, 104, 16, 244, 32, 122, 166, 164

170 data 58, 200, 240, 3, 32, 194, 189, 169, 187, 160, 194, 32

180 data 120, 164, 134, 192, 150, 192, 161, 192, 178, 192, 198, 192

190 data 220, 192, 238, 192, 0, 193, 19, 193, 43, 193, 60, 193

200 data 73, 193, 94, 193, 110, 193, 128, 193, 137, 193, 159, 193

210 data 173, 193, 190, 193, 216, 193, 235, 193, 0, 194, 21, 194

220 data 41, 194, 68, 194, 97, 194, 123, 194, 148, 194, 170, 194

230 data 180, 194, 90, 85, 32, 86, 73, 69, 76, 69, 32, 68

240 data 65, 84, 69, 73, 69, 206, 68, 65, 84, 69, 73, 32

250 data 79, 70, 70, 69, 206, 68, 65, 84, 69, 73, 32, 78

260 data 73, 67, 72, 84, 32, 79, 70, 70, 69, 206, 68, 65

270 data 84, 69, 73, 32, 78, 73, 67, 72, 84, 32, 71, 69

280 data 70, 85, 78, 68, 69, 206, 71, 69, 82, 65, 69, 84

290 data 32, 78, 73, 67, 72, 84, 32, 86, 79, 82, 72, 65

300 data 78, 68, 69, 206, 75, 69, 73, 78, 69, 32, 69, 73

310 data 78, 71, 65, 66, 69, 68, 65, 84, 69, 201, 75, 69

320 data 73, 78, 69, 32, 65, 85, 83, 71, 65, 66, 69, 68

330 data 65, 84, 69, 201, 70, 69, 72, 76, 69, 78, 68, 69

340 data 82, 32, 68, 65, 84, 69, 73, 78, 65, 77, 197, 85

118

<!-- TOC PAGE_129: Encoded text data document -->

===========================================================
                      PAGE 129 OF 386                       
===========================================================

350 data 78, 71, 85, 69, 76, 84, 73, 71, 69, 32, 71, 69
360 data 82, 65, 69, 84, 69, 78, 85, 77, 77, 69,210, 39
370 data 78, 69, 88, 84, 39, 32, 79, 72, 78, 69, 32, 39
380 data 70, 79, 82,167, 83, 89, 78, 84, 65, 88, 32, 70
390 data 69, 72, 76, 69,210, 39, 82, 69, 84, 85, 82, 78
400 data 39, 32, 79, 72, 78, 69, 32, 39, 71, 79, 83, 85
410 data 66,167, 90, 85, 32, 87, 69, 78, 73, 71, 32, 39
420 data 68, 65, 84, 65, 83,167, 85, 78, 90, 85, 76, 65
430 data 69, 83, 83, 73, 71, 69, 82, 32, 87, 69, 82,212
440 data 85, 69, 66, 69, 82, 76, 65, 85,198, 90, 85, 32
450 data 87, 69, 78, 73, 71, 32, 83, 80, 69, 73, 67, 72
460 data 69, 82, 80, 76, 65, 84,218, 70, 69, 72, 76, 69
470 data 78, 68, 69, 32, 90, 69, 73, 76,197, 85, 78, 71
480 data 85, 69, 76, 84, 73, 71, 69, 82, 32, 73, 78, 68
490 data 69,216, 70, 69, 76, 68, 32, 66, 69, 82, 69, 73
500 data 84, 83, 32, 68, 73, 77, 69, 78, 83, 73, 79, 78
510 data 73, 69, 82,212, 68, 73, 86, 73, 83, 73, 79, 78
520 data 32, 68, 85, 82, 67, 72, 32, 78, 85, 76,204, 68
530 data 73, 82, 69, 75, 84, 45, 77, 79, 68, 85, 83, 32
540 data 86, 69, 82, 66, 79, 84, 69,206, 70, 65, 76, 83
550 data 67, 72, 69, 82, 32, 86, 65, 82, 73, 65, 66, 76
560 data 69, 78, 84, 89,208, 90, 69, 73, 67, 72, 69, 78
570 data 75, 69, 84, 84, 69, 32, 90, 85, 32, 76, 65, 78
580 data 199, 70, 69, 72, 76, 69, 82, 72, 65, 70, 84, 69
590 data 32, 68, 65, 84, 69, 78, 32, 65, 85, 83, 32, 68
600 data 65, 84, 69,201, 83, 84, 82, 73, 78, 71, 65, 85
610 data 83, 68, 82, 85, 67, 75, 32, 90, 85, 32, 75, 79
620 data 77, 80, 76, 73, 90, 73, 69, 82,212, 70, 79, 82
630 data 84, 70, 85, 69, 72, 82, 69, 78, 32, 78, 73, 67
640 data 72, 84, 32, 77, 79, 69, 71, 76, 73, 67,200, 78
650 data 73, 67, 72, 84, 32, 68, 69, 70, 73, 78, 73, 69
660 data 82, 84, 69, 32, 70, 85, 78, 75, 84, 73, 79,206
670 data 75, 69, 73, 78, 69, 32, 85, 69, 66, 69, 82, 69
680 data 73, 78, 83, 84, 73, 77, 77, 85, 78,199, 76, 65

119

<!-- TOC PAGE_130: Basic data validation script -->

===========================================================
                      PAGE 130 OF 386                       
===========================================================

690 data 68, 69, 70, 69, 72, 76, 69,210, 65, 66, 66, 82
700 data 85, 67,200, 13, 70, 69, 82, 84, 73, 71, 46, 13
710 data 0
720 if s &lt;&gt; 62278 then print "error in datas!!" :end
730 sys 49152 : print "ok!"

120

<!-- TOC PAGE_131: Commodore 64 BASIC hardcopy routine -->===========================================================
                      PAGE 131 OF 386                       
===========================================================

121

# 4.11 BASIC HARDCOPY ROUTINE AND ITS APPLICATION

Have you often tried to print the contents of the screen on your printer? There are a number of different machine programs that do this job. But this little problem is also easy to solve from BASIC.

So that you understand the structure of the program, we first have to look at the structure of the screen memory. Because this needs to be transferred to the printer.

As you probably already know, you have 1000 characters available on the screen. The 1000 characters are made up of 40 characters on 25 lines. Of course, these 1000 characters are not only on the screen, but also in the RAM of the Commodore 64. The area in which the individual characters are located is in the RAM of the Commodore 64 from 1024 to 2023. In order to put all the information that appears on the screen on paper, you have to read out character by character from this memory area using the PEEK function and then print out the value obtained using the CHR$ function. However, you must also note that you cannot print out values ​​in the range from 0 to 31 inclusive, as there are so-called control characters in this ASCII range, which cause strange output.

But there is something else to consider. As we just saw, one line on the screen consists of 40 characters. However, a print line usually consists of 80 characters. If you are familiar with programming in BASIC, you know that if you want to print several characters in a row on a line (screen or printer), you can start each PRINT command with a ";" have to complete. With our HARDCOPY routine you have to make sure that you first print 40 characters in a row (i.e. a whole line) and then send a carriage return that takes you to the next line

<!-- TOC PAGE_132: BASIC printer output program code -->

===========================================================
                      PAGE 132 OF 386                       
===========================================================

come. To program this process you must use two nested loops. The finished program then looks like this:

50000 OPEN 4.4: OPEN REM PRINTER CHANNEL FOR LARGE/GRAPHICS
50010 FOR I=1024 TO 1984 STEP 40: REM 25 LINES
50015 BZ$="": REM DELETE ENTIRE LINE
50020 FOR J=0 TO 39: REM 40 CHARACTERS
50030 Z=PEEK(I+J): READ REM CHARACTERS
50040 IF Z&lt;32 THEN Z=Z+64: REM CONVERT FROM CAPITAL LETTERS
50050 BZ$=BZ$+CHR$(Z): FORM REM TOTAL LINE
50060 NEXT J: REM NEXT CHARACTER
50070 PRINT BZ$: REM PRINT ENTIRE LINE
50080 NEXT I: REM NEXT LINE
50090 RETURN: REM BACK TO THE MAIN PROGRAM

As you'll probably notice, we've taken a slightly different approach to this program than discussed above. If you have ever seen a HARDCOPY routine in action, you may have noticed that a certain amount of time often elapses before a line is printed before it is output to the printer. Why this??? Almost every printer has a more or less large so-called buffer. Characters from the computer are transferred into this buffer until the buffer is filled. Only then will the buffer be printed out. The advantage of this method is that printing is completed more quickly than if character by character were printed directly. For a similar reason, we first fill a TEXT-STRING (BZ$) before printing it out. This is faster than if we print each character individually.

A special feature of this program is the conversion of capital letters (line 50040). As you may know, the capital letters in screen memory start again with the code "1". But since, for example, "A" does not have the code 1 but 65, all numbers are &lt; 32 adds the number 64.

122

<!-- TOC PAGE_133: CBM64 clock program description -->===========================================================
                      PAGE 133 OF 386                       
===========================================================

4.12 THE BERLIN KU' DAMM CLOCK ON THE CBM64

Many an unprepared stroller on the Kurfürstendamm in Berlin may have stopped and shook their head at a frame standing in the middle of the green strip with red and yellow lamps flashing.

At first glance, what is happening there is not unlike a light organ, and even at second glance no one will easily realize that the whole thing represents a normal clock that shows the time in a somewhat unusual way.

Even the initiated find it difficult to determine the correct time straight away.

On the page behind the program listing you will find a drawing of the clock with an explanation of the individual fields.

We didn't want to miss the exciting opportunity to familiarize you a little with the capabilities of the CBM64 in this fun way and have developed a program that reproduces this clock on the screen of your computer.

Of course, the display only really comes into its own on a color television.

In this program we work, how could it be otherwise, with the real-time clock and with sprites, and of course also with the normal symbol graphics.

The real-time clock in particular has its pitfalls when it comes to programmatic handling, which is not least due to the 12-hour counting method of the clock.

We will therefore dismantle the program step by step to enable you to apply some parts to your own programs.

123

<!-- TOC PAGE_134: Program variable documentation -->

===========================================================
                      PAGE 134 OF 386                       
===========================================================

Let's start with a description of the variables used:

A$ Time when entered
AP pointer to the arrays for symbol graphics
C Base address of the real time clock
V Base address of the video controller
S1 Address of the dot pattern for sprite 0
S3 Address of the dot pattern for sprite 1
F1 =0 first half of a second
=1 second half of a second
F2 =1 clock reset
FL =0 in the morning
=1 in the afternoon
H number of hours
M number of minutes
S number of seconds
T tenths of a second
H$ String format of H
M$ String format of M
S$ String format of S
ME$(x) symbol graphic for minute ones
MZ$(x) symbol graphic for minute fives
SE$(x) symbol graphic for hour units
SZ$(x) Symbol graphic for hourly tens

Below you will find explanations of the individual program steps:

5-10 The variables are initialized.
15 The border color is set to black and the sprites are turned off, which is required when you stop and restart the program. Otherwise the sprites would get in the way when entering the time.

124

<!-- TOC PAGE_135: Real-time clock configuration guide -->

===========================================================
                      PAGE 135 OF 386                       
===========================================================

30 The most significant bit of this register must be =0 to set the time.

35 To indicate that the real-time clock is supplied with a clock of 50Hz, the most significant bit of this register must be =1.

The clock frequency is taken from the mains voltage, which in most European countries is 50Hz.

In the USA, however, this bit would have to be =0, since the network frequency there is 60Hz.

40-50 The time is entered via the keyboard.

60-80 The input string is broken down into its numerical components.

90-100 Since the clock only has a 12-hour cycle, the AM/PM flag (bit 7 in the hour register) must be set according to the input.

AM/PM is the abbreviation of the Latin expressions 'ante/post meridiem', which in German simply means before/afternoon. In many countries this is how time is preferred.

110-160 The individual values ​​are broken down into units and tens and fed to the corresponding registers. Please note that the clock registers work in BCD (Binary Coded Decimal) format, i.e. each nibble can only have a maximum value of 9.

161-164 Sprite data for the filled circle.

165-167 Sprite data for the circle border.

168-169 The sprite data is brought into memory.

170-171 The sprite pointers are set, the sprites are switched on and set to double size, the sprites are positioned and their color is determined.

179-196 The frames for the rectangular fields are created.

125

<!-- TOC PAGE_136: Program listing with timing logic -->===========================================================
                      PAGE 136 OF 386                       
===========================================================

198-224 Here the arrays are filled with values and colors unique for each minute and hour. Although this procedure requires more memory than filling the fields calculatedly, it is much faster.

225-229 The syringe for the filled circle is alternately switched on and off at an interval of half a second.

230-290 The real-time clock is read and the values ​​are converted into a decimal number. Depending on the AM/PM flag (the variable FL is derived from this in line 250), 12 is added to the number of hours read in order to get a 24-hour display.

310-350 The values ​​read from the clock are converted into a printable format and displayed in the lower right corner of the screen.

380-410 The minute and hour patterns stored in the arrays are now created here. Since there is a pattern for every combination, the arrays practically only need to be indexed with the time.

Of course, this process is only necessary every full minute (line 370), but in any case after the clock has been set (line 360).

Below is the program listing.

Please understand that the font quality is slightly lower, as we obviously had to print the list on a printer that can reproduce it because of the many special characters.

126

<!-- TOC PAGE_137: Vintage BASIC clock program code -->

===========================================================
                      PAGE 137 OF 386                       
===========================================================

5 print"#":dimmz$(11)
10 c=56328:v=53248:s1=704:s3=832:f2=1
15 pokev+33.0:pokev+21.0:print"#
30 pokec+7,peek(c+7)and127
35 pokec+6,peek(c+6)or128
40 print "enter time"
50 input"format hhmm";a$
60 h=val(left$(a$,2))
70s=0
80 m=val(right$(a$,2))
90ifh&gt;23then40
95 ifh=12then110
100 ifh&gt;11thenh=h+68
110 pokec+3.16*int(h/10)+h-int(h/10)*10
120ifm&gt;59then40
130 pokec+2.16*int(m/10)+m-int(m/10)*10
140 ifs&gt;59then40
150 pokec+1.16*int(s/10)+s-int(s/10)*10
160 pokec,0
161 data0,0,0,0,126,0,3,255,192,7,255,224,15,255,240,31,255,248,31,255,248
162 data31,255,248,31,255,248,63,255,252,63,255,252,63,255,252,31,255,248
163 data31,255,248,15,255,248,15,255,248,7,255,240,3,255,224,3,255,192
164 data0,255,0,0,0,0
165 data1,255,128,7,129,224,12,0,48,24,0,24,48,0,12,48,0,6,96,0,6,96,0,6
166 data96,0,6,192,0,3,192,0,3,192,0,3,96,0,6,96,0,6,48,0,6,48,0,6
167 data24,0,12,12,0,24,12,0,48,7,0,224,3,255,128
168 fori=s1tos1+62:reada:pokei,a:next
169 fori=s3tos3+62:reada:pokei,a:next
170 poke2040,11:poke2041,13:pokev+32,2:pokev+33,6:pokev+21,3:pokev+23,3
171 pokev+39.7:pokev+40.0:pokev,160:pokev+2,160:pokev+1.59:pokev+3.59:pokev+29.3
179 print"#
180 print"#
181 print"#
182 print"#
183 print"#
184 print"#
185 print"#
186 print"#
187 print"#
188 print"#
189 print"#
190 print"#
191 print"#
192 print"#
193 print"#
194 print"#
195 print"#
196 print"#
198 sz$(0)=" 111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111

127

<!-- TOC PAGE_138: Data processing code snippet -->===========================================================
                      PAGE 138 OF 386                       
===========================================================

|  200 | sz$(2)="BBDDWE | H | H | H | H | H | H | H | H |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
|  201 | sz$(3)="BBDDWE | H | H | H | H | H | H | H | H |
|  202 | sz$(4)="BBDDWE | H | H | H | H | H | H | H | H |
|  203 | se$(0)="BBDDWE | H | H | H | H | H | H | H | H |
|  204 | se$(1)="BBDDWE | H | H | H | H | H | H | H | H |
|  205 | se$(2)="BBDDWE | H | H | H | H | H | H | H | H |
|  206 | se$(3)="BBDDWE | H | H | H | H | H | H | H | H |
|  207 | se$(4)="BBDDWE | H | H | H | H | H | H | H | H |
|  208 | mz$(0)="BBDDWE | H | H | H | H | H | H | H | H |
|  209 | mz$(1)="BBDDWE | H | H | H | H | H | H | H | H |
|  210 | mz$(2)="BBDDWE | H | H | H | H | H | H | H | H |
|  211 | mz$(3)="BBDDWE | H | H | H | H | H | H | H | H |
|  212 | mz$(4)="BBDDWE | H | H | H | H | H | H | H | H |
|  213 | mz$(5)="BBDDWE | H | H | H | H | H | H | H | H |
|  214 | mz$(6)="BBDDWE | H | H | H | H | H | H | H | H |
|  215 | mz$(7)="BBDDWE | H | H | H | H | H | H | H | H |
|  216 | mz$(8)="BBDDWE | H | H | H | H | H | H | H | H |
|  217 | mz$(9)="BBDDWE | H | H | H | H | H | H | H | H |
|  218 | mz$(10)="BBDDWE | H | H | H | H | H | H | H | H |
|  219 | mz$(11)="BBDDWE | H | H | H | H | H | H | H | H |
|  220 | me$(0)="BBDDWE | H | H | H | H | H | H | H | H |
|  221 | me$(1)="BBDDWE | H | H | H | H | H | H | H | H |
|  222 | me$(2)="BBDDWE | H | H | H | H | H | H | H | H |
|  223 | me$(3)="BBDDWE | H | H | H | H | H | H | H | H |
|  224 | me$(4)="BBDDWE | H | H | H | H | H | H | H | H |

225 onf1goto228
226 ifpeek(c)&gt;4thenpokev+39.7:goto225
227 pokev+39,11:f1=1:gosub230:goto310
228 ifpeek(c)&lt;5then228
229 f1=0:goto225
230 h=peek(c+3):m=peek(c+2):s=peek(c+1):t=peek(c)
240 f1=1
250 ifh&gt;32thenh=h-128:f1=0
260 h=int(h/16)*10+h-int(h/16)*16:onf1goto280
265 ifh=12then285
270h=h+12
280 ifh=12thenh=0
285 m=int(m/16)*10+m-int(m/16)*16
290 s=int(s/16)*10+s-int(s/16)*16
300 returns
310 h$=str$(h):if len(h$)=2thenh$="0"+right$(h$,1)
320 m$=str$(m): if len(m$)=2thenm$="0"+right$(m$,1)
330 s$=str$(s): if len(s$)=2thens$="0"+right$(s$,1)
340 print"225
350 printright$(h$,2)":"right$(m$,2)":"right$(s$,2);
360 onf2goto380
370 ifs&lt;&gt;0then225
380 ap=int(h/5):print"225"sz$(ap):printsz$(ap):printsz$(ap)
390 ap=h-int(h/5)*5:print"225"se$(ap):printse$(ap):printse$(ap)
400 ap=int(m/5):print"225"mz$(ap):printmz$(ap):printmz$(ap)
410 ap=m-int(m/5)*5:print"225"me$(ap):printme$(ap):printme$(ap)
420 f2=0:goto225

<!-- TOC PAGE_139: Time tracking document summary -->

===========================================================
                      PAGE 139 OF 386                       
===========================================================

![img-4.jpeg](img-4.jpeg)

HOURS
TIMES 5

HOURS
TIMES 1

MINUTES
TIMES 5

MINUTES
TIMES 1

129

<!-- TOC PAGE_140: Software copy protection analysis -->===========================================================
                      PAGE 140 OF 386                       
===========================================================

4.13 A SMALL COPY PROTECTION

Anyone who has ever written a program knows what they achieved. Hours, even days, weeks or months of effort go into a good program. Who doesn't want to protect themselves to some extent against unauthorized reproduction of their work and their idea? However, this is easier said than done, because there is a community of computer geeks all over the world who have made it their mission to crack every new copy protection, no matter how perfect it is. This has become a real popular sport in some places.

Furthermore, today there are increasingly sophisticated copy programs that make it possible for even the most amateur to copy protected programs, since the existing backup of the program is simply transferred by the copy program. Basically, you have to differentiate between two different types of protection. On the one hand, there is the so-called hardware protection. This is, for example, an electronic component that is plugged into the user port or the joystick port. This “electronic key” then contains an integrated circuit that converts or logically shifts the data to be processed in the program in a very specific form. Since the inner workings of such a "dongle" cannot be seen - it is cast with a plastic mass - it requires a sound knowledge of electronics and some good measuring equipment to get to the bottom of how the data is encrypted. However, this method is completely unsuitable for a private individual because they do not have the necessary equipment to create such hardware backups. But take comfort, because apart from the high manufacturing costs, hardware protection also has the disadvantage that sooner or later it will be outwitted.

130

<!-- TOC PAGE_141: Software protection guide introduction -->

===========================================================
                      PAGE 141 OF 386                       
===========================================================

On the following pages we want to look at the software solution to this problem. It certainly remains to be noted that the following lines are at best an introduction to this topic. If you are interested in this area, please refer to the book "64 TIPS & TRICKS, Volume 2".

Our copy protection consists of two parts. The first part is the preparation, the second then represents the actual protection in a modular form. This module can be easily implemented in new programs, but also in programs that have already been written. A very big advantage of our solution is that there are currently only two copy programs on the relevant market that are able to overcome our hurdle. This means that you are at least somewhat protected against some “casual offenders”.

When attempting the following solution, you should definitely adhere to two guidelines:

Before you test the functionality of the two programs, you should definitely save them first, as there is a relatively high risk that something will go wrong, which will result in all the data entry work being in vain. For all tests and possible later practical use, always only use empty diskettes, as the preparation program changes a diskette block without taking into account whether it may already be occupied by normal data.

Here is the preparation routine:

131

<!-- TOC PAGE_142: BASIC floppy disk formatting code -->===========================================================
                      PAGE 142 OF 386                       
===========================================================

10 REM***
PREPARE 20 REM BLOCK
30 REM***
40 PRINT CHR$(147)
50 PRINT" DO YOU WANT ONE SPECIFIC
BLOCK"
PREPARE 60 PRINTS
(Y/N)"
70 GET A$ :IF A$ &lt;&gt; "J" AND A$ &lt;&gt; "N" THEN GOTO 70
80 IF A$ = "N" THEN TT = 18 : SS = 2 : GOTO 200
90 PRINTS
100 INPUT" TRACK ";TT
110 IF TT &gt; 35 THEN PRINT"DOES NOT EXIST"; CHR$(145); CHR$(145) : GOTO 100
120 PRINTS"
130 SX = 16
140 IF TT &lt; 18 THEN SX = 20
150 IF TT &lt; 25 THEN SX = 18
160 IF TT &lt; 31 THEN SX = 17
170 INPUT " SECTOR ";SS
180 IF SS &gt; SX THEN PRINT"DOES NOT EXIST"; CHR$(145); CHR$(145) : GOTO 170
190 PRINT"
200 OPEN 1,8,15 : OPEN 2,8,2,"#"
210 PRINT#1,"B-P:"2;0
220 INPUT" CODE WORD ";C$
230 IF LEN(C$) &gt; 15 THEN PRINT"TOO LONG"; CHR$(145); CHR$(145) : GOTO 220
240 PRINT#2,C$
250 PRINT#1,"U2:"2;0;TT;SS
260 CLOSE2
270 PRINT#1,"B-F:"0;TT;SS
280 CLOSE1
290 PRINT "DONE!" :END

<!-- TOC PAGE_143: Floppy disk protection guide -->

===========================================================
                      PAGE 143 OF 386                       
===========================================================

What is achieved by this small program?

You can decide whether or not to prepare a specific block on the disk. If you choose "N", please note the values: Track 18, Sector 2. If you prepare another block, you must remember the values ​​you assigned. The program automatically checks whether your entries are possible and then points out any errors. This all happens in lines 10 to 190. In line 200 the command channel and a data channel to the floppy are opened. You will then be asked to enter a “code word”. You definitely have to remember this too. In the program version presented here, the code word must not be longer than 15 characters.

The code word is then written into the data buffer 2, which in turn is then written as a complete block to the specified location on the diskette. Finally, the block that has just been applied is marked as “free” in the BAM of the diskette. This is one of the reasons why this protection function is insurmountable for many copy programs.

However, there is a catch. If you use the address specified by the program, you run the risk of deleting it again if you save more than 24 programs on your prepared diskette. If you have determined the address yourself, then it cannot be predicted whether and when your block will become a normal data block again.

Now let's move on to the second part of our backup package, the so-called block query.

133

<!-- TOC PAGE_144: Basic copy protection demo code -->

===========================================================
                      PAGE 144 OF 386                       
===========================================================

10 REM***
QUERY 20 REM BLOCK BLOCK
30 REM***
40 PRINT"THIS IS A DEMONSTRATION"
50 PRINT "FOR THIS COPY PROTECTION"
60 INPUT "CODE WORD ";C$
70 TT = 18 : SS = 2
80 GOSUB 60000
90 END
60000 OPEN1,8,15 : OPEN2,8,2,"#"
60010 PRINT#1,"U1:"2;0;DD;SS
60020 INPUT#2,A$
60030 CLOSE1 : CLOSE2
60040 IF A$ = C$ THEN RETURN
60050 SYS 64738

This small demonstration program must be saved on the previously prepared diskette, otherwise it will not work. The actual backup function can be found in subprogram lines 60000 to 60050. This means that all basic lines under 60000 are available for your own program. The only thing to remember is that you store your code word in the variable C$ before you start the subprogram. Likewise, when checking whether the correct code word is on the diskette (in line 60040), you should enter the direct code there.

60040 IF A$ = "A code word" THEN RETURN

It should also be noted that the address on the diskette is either stored in the variables TT (for track) and SS (for sector) or that it is entered directly in the block read command in line 60010.

60010 PRINT#1,"U1:"2;0;18;2

<!-- TOC PAGE_145: Software protection instructions manual -->===========================================================
                      PAGE 145 OF 386                       
===========================================================

In line 60050 of the subprogram you can then freely decide what should happen if no agreement was achieved during the check. In our case, a reset of the computer is triggered. This means that the computer is returned to its switched-on state. The program in the computer is then of course lost. You can see that this method offers you unimagined possibilities for securing your intellectual property.

Of course, it is also conceivable that you prepare several blocks on your diskette with one key in the manner described.

To see that our protection really works, you should go here and enter the code word you entered incorrectly.

At this point it must be pointed out that it is relatively easy to remove the entire key query from the program. This can be avoided by compiling your program or using a good list protection for a basic program.

135

<!-- TOC PAGE_146: Chapter 5: FORTH programming guide -->

===========================================================
                      PAGE 146 OF 386                       
===========================================================

CHAPTER 5: THE 64 CAN'T JUST BASIC

## 5.1 PROGRAMMING FORTH

WHAT IS FORTH? This question will probably be asked by anyone who has only ever dealt with programming in BASIC or assembler. Surely some people will say "Why should I use another programming language when my Commodore 64 speaks BASIC excellently?". This objection may be justified at first glance, but at second glance you should consider whether it might not be a good thing if a computer can not only speak one language, but is a true linguistic genius.

If you have already programmed in BASIC for some time, then you will know that every now and then there are things that are difficult or impossible to program. In such cases, large computers offer the option of using other languages. There is FORTRAN for mathematical problem solving, COBOL for commercial purposes, ASSEMBLER for time-critical tasks (i.e. problems that need to be processed quickly, e.g. machine controls), BASIC for general problem solving on microcomputers, and so on. Then there are languages ​​that are intended to teach the newcomer structured programming, such as PASCAL and ELAN. So all languages ​​have their strengths and their weaknesses.

FORTH, which means something like 'The Fourth', belongs to the latest generation of programming languages, as its name suggests, the fourth generation. An attempt was made to implement all the advantages of the well-known, renowned programming languages ​​in FORTH, but without adopting their errors.

FORTH, already in its structure, has some very striking advantages that are particularly advantageous for microcomputers:

<!-- TOC PAGE_147: FORTH programming language overview -->===========================================================
                      PAGE 147 OF 386                       
===========================================================

1.) The computer on which FORTH runs usually only requires a very small amount of RAM. Since FORTH programs don't require a lot of space, you can create large, powerful programs even on a very small computer.

2.) FORTH requires no, or very few, I/O lines. So you don't have to know the inside of your device's hardware in order to program in FORTH. In addition, microcomputers often only have very few I/O lines available anyway.

3.) From the advantage already mentioned under 2, it is clear that FORTH itself would get along without a floppy station. A floppy is of course advantageous in any case.

FORTH consists of five parts:

1.) TABLE OF CONTENTS: The philosophy of FORTH is that the actual vocabulary, i.e. the commands that FORTH understands, is very small. However, it is possible to define your own commands and use them in the programs themselves. This means you can write your own, very powerful language – just the way you need it. As an example:

You want to write a program that is supposed to solve mathematical problems - for example a curve discussion. In this program you will hardly need any parts for text editing, and if you don't want to use graphics, just leave these commands 'outside'. For this reason, you don't need a lot of RAM.

2.) STACK: Actually the most important element in FORTH. The term STACK will already be familiar to anyone who knows a little about machine language programming or who owns an HP calculator. We'll come back to that later.

137

<!-- TOC PAGE_148: Forth programming language documentation -->

===========================================================
                      PAGE 148 OF 386                       
===========================================================

This STACK works according to the LIFO system (Last in - First out, or translated: Last in, first out). All operations, computational, logical and comparative, are processed on this STACK.

3.) INTERPRETER: As already known from the Commodore 64, FORTH also works with an interpreter. This means that you first create the FORTH program with the EDITOR, and then start the program with the appropriate command. Error checking is then carried out during the program run. So you don't have to go through the lengthy process of compiling the program, you can start it straight away. However, this usually means that interpreted programs are slower. With FORTH this time factor is not so big - the interpreter is divided into the TEXT INTERPRETER and the ADDRESS INTERPRETER. The TEXT INTERPRETER checks the WORDS in the table of contents and if the WORD is found, the ADDRESS INTERPRETER is activated. This interpreter then processes the absolute addresses. The result is that this ensures a very quick process.

4.) ASSEMBLER: Every FORTH interpreter contains an assembler, with this assembler you can define WORDS, which can then execute entire machine routines when called. This type of programming is needed to establish a connection to the outside world. So, as you'll probably notice, FORTH here also has a lot of similarity to standard ASSEMBLER programming - it's just as fast, but much easier to learn.

5.) MEMORY: The main memory is of course very important for FORTH. This memory has the special feature that when the individual blocks in the memory, which are always the same length, are changed, the corresponding block on the diskette is also changed at the same time, of course only if a floppy is also switched on.

138

<!-- TOC PAGE_149: Forth vs BASIC comparison guide -->===========================================================
                      PAGE 149 OF 386                       
===========================================================

139

# 5.2 COMPARISON PROGRAM FORTH - BASIC

Of course, the easiest way to get to know FORTH is to see a FORTH program compared to a BASIC program that does the same job.

But before we get to the program, we first have to explain a few terms and techniques.

We have already pointed out in Chapter 5.1 that the STACK plays an important role and that comparisons can be made with the way HP calculators work:

We now calculate $(2 + 3) * (4 + 5)$ on an HP calculator. The key sequence is as follows:

$$
2 \langle \text{ENTER} \rangle = 3 + 4 \langle \text{ENTER} \rangle = 5 + * \text{ (}
$$

This may look confusing at first glance, but if you try to work without the usual '(' ')', you will see that this is the only way to solve the problem. So I take the number '2' and press <enter> to put it on the STACK. Then I press the number '3', this number also has to be put on the STACK, so we push the '2' one place further back. In a picture you could imagine the process like this:

|  STACK: | TOP | - | ↑ |
| --- | --- | --- | --- |
|   |  | - | ↑ |
|   |  | - | ↑ |
|   |  | - | ↑ |
|   |  | - | ↑ |
|   |  | 2 | ↑ |
|   | DOWN | 3 | ↑ |

(The arrows on the right are intended to indicate the direction in which the stack is expanded.)</enter>

<!-- TOC PAGE_150: Stack operation documentation -->

===========================================================
                      PAGE 150 OF 386                       
===========================================================

Then the `+` key is pressed and the addition is carried out. After addition, the STACK looks like this:

```
ABOVE
-
-
-
-
-
-
-
BOTTOM 5
```

When you press the `4` key, the `5` moves up one place and the `4` is below:

```
ABOVE
-
-
-
-
-
5
BOTTOM 4
```

Now the number 5 should be entered. After pressing this key, both the old `5` and `4` move up one position:

```
ABOVE
-
-
-
-
5
4
BOTTOM 5
```

Now the number 4 and the number 5 should be added. So the STACK looks like this afterwards:

140

<!-- TOC PAGE_151: Forth programming tutorial example -->

===========================================================
                      PAGE 151 OF 386                       
===========================================================

141

ABOVE
-
-
-
-
-
5

BOTTOM 9

And the last operation is multiplication:

ABOVE
-
-
-
-
-
-

BOTTOM 45

So now we have the result available. This all looks incredibly complicated and time-consuming, but every calculator and even computer works according to this principle. However, this principle is most clearly developed in the HP calculator. Anyone who has ever worked with such a computer or programmed in assembler will quickly be able to get their head around FORTH - but even those new to programming will have fewer difficulties than they might think, because FORTH is actually a very easy language to learn. The only difficulty with FORTH is that it is so different from the other languages.

Here is a first small FORTH program that explains how the stack works and at the same time shows the definition of a WORD.

This program is about finding the cube value of a number. Since there is no command for this calculation, we first have to define it:

<!-- TOC PAGE_152: Forth programming language tutorial -->===========================================================
                      PAGE 152 OF 386                       
===========================================================

:CUBIK (THIS WORD IS NOW DEFINED)
DUP DUP (COPY THE NUMBER 2* INTO THE STACK)
* * (MULIPLICATES THE STACK 2* WITH ITSELF)

So what does this program mean? First, the ∵ FORTH indicates that a word is now to be defined. If you did not include the colon, FORTH would be included in the message

## CUBIK?

come back, thereby indicating that this word is not yet noted in the table of contents. But we just want to define a word and add it to the table of contents. To do this we need the ∵ FORTH now knows that the definition of a word should follow until it hits a semicolon ∵. After this signal, FORTH reports again with his friendly

## OK

We now know that FORTH has included the word in its table of contents, and from now on we can use it directly or in a program. By the way, the definition of the word is only retained in the computer as long as it remains switched on. In order to be able to use these new words again later, they must of course be saved on floppy. This means you can always reload the extended FORTH from the diskette later.

The DUP command copies the lowest STACK value. Since we don't just want to calculate the square but the cube of a number, we have to copy the stack twice, i.e. a second DUP. With the number 5 the STACK would now look like this:

ABOVE

142

<!-- TOC PAGE_153: FORTH programming tutorial example -->

===========================================================
                      PAGE 153 OF 386                       
===========================================================

143

```markdown
UNITES 5

Now we have to multiply the numbers together. So a total of 2 multiplications are necessary. FORTH uses the normal multiplication character `*.` After we have multiplied the STACK twice, we can end the definition. To do this, as mentioned above, we enter a semicolon. FORTH reports again with its OK (if we have done everything correctly) and we can now start with the calculations. So for example with the 5:

|  YOU TYPE: | FORTH REPORTS: |
| --- | --- |
|  5 CUBIC . | 125 OK |
|  1 CUBIC . | 1 OK |
|  -15 CUBIC . | -3375 OK |

As you can see, it is very easy to define new commands yourself. That is precisely the enormous advantage of FORTH. You never have to carry around a load of useless commands that you don't need at all, saving you a lot of storage space.

Here is a comparison between a FORTH and a BASIC program:

This program calculates the cube numbers between 0 and 10. If you write this program in FORTH, remember that this program uses the word CUBIC. It must therefore be defined beforehand using the program given above.

CUBIC NUMBERS:

<!-- TOC PAGE_154: BASIC programming code example -->

===========================================================
                      PAGE 154 OF 386                       
===========================================================

1.) FORTH

: CUBIC NUMBERS
10 0 (FROM 0 TO 10! LIFO!!)
DO (BEGIN LOOP)
CR I . I CUBIC . (PRINT NUMBER (I) AND CUBIC)
LOOP (END OF LOOP)

CUBIC NUMBERS
0 0
1 1
2 8
3 27
4 64
5,125
6,216
7,343
8,512
9 729 OK

2.) BASIC

10 REM CALCULATE CUBIC NUMBERS
20 MIN=0: MAX=9
30 FOR I=MIN TO MAX: PRINT I,I*I*I
40 NEXT I
50 END

RUN
0 0
1 1
2 8
3 27
4 64
5,125
6,216
7,343
8,512

<!-- TOC PAGE_155: Forth vs BASIC benchmark test -->===========================================================
                      PAGE 155 OF 386                       
===========================================================

9,729

READY.

As you can see, both programs require approximately the same number of program lines. But in memory the whole thing looks different - the FORTH program is a lot smaller. But this space saving is far from everything. Let's do a time comparison (benchmark test) in FORTH and BASIC. What else is better than a simple loop:

1.) FORTH

: TIME TEST
30000 0 ( FROM 0 TO 30000 )
DO (BEGIN LOOP)
( EMPTY LOOP )
LOOP (END OF LOOP)
; (END)

TIME TEST OK

2.) BASIC

10 REM TIME TEST
20 MIN=0: MAX=30000
30 FOR I=MIN TO MAX
40 NEXT I
50 END

RUN
READY.

And now our little race can begin. The result is perhaps quite surprising: it was a race between a rabbit and a hedgehog, only this time the hedgehog wasn't quite as intelligent. Here are the times:

145

<!-- TOC PAGE_156: Commodore 64 FORTH programming guide -->

===========================================================
                      PAGE 156 OF 386                       
===========================================================

LANGUAGE: TIME:
---
BASIC approx. 40 seconds.
FORTH approx. 4 seconds.

And this should not be forgotten: Both time tests were carried out with one and the same computer:

# YOUR COMMODORE 64!!!

This result alone should make some people perhaps consider checking out FORTH. Programming is incredibly easy, the time saved is significant and learning something new is always fun. Or?

If you are now interested in the Commodore FORTH, here is some special information:

With a few small word changes, FORTH 64 can be made into a FORTH-79 standard package - the standard on which most FORTH programs are written.

FORTH 64 uses 3 disk buffers, each 1024 bytes long, located at address $COOO. In addition, FORTH 64 generates a screen memory of $0400.

FORTH 64 is stored on MODUL and is always ready to hand and start.

FORTH - The language for the professional software developer

It should also be interesting that more and more professional software developers are switching to FORTH. The reason lies in the advantages of FORTH outlined above. It is just as easy and comfortable to use after a short training period

146

<!-- TOC PAGE_157: Forth programming language benefits -->

===========================================================
                      PAGE 157 OF 386                       
===========================================================

still offers the flexibility and computing speed that is so valued in machine programming. Sophisticated program packages have already been developed in FORTH on the Commodore 64. This includes, for example, the CALC RESULT program, a very powerful, universal calculation and planning program.

FORTH has another advantage that software companies particularly value. It is one of the few portable languages, i.e. programs written in FORTH on one computer can be easily implemented on another computer. This means that software investments do not become worthless so quickly, and it no longer takes as long until corresponding programs can be offered for new computers.

We can unreservedly recommend working with the FORTH language to every Commodore 64 programmer.

147

<!-- TOC PAGE_158: Commodore 64 programming languages guide -->===========================================================
                      PAGE 158 OF 386                       
===========================================================

148

# 5.3 OTHER LANGUAGES: PASCAL, LOGO, TURTLE GRAPHICS

Different languages make a computer a perfect computer. There will also be a wide variety of languages ​​available for the Commodore 64 very soon. This possibility is further expanded by the fact that the Commodore 64 is now one of the computers that can process the CP/M operating system (see Chapter 6). And almost all languages ​​that exist for microcomputers can be run under CP/M.

What are the individual languages ​​used for?

## PASCAL

This language is actually intended as a teaching language. It was developed by a Swiss professor (N. WIRTH) and impresses with the possibility of properly structured programming. PASCAL is now used as a regular computer language at many institutes and companies and is taught at various schools and universities.

##LOGO

This language is still quite unknown. It was also developed for computer training. IT'S SO EASY TO LEARN THAT EVEN CHILDREN CAN PROGRAM AFTER A FEW HOURS. This is the motto of this language, and it is true. The individual elements of this language are easy to learn and use.

## TURTLE GRAPHICS

This is actually not one of the known languages. It stands between PILOT and LOGO. As its name suggests, it supports graphics programming. Since the Commodore 64 is known to have excellent graphics properties, this language is perfect for this computer. Here's a small one

<!-- TOC PAGE_159: Turtle Graphics programming example -->

===========================================================
                      PAGE 159 OF 386                       
===========================================================

Example to illustrate the programming of a graphic under TURTLE GRAPHICS:

1 LABEL BOX
2 REMARK SET THE SCREEN COLORS
3 SCREEN COLOR CYAN
4 BORDER COLOR CYAN
5 TURTLE COLOR BLACK
6 REMARK SET THE HI-RES MODE
7 HIRES
8 REMARK MUTE RECORDER
9 PEN UP
10 REMARK SCREEN POSITION TOP-LEFT
11 MOVE TO 0-0
12 REMARK TURN ON THE RECORDER
13 PEN DOWN
14 REMARK SCREEN POSITION BOTTOM-RIGHT
15 MOVE TO 199-319
16 REMARKS QUEUE
17 WAIT 300

With this program you draw a straight line from position 0.0 to position 199.319. The writer behaves as a plotter would. Once PEN DOWN is set, it records every movement - e.g. the movement caused by the MOVE TO command.

As you can see, there are many interesting languages ​​that make the Commodore 64, in every respect, a computer that can compete with larger systems.

149

<!-- TOC PAGE_160: Commodore 64 ADA programming guide -->

===========================================================
                      PAGE 160 OF 386                       
===========================================================

5.4 ADA FOR THE COMMODORE 64

Some time ago a new language was added to the languages your Commodore understands. It's ADA. In contrast to many others, the name of this language is not an abbreviation of the language meaning (e.g. COBOL = Common Business Oriented Language). ADA is the first name of a woman who was involved in the development of computer languages ​​in the 18th century.

ADA, like many other languages ​​promoted by the US Department of Defense, is more relevant today than ever before. It is particularly characterized by its good structure and ease of learning. As is common practice, ADA commands are borrowed from the English language. An ADA program is always modular. Every program consists of a series of problems. With ADA, each problem is broken down into individual fragments, which as a whole then result in the problem solution. Variable names can be freely chosen according to their meaning. The entire program structure is very clear and therefore easy to understand even when troubleshooting. There are no superfluous formal instructions that can easily spoil the fun of the thing, especially for a beginner.

Let's look at a small ADA program and you will see that it is almost self-documenting.

010 with TEXT IO; use TEXT IO;
020 with C 64; use C64;
030 --
040 -- This program calculates this
050 -- Product of two to be entered
060 -- Evaluate and print it out.
070 --
080 procedure CALCULATE is
090 --

150

<!-- TOC PAGE_161: Basic multiplication program code -->===========================================================
                      PAGE 161 OF 386                       
===========================================================

151

```txt
100 -- Set variables
110 --
120 MAND : float :=0
130 MOR : float :=0
140 --
150 RESULT : float :=0
160 --
170 begin
180 --
190 --
200 put ("Enter the multiplicand");
210 get (MAND)
220 --
230 put ("Enter the multiplier");
240 get (MOR)
250 --
260 -- form result
270 --
280 RESULT := MAND * MOR ;
300 --
310 set row(10); set col(10);
320 --
330 -- Show result
340 --
350 put ( MAND ); put("*"); put ( MOR );
360 put ("="); put ( RESULT );
370 --
380 --
390 end CALCULATE
```

There is actually no need for any more explanation about this program.

Of course, program nesting is also possible using several convenient commands. Since you can use different nesting commands, this makes an ADA program really elegant.

<!-- TOC PAGE_162: Chapter 6: CP/M on Commodore 64 -->

===========================================================
                      PAGE 162 OF 386                       
===========================================================

CHAPTER 6: CP/M ON THE COMMODORE 64

## 6.1 THIS IS CP/M

CP/M is the most common operating system used on microcomputers. To this day, it has proven itself to be the standard operating system that is the most sophisticated of its kind. With many new operating systems you often have the problem that many years after the operating system was introduced, not all of the teething problems have been resolved. This problem does not exist with CP/M. So you can completely rely on this operating system.

But what does the Commodore 64 user get out of this operating system? He is used to his DOS and his BASIC 2 - then why another operating system?

This question actually only arises for Commodore 64 users who have never seen anything of the big computer world. There he finds a mountain of software that he had only dreamed of before. Not that the Commodore 64 has little software, on the contrary, but compared to the whole mountain of CP/M software, the Commodore 64 software looks like a small bump in the ground. There will be a lot of Commodore 64 coming onto the market in the near future - from word processing, to file management, commercial software, to games. But the CP/M software already has a lead that can no longer be caught up.

The wide range of CP/M software not only includes various programs for word processing and file management, but also individual software can be found in abundance on the CP/M market.

But not only the user of such software benefits from this offer, the programmer also has many advantages

152

<!-- TOC PAGE_163: CP/M compatibility and limitations -->===========================================================
                      PAGE 163 OF 386                       
===========================================================

this CP/M system. This means he can now write his software for a much larger group of users than he was able to do before. Creating CP/M software is a term that means something to 100,000 computer users; The programmer of Commodore 64 software finds his market only among the Commodore 64 user group. We don't mean to say that this circle isn't very large - but CP/M can be compared to a seal of quality. Many a programmer on an 'exotic' operating system has probably already heard:

AND WHEN WILL THE PROGRAM BE AVAILABLE ON THE CP/M OPERATING SYSTEM?

At this point we should also point out a problem with every CP/M operating system:

CP/M IS NOT THE SAME CP/M!

Unfortunately, most computer manufacturers use their own modified CP/M. This means that, despite apparent compatibility with other computers, it is not possible to exchange programs or transfer data. The CP/M of the Commodore 64 also has its own peculiarities. For example, the IOBYTE of the CP/M operating system is not implemented at all, on the other hand the Commodore 64 can only display 40 characters per screen and the format of the floppy disks is also not compatible with other computers. But we'll get to these problems AND HOW TO FIX THEM later.

You've just seen that CP/M requires some standards:

1.) There must be at least a 48K RAM computer available.
2.) CP/M has free programming memory starting at address $0100
3.) As a rule, most programs require a screen display of 80 characters on 24 (or 25) lines.

153

<!-- TOC PAGE_164: CP/M software compatibility guide -->

===========================================================
                      PAGE 164 OF 386                       
===========================================================

4.) The CP/M software is almost exclusively delivered on large, 8'' floppys.

We would now like to briefly discuss these standards. First of all there is the RAM of 48K. Many microcomputers can now be expanded to this storage capacity. The Commodore 64 already owns you right from the start. And something else is interesting about this computer: As is well known, you can hide the entire ROM (see 64 internally). This means that things can be achieved with this computer, even under CP/M, that are impossible or at least only possible with great difficulty on other computers that also have a specific ROM area.

For example, there are computers whose ROM is in such an unfortunate range for CP/M (e.g. from 0000) that the entire CP/M operating system must be structured differently on this computer. Every programmer who encounters such an operating system and wants to use CP/M routines will have gray hair when programming. Nothing to see of compatibility. Fortunately, the Commodore 64 is structured differently. Here the CP/M is where it belongs, namely from address $0100.

The first problem actually only arises with the representation of characters on the screen. CP/M programs, such as WordStar, the star among the word processing programs, DataStar, the file management program, and other programs, require an 80-character screen to function properly. Unfortunately, the Commodore 64 only has 40 characters. But here too there is the right remedy for the user. More about this in chapter 6.3.

The last problem is the floppy. As already mentioned, most software is offered on 8'' floppys. So the 1541 floppys aren't so lucky - that's what you think

154

<!-- TOC PAGE_165: CP/M operating system components guide -->===========================================================
                      PAGE 165 OF 386                       
===========================================================

at least. But it is much more the case that almost all microcomputer manufacturers are increasingly using 5 1/4'' floppys. So every microcomputer actually has to transfer data from 8'' to 5 1/4''. You can find out how this happens in Chapter 6.3

## What does CP/M consist of?

CP/M is an operating system composed of several parts. To be more precise, there are 4 parts, which we now want to go into in more detail.

1.) BIOS (Basic Input/Output System): As its name suggests, the BIOS is responsible for communication with the outside world. For example, if information is to be sent to the printer, to the terminal (screen) or to the floppy. To tell the operating system what to do, the BIOS has a few function calls. We will show you the entire table at the end of these 4 parts.

2.) BDOS (Basic Disk Operating System): This part controls the floppys - their content, the management of the table of contents and the actual read and write commands. These processes are also all controlled via individual function calls. We'll get to that in a moment.

3.) CCP (Console Command Processor): Somehow the operating system has to be told what you actually want. This message is usually made via the keyboard of the Commodore 64. CCP forwards your commands to the CP/M system - you can also imagine it as a telephone exchange where all the connections between the individual participants, in our case the CP/M parts, are made.

4.) TPA (Transient Program Area): This is the actual, free program memory that the user has

155

<!-- TOC PAGE_166: BIOS function reference table -->

===========================================================
                      PAGE 166 OF 386                       
===========================================================

can prove. So when you write a program or use one, this is the RAM for it.

And this is how BIOS, BDOS, CCP and TPA are located in the main memory:

|  Description | from address |
| --- | --- |
|  FDOS (BIOS + BDOS) | $9C00 |
|  CCP | $9400 |
|  TPA | $0100 |
|  System Parameters | $0000 |

Here are the FDOS functions in detail:

|  Function: | Description: |
| --- | --- |
|  --- | --- |

BIOS

|  00 | System Reset |
| --- | --- |
|  01 | Read ASCII characters from Terminal |
|  02 | Send ASCII characters to Terminal |
|  03 | Read ASCII characters from reader |
|  04 | Send ASCII characters to puncher |
|  05 | Send ASCII characters to printer |
|  06 | Receive/Send Characters to Console |
|  07 | Read status of a device unit |
|  08 | Send status to a device unit |
|  09 | Send string from Buffer |
|  10 | Read string in Buffer |
|  11 | Read status of the console unit |

<!-- TOC PAGE_167: CP/M system call reference guide -->

===========================================================
                      PAGE 167 OF 386                       
===========================================================

157

#BDOS

12 Read version number of CP/M
13 Disk Reset
14 Select drive number
15 Open file (OPEN)
16 Close file (CLOSE)
17 Search for first program in FCB
18 Search for the next program in FCB
19 Delete program (DELETE)
20 Read from sequential file
21 Write to sequential file
22 Create file
23 Change the program name (RENAME)
24 Specify possible drives
25 Read current drive number
26 Set DMA address
27 Read address
28 sets of write protection
29 Read/Write pointers
30 Set read/write pointers
31 Read address of the disk parameters
32 Read/Set user ID
33 Read from random file
34 Write to random file
35 Calculate program length
36 Read address of the record

All of these functions are called according to a very specific pattern. To clarify this, we now have to look a little at the 8080 machine language. Since CP/M was developed on this processor, and the Z-80 processor located in the Commodore 64 CP/M module also understands this language, most CP/M applications are presented in this language. If you are not yet familiar with this processor and its language, but would like to delve deeper into CP/M, we can only recommend that you not only read a detailed CP/M manual (e.g. HOW TO HANDL IT

<!-- TOC PAGE_168: CP/M function call documentation -->===========================================================
                      PAGE 168 OF 386                       
===========================================================

CP/M -- Bernd Pol -- IWT Verlag, or CP/M manual -- RODNAY ZAKS), but also Z-80 or 8080 manuals to make them your standard literature.

## What do the function calls look like?

For example, to determine the version number of the Commodore CP/M (it is 2.2), the following routine can be used:

|  MVI | C,12 | ;FUNCTION 12 |
| --- | --- | --- |
|  CALL | 0005 | ;BDOS INTERVENTION |
|  CPI | 20H | ;$20 MEANS CP/M 2.0 |

First, the C register is loaded with the value 12, i.e. the function number for reading the CP/M version. This C register is **always** loaded with the function number before branching to address 0005. CP/M now knows that we want to find out the CP/M version and automatically branches to the point in the CP/M system where the version number is read. BDOS then jumps back into our machine routines and has the version number provided in the battery. If the value of the battery is now $20, we know that this version of the CP/M is at least a 2.0 version. This information can be very interesting if we want to write a program that manages random files. All versions before 2.0 can only save sequential files (see Chapter 8). So if we want to use our program on a CP/M computer other than our Commodore 64, we can easily determine whether this program is even running on the computer.

The various registers play a very important role in the CP/M function calls. The first thing to be mentioned here is the C register, in which the function number is stored before the BDOS/BIOS call. After carrying out the

158

<!-- TOC PAGE_169: CP/M BIOS/BDOS documentation -->

===========================================================
                      PAGE 169 OF 386                       
===========================================================

The routine mentioned above then contains the desired information in the various other registers. Of course, it can also happen that there is no input but rather the output of a character. Then of course the call is a little different. Register C still contains the function code. However, the other registers or the other register are loaded before the call.

## Why short codes?

As you already know, one of the advantages of the CP/M operating system is that a CP/M program should generally run on every CP/M computer. However, small changes in the BIOS/BDOS or CCP may be necessary from computer to computer. In order to ensure that the programs run without the programmer having to worry about the structure of the CP/M, there is this BIOS/BDOS call at address 0005. This means that a certain part of the CP/M operating system can be changed (even if it is only one byte) without having to readjust the existing programs. You also have the same advantage with the KERNAL of the standard Commodore 64, i.e. without a CP/M operating system. There are the various entry points for the various I/O (input-output) routines. If one of these routines were to be changed, it would still be possible to continue using the old programs - they won't notice the change in the operating system at all.

## The CCP commands

As already mentioned above, the CCP represents an interface to the other CP/M programs. It has its own small set of commands. Executable programs can also be executed from here. All in all, the connection between the CP/M operating system and the user.

Here are the commands in detail:

<!-- TOC PAGE_170: CP/M DIR command reference -->===========================================================
                      PAGE 170 OF 386                       
===========================================================

1.) DIR (Directory): With this command you can view the table of contents of the diskette. There are various options for this:

- DIR displays the entire contents of the diskette located in the currently addressed drive.

- DIR B: displays the entire contents of the diskette located in drive B (1). A can also stand in place of B. Then the contents of drive A (O) will be displayed.

- DIR <name.ext> only shows whether the program you are looking for is also on the diskette. The NAME can be chosen arbitrarily, but must not exceed 8 characters and must not contain any special characters. EXT is a 3-character suffix to the program name. It indicates what type of program it is. For example, only programs with the abbreviation COM can be started. TXT would mean that this is a TEXT file, BAS is a BASIC program, etc.

- DIR &lt;*.EXT&gt; shows all programs that have the abbreviation EXT. So *.COM would show all programs that need to be started directly.

There are a number of other forms for the DIR command. Please refer to the CP/M manual.

Here is the format of the table of contents when using the DIR command on the Commodore 64:

|  A>DIR |   |   |   |
| --- | --- | --- | --- |
|  A: MOVCPM | COM: PIP | COM |   |
|  A: SUBMIT | COM : XSUB | COM |   |
|  A: ED | COM: ASM | COM |   |
|  A: DDT | COM : LOAD | COM |   |
|  A: STAT | COM: SYSGEN | COM |   |</name.ext>

<!-- TOC PAGE_171: CP/M command reference guide -->

===========================================================
                      PAGE 171 OF 386                       
===========================================================

A: DUMP COM : DUMP ASM
A: COPY COM : CONFIG COM
A&gt;

2.) ERA (Erase): This command deletes one or more programs from the table of contents. Here, too, there are various options:

- ERA <name.ext> see above
- ERA &lt;*.EXT&gt; see above

3.) REN (Rename): With this command you can give an existing program or file a new name. There is only one form here

- REN <new name=""> = <old name="">

4.) TYPE: This command only works on text files. For example, if you want to list a file that you created with a file management program on the screen (or the printer), you can use this command. It has the form:

- TYPE <filename.ext>

In most cases the abbreviation will be of the type TXT, PRN or similar.

5.) SAVE: This command is quite complicated at first glance. Normally you use this command when you have changed a program with DDT (see below) and want to save it again. But also when saving a modified CP/M version (see below). The form is:

- SAVE <page number> <name.ext>

161</name.ext></page number></filename.ext></newer></alter></name.ext>

<!-- TOC PAGE_172: CP/M command reference guide -->===========================================================
                      PAGE 172 OF 386                       
===========================================================

The page number indicates how many 'pages' should be saved per 256 bytes. This is how the command saves:

SAVE 50 TEST.COM

the TEST.COM program runs from address $0100 (beginning of TPA) to address $32FF. The length is therefore 50*256 bytes.

6.) USER: With the help of this command you can divide a table of contents for different users. This makes it possible to secure certain areas of the table of contents against use by other users (on other computers). With the Commodore 64, however, this command has no major meaning. It is only mentioned here for formality. The form is:

- USER USER NUMBER

The user number can have a value between 0 and 15. Entering a number takes you to the table of contents for the corresponding user. The number is 0.

These are the commands that every computer with a CP/M operating system understands. Only the USER command has only been available since CP/M version 2.0. All others, however, belong to the standard CP/M command set. On the next pages we will give you a brief insight into the standard CP/M programs: PIP, ED, DDT, STAT. Although they are included in the scope of delivery of every CP/M system diskette, they are not to be understood as commands, but rather as programs. Although they form a command extension in their entirety, they must first be reloaded from a diskette.

162

<!-- TOC PAGE_173: CP/M standard programs guide -->

===========================================================
                      PAGE 173 OF 386                       
===========================================================

163

# 6.2 HANDLING THE INDIVIDUAL CP/M PROGRAMS

What would CP/M be without its basic framework of support programs? DIGITAL RESEARCH, the manufacturer of CP/M, has ensured that the user can start programming from the very first moment - a downer for Commodore 64 users: There is no special BASIC version as standard. But nothing is impossible for CP/M - even a BASIC interpreter can be used later.

But now to the individual programs. The following programs belong to the CP/M standard:

- STAT.COM A program with which a wide variety of system information can be queried (e.g. storage space on the disk, connected interfaces, device assignments, etc.)
- ASM.COM An assembler. As already mentioned above, programming is often still done in 8080 assembly language. So this assembler is also designed for programming in 8080 code.
- LOAD.COM This program turns the fully assembled programs (programs with the abbreviation .HEX) into executable programs.
- DUMP.COM With this program a program (.COM) can be displayed on the screen in readable HEX form.
- PIP.COM In plain English you could say this program: A program for exchanging data between different peripheral units.
- ED.COM The CP/M text editor. This program is an important tool for creating texts,

<!-- TOC PAGE_174: CP/M utility program descriptions -->===========================================================
                      PAGE 174 OF 386                       
===========================================================

Machine programs and the like.

- SYSGEN.COM Where you could only copy files with PIP, you can use SYSGEN to write the individual BIOS tracks to disk and even generate a new BIOS (see Chapter 6.3).
- MOVCPM.COM This program adapts the standard CP/M to your specific computer type (see chapter 6.3)
- SUBMIT.COM It often happens that certain entries have to be made again and again at the same time. To make your work easier, the SUBMIT program is available to you.
- XSUB.COM This program also makes it easier for you to work with recurring command sequences. However, this program is only used in conjunction with SUBMIT. It allows manual input, i.e. via keyboard, during the automatic process using SUBMIT.

We cannot go into detail about all the programs at this point. At this point we will only content ourselves with a brief introduction to the various programs - CP/M manuals provide more detailed information.

# STAT

One of the most important programs is certainly the STAT program. You could also call it a STATUS program. With the help of this program you can obtain a lot of information about the status of the entire system. Not only can the remaining space on the diskette and the length of the programs be determined, the read/write pointers can also be changed, which indicate whether the diskette can be written to and read from, or perhaps only read

164

<!-- TOC PAGE_175: Commodore 64 CP/M STAT command guide -->

===========================================================
                      PAGE 175 OF 386                       
===========================================================

Access exists. And information about the various interfaces can also be queried and changed. However, there is a limitation here with the Commodore 64 CP/M version. The IOBYTE is not implemented, which means that the individual assignments cannot be changed. But this is not particularly disruptive for normal use.

Here is an example of the STAT command:

A&gt;STAT VAL:

TEMP R/O DISK: D:=R/O
SET INDICATOR: D:FILENAME.TYP $R/O $R/W $SYS $DIR
DISK STATUS : DSK: D:DSK:
USER STATUS: USR:
IOBYTE ASSIGN:

CON: = TTY: CRT: BAT: UC1:
RDR: = TTY: PTR: UR1: UR2:
PUN: = TTY: PTP: UP1: UP2:
LST: = TTY: CRT: LPT: UL1:

Here we now find out which values and in what form we can (theoretically) change - because as already said, the values under IOBYTE ASSIGN cannot be changed on the Commodore 64.

If, for example, we want to change the write protection on the floppy disk, all we need is: STAT A:=R/O. This write protection remains as long as the device remains switched on.

To find out the connected CP/M interfaces, simply type: STAT A:DEV:

The printout for the Commodore 64 then looks like this:

A&gt;STAT DEV:
CON: IS TTY:

165

<!-- TOC PAGE_176: Floppy disk system documentation -->

===========================================================
                      PAGE 176 OF 386                       
===========================================================

RDR: IS TTY:

PUN: IS TTY:

LST: IS TTY:

Any change to one of these assignments would remain unchanged on the system. For example: STAT LST:=LPT:.

The information about the disk characteristics is also very informative. Here you can find out how large the capacity of the diskette is, what its structure looks like and much more. The corresponding query is:

A&gt;STAT DSK:

A: DRIVE CHARACTERISTICS
1088: 128 BYTE RECORD CAPACITY
136: KILOBYTE DRIVE CAPACITY
64: 32 BYTE DIRECTORY ENTRIES
64: CHECKED DIRECTORY ENTRIES
128: RECORDS/EXTENT
8: RECORDS/BLOCK
34: SECTORS/BLOCK
2: RESERVED TRACKS

This is the statement from STAT. Now for another program,

PIP

This program is a universal program for copying files. It is not only possible to copy between different floppys, but also to output a text file to the printer. This has the advantage that the entire listing can be formatted, i.e. printed out with line numbers and tabs. To copy an entire diskette, the following form is used: PIP B:=A:*.*. This command copies all files and programs from drive A to drive B.

166

<!-- TOC PAGE_177: Commodore ED text editor guide -->===========================================================
                      PAGE 177 OF 386                       
===========================================================

To output a text file to the printer, you must use the following command: PIP LST:=DUMP.ASM. Now, if the printer is connected, the entire DUMP.ASM program will be output on it.

ED

This text editor allows you to enter text as well as machine programs and all programs that are to be compiled later, such as FORTRAN or COBOL programs. Working with ED requires some practice - it is certainly a bit complicated for the Commodore user and takes some getting used to, but you quickly become familiar with how this simple editor works. Here is an example:

```
A&gt;ED TEST.TXT
NEW FILE
*I
THIS IS THE FIRST LINE OF TEXT
AND THIS THE SECOND
<ctrl>-Z Press CTRL and Z
button at the same time
*E
```

With this small example you can write your first text file to disk. When the writing process is finished, the operating system reports again with A&gt;. Now try the TYPE command (see above).

With ED you can not only create and write texts (programs), but you can also read them back in, change them and carry out other manipulations on them.

167</ctrl>

<!-- TOC PAGE_178: CP/M adaptation guide for C-64 -->

===========================================================
                      PAGE 178 OF 386                       
===========================================================

168

# 6.3 ADAPTING STANDARD CP/M SOFTWARE TO THE C-64

What should you pay attention to when adapting CP/M software to the hardware of the Commodore 64? First of all, you have to remember that you only have a 40 character screen available. However, since most user software is tailored to the 80 characters of a standard terminal, you need an 80 character card for this.

A large and fast floppy is also an advantage when using CP/M.

This system then gives you access to the largest range of software in the world.

To adapt CP/M to a computer, the operating system has two programs: MOVCPM and SYSGEN.

MOVCPM allows you to set the operating system to a specific memory configuration. This makes it possible to fully utilize the maximum storage space. When starting the CP/M operating system, the computer reports the message 44K CP/M. But it is even possible to use the full memory for CP/M. As already mentioned, it is possible to switch the Commodore 64 entirely to RAM.

With SYSGEN the CP/M system can then be copied to your diskettes. You now have a CP/M computer that can do even more.

<!-- TOC PAGE_179: Z80 memory management guide -->===========================================================
                      PAGE 179 OF 386                       
===========================================================

6.4 THE MEMORY MANAGEMENT OF THE Z80 PROCESSOR

The Z80 processor on the CP/M card can address the full 64 KBytes of the Commodore 64. Since the Z80 requires address zero as a reset address, but this address is assigned to the processor port of the 6510 in the Commodore 64, a different approach was taken to address the memory by the Z80 processor. The CP/M card contains the hardware to create an offset when the Z80 addresses memory. The offset is $1000 equal to 4096. This results in the following situation: If the Z80 processor addresses memory cell 0, the address $1000 of the Commodore 64 is addressed under the 6510 through hardware manipulation of the address lines. Since the Z80 is intended to be operated together with the 6510, the Z80 processor has a continuous memory area starting at address 0. If you want to calculate the corresponding Z80 address from a 6510 address, you simply subtract $1000 and then get the Z80 address. Alternatively, you can add $F000 and ignore any carryover. This trick places a 4 Kbyte range from address 0 to $1000 of the 6510 at the end of the Z80's address range. This memory area is used by the 6510 as zero page, stack and main memory. The video RAM is also located there. The remaining 2 Kbytes from $800 to $FFF are used by the CP/M card to transfer data from the 6510 to the Z80 and vice versa and as program memory for 6510 input-output routines. The Z80 delegates the input/output to the 6510. This situation is shown again graphically on the next page.

The most important common addresses of the CP/M between Z80 and 6510 are summarized below.

<!-- TOC PAGE_180: 6510/Z80 memory map table -->

===========================================================
                      PAGE 180 OF 386                       
===========================================================

170

|  label | 6510 | Z80 | Meaning |
| --- | --- | --- | --- |
|  HSTBUF | $0800 | OF800H | 256 bytes floppy buffer |
|  CMD | $0900 | OF900H | Command register for 6510 |
|  DATA | $0901 | OF901H | Data register |
|  SECTOR | $0902 | OF902H | Sector register |
|  TRACK | $0903 | OF903H | Track register |
|  DISKNO | $0904 | OF904H | Drive number register |
|  KEYCHAR | $0905 | OF905H | Number of the pressed key |
|  FASHION SW | $DE00 | OCE00H | Switch for 6510 / Z80 |
|  IOTYPE | $OCFF | OFCFFH | I/O configuration |

6510

Z80

6510

$FFFF

6510

OPERATING

SYSTEM

$DOOO

$C000

48K

44K

CP/M

$1000

$0000

6510 - Z80

OEEFFH

OFFFFH

OCOOOH

OBOOOH

OF90OH

OF80OH

OF40OH

OFOOOH

OFOOOH

$OFFFF

$0EFFFH

$0900

$0800

$0400

$0000

$0510

WORKING

STORAGE

$0000

<!-- TOC PAGE_181: CP/M disk management guide -->

===========================================================
                      PAGE 181 OF 386                       
===========================================================

171
# 6.5 DISK MANAGEMENT UNDER CP/M

A floppy disk is divided into several concentric tracks, which in turn are divided into individual sectors (segments). For the VC 1541 it looks like this:

|  track | Sectors |
| --- | --- |
|  1-17 | 0-20 |
|  18-24 | 0-18 |
|  25-30 | 0-17 |
|  31-35 | 0-16 |

This is a total of 683 sectors (blocks), of which track 18 is used internally for the diskette table of contents, so that you still have 664 blocks available.

Under CP/M, the first two tracks are reserved for the CP/M system itself; the other programs are free for data and program storage. Track 18 is left out. Since the diskette management under CP/M cannot process variable numbers of sectors per track, only sectors 0 to 16 are used. In the end you still have 32 tracks with 17 sectors each, which is 574 blocks of 256 bytes equal to 143 Kbytes. There is still some difference for the CP/M directory (max. 64 entries of 32 bytes each, equal to 2 Kbytes). This data is stored in the BIOS (Basic Input/Output System) of the CP/M in the so-called Disk Parameter Block and can be adapted by the user to his disk capacity. For example, track 18 (which contains the Commodore Directory) is left out in the BIOS. Please take a look at the BIOS listing of the CP/M 64.

The assignment of the first two tracks by the operating system looks like this:

<!-- TOC PAGE_182: CP/M disk layout documentation -->===========================================================
                      PAGE 182 OF 386                       
===========================================================

Track 1 sector 0 contains the loader 'CPM'. In track 1 from sectors 1 to 5 there is the 'BIOS 65', which are the I/O routines for the 6510 and the cold start loader for the CP/M. The 'CPM' program loads these 5 sectors into the memory area $0A00 to $0EFF. The range from $0E00 to $0EFF is then transferred to the address $1000 to $10FF. This is Z80 address 0 to which the cold start charger is transferred. The 6510 then switches itself off and the Z80 on at the same time. The Z80 now runs the program from address 0, which loads the CP/M operating system from the diskette. CCP and BDOS (Command Console Processor and Basic Disk Operation System) occupy 22 sectors on tracks one and two; namely from track 1 sector 6 to track 2 sector 10. These sectors are also reloaded from the diskette with every warm start with Control C; An asterisk appears on the screen for each loaded sector. The BIOS, which is only loaded during a cold start, occupies 5 sectors from track 2, sector 11 to sector 16. The directory occupies sectors 0 to 7 on track 3.

With the CP/M utility program 'COPY', depending on the selected option, only the required sectors are read and written to the new diskette, e.g. with 'system tracks only' only sectors 1 and 2 as well as 18 and track 3 for the CP/M directory.

If you want to connect another floppy, e.g. via the IEC bus, you need to know the track and sector division of the floppy disk station. No adjustment is required for the 4040 floppy, as 4040 floppy disks are completely compatible with the 1541. In order to take advantage of the increased storage capacity of an 8050 or 8250 floppy, an adjustment in the BIOS is required. The 'Disk Parameter Block' is used for this purpose. There are the values for sectors per track (23 for 8050) as well

172

<!-- TOC PAGE_183: Commodore disk formatting instructions -->

===========================================================
                      PAGE 183 OF 386                       
===========================================================

the disk capacity. In addition, instead of track 18, tracks 38 and 39 must be left out because the Commodore directory is located there. These changes are also required in the COPY program.

173

<!-- TOC PAGE_184: Commodore 64 CP/M processor cooperation -->

===========================================================
                      PAGE 184 OF 386                       
===========================================================

174
# 6.6 THE COLLABORATION BETWEEN 6510 AND Z80

When you work with CP/M on the Commodore 64, two microprocessors share the work. While the Z80 serves the actual CP/M, the 6510 is used for input/output operations, as the Commodore 64 operating system already provides these routines. The following tasks are delegated from the Z80 to the 6510:

|  Command number | Operation |
| --- | --- |
|  0 | read a sector from floppy disk |
|  1 | write a sector to a floppy disk |
|  2 | Query the keyboard |
|  3 | Output characters to screen |
|  4 | Get status of printer |
|  5 | Output characters to printer |
|  6 | Format floppy disk |
|  7 - 9 | reserved for future expansion,
e.g. serial input/output |

The two processors cannot work at the same time, but only alternately. The address $DE00 of the 6510 or OCE00H of the Z80 is used to switch between the two processors. If the Z80 wants the 6510 to execute an input/output function, it passes the number of the desired command from the table above and, if necessary, other parameters in a shared memory area to the 6510 and then switches itself off by writing a '1' to the address OCE00H and thus switches the 6510 on. This now knows which function it should execute for the Z80 based on the command number. Once the command has been executed, the 6510 switches itself off by writing a '0' to address $DE00 and thus switches the Z80 back on. The Z80 can now be back in its place in its program

<!-- TOC PAGE_185: 6510/Z80 memory mapping guide -->===========================================================
                      PAGE 185 OF 386                       
===========================================================

continue where he had relinquished control to the 6510. Due to hardware requirements, the first command after the 6510 and Z80 are switched back on must be a NOP (No Operation) command.

The memory area from address $900 or OF900H is used for parameter transfer.

|  6510 | Z80 | Meaning |
| --- | --- | --- |
|  $900 | OF900H | Command number |
|  $901 | OF901H | Data for input or output |
|  $902 | OF902H | Sector number |
|  $903 | OF903H | Track number |
|  $904 | OF904H | Floppy number |
|  $905 | OF905H | Key number for keyboard query |

The range from $800 to $8FF or OF800H to OF8FFH serves as a buffer for a sector of the diskette to be written or read.

Reading or writing diskette sectors is done directly using block read and block write commands.

The keyboard query only provides the number of the key pressed. The assignment of a key to an ASCII value is done from the BIOS via a table from address $DOO to $DFF or OFDOOH to OFDFFH. Starting at address $COO or OFCOOH are the addresses of the texts with which the function keys are assigned. The texts themselves, which can contain up to 16 characters, start at address $C10 or OFC10H. These assignments can be changed as desired using the CONFIG program.

175

<!-- TOC PAGE_186: Commodore 64 CP/M BIOS listing -->

===========================================================
                      PAGE 186 OF 386                       
===========================================================

176

#6.7 COMMENTED CP/M BIOS LISTING

On the following pages you will find a detailed documented listing of the Basic I/O System (BIOS) of the Commodore 64 CP/M. The BIOS is divided into 4 parts. The first part includes the program "CPM" on your system disk and is loaded with LOAD "CPM",8 in the address range from $800 to $8FF. This program loads BIOS65 into memory from address $A00 to $DFF. This is the part of the BIOS that is run by the 6510 processor. The third part is the so-called 'BOOT' program, which loads the fourth part, the actual Z80 BIOS, when the CP/M cold starts.

# 6.7.1 LOADING PROGRAM FOR BIOS 65

|  *** | Commodore 64 loading program for CP/M |
| --- | --- |
|  080F 78 SEI |   |
|  0810 20 E7 FF JSR $FFE7 | CLALL, close all I/O channels |
|  0813 A9 0F LDA #$0F | logical file number 15 |
|  0815 A2 08 LDX #$08 | Device number 8 |
|  0817 A0 0F LDY #$0F | Secondary address 15 |
|  0819 20 BA FF JSR $FFBA | Set file parameters |
|  081C A9 00 LDA #$00 | no file name |
|  081E 20 BD FF JSR $FFBD | Set parameters for file names |
|  0821 20 CO FF JSR $FFCO | OPEN error channel |
|  0824 A9 02 LDA #$02 | logical file number 2 |
|  0826 A2 08 LDX #$08 | Device number 8 |
|  0828 A0 02 LDY #$02 | Secondary address 2 |
|  082A 20 BA FF JSR $FFBA | Set file parameters |
|  082D A9 01 LDA #$01 | Length of the file name equals one |
|  082F A2 B5 LDX #$B5 |   |
|  0831 A0 08 LDY #$08 | Pointer to "#" |

<!-- TOC PAGE_187: Z80 assembly bootloader code -->

===========================================================
                      PAGE 187 OF 386                       
===========================================================

177

0833 20 BD FF JSR $FFBD Set parameters for file names
0836 20 CO FF JSR $FFCO OPEN Direct access channel
0839 A9 05 LDA #$05
083B 8D B6 08 STA $08B6 Load counter for 5 sectors
083E A2 OF LDX #$OF 15
0840 20 C9 FF JSR $FFC9 CKOUT, output on channel 15
0843 A2 00 LDX #$00
0845 AO 0B LDY #$0B 12 characters
0847 BD AA 08 LDA $08AA,X "U1:2 0 1 s" Track 1, Sector 1 to 5
Issue 084A 20 D2 FF JSR $FFD2
084D E8 INX
084E 88 DEY
084F DO F6 GNI $0847
0851 20 CC FF JSR $FFCC CLRCH, output back to default
0854 A2 02 LDX #$02 2
0856 20 C6 FF JSR $FFC6 CHKIN, entry of channel 2
0859 A2 00 LDX #$00
085B 20 CF FF JSR $FFCF Get character
085E 9D 00 0A STA $0A00,X and save
0861 E8 INX
0862 DO F7 BNE $085B already 256 characters?
0864 20 CC FF JSR $FFCC CLRCH, input back to default
0867 EE B3 08 INC $08B3 Increase sector number
086A EE 60 08 INC $0860 Increase memory address by one page
086D CE B6 08 DEC $08B6 5 sectors already read?
0870 DO CC BNE $083E no, read on
0872 A2 00 LDX #$00
0874 BD 00 0E LDA $0E00,X BOOT program for Z80
0877 9D 00 10 Copy STA $1000,X to Z80 address 0000H
087A E8 INX
087B DO F7 GNI $0874
087D 20 E7 FF JSR $FFE7 CLALL, close I/O channels
0880 A9 36 LDA #$36
0882 85 01 STA $01 Switch off BASIC ROM

<!-- TOC PAGE_188: Z80 assembly code snippet -->===========================================================
                      PAGE 188 OF 386                       
===========================================================

0884 A9 09 LDA #$09 CHR$(9)

0886 20 D2 FF JSR $FFD2 Allow switching

0889 A9 OE LDA #$0E CHR$(14)

088B 20 D2 FF JSR $FFD2 Set text mode

088E A9 08 LDA #$08 CHR$(8)

0890 20 D2 FF JSR $FFD2 Disable switchover

0893 A9 93 LDA #$93 CHR$(147)

0895 20 D2 FF JSR $FFD2 Clear screen

0898 A9 OD LDA #$0D CHR$(13)

089A 20 D2 FF JSR $FFD2 new line

089D A9 FF LDA #$FF

089F 8D 00 09 STA $0900 Command register

08A2 A9 28 LDA #$28 Key number

08A4 8D 05 09 STA $0905 note

08A7 4C 00 0A JMP $0A00 to main loop Z80 - 6510

08AA 55 31 3A 32 20 30 20 31 20 31 OD "U1:2 0 1 1" block read command

08B5 23 "#" File name for direct access

<!-- TOC PAGE_189: Commodore 64 BIOS assembly code -->

===========================================================
                      PAGE 189 OF 386                       
===========================================================

6.7.2 BIOS 65

Main loop Z80 - 6510

OA00 A9 00 LDA #$00
OA02 8D 00 DE STA $DE00 6510 switch off
OA05 EA NOP
OA06 20 OC 0A JSR $OAOC Run routine for Z80
OA09 4C 00 0A JMP $OA00 back to the loop

Select routines for Z80

OAOC AD 00 09 LDA $0900 Command code
OAOF C9 FF CMP #$FF Z80 not active?
OA11 TH 03 GNI $OA16
OA13 6C FC FF JMP ($FFFC) RESET of the Commodore 64
OA16 C9 0A CMP #$0A Command number greater than or equal to 10?
OA18 90 01 BCC $OA1B no
OA1A 60 RTS ready

OA1B D8 CLD
OA1C 18 CLC
OA1D 6D 00 09 ADC $0900 Command number * 2
OA20 69 28 ADC #$28 plus $28
OA22 8D 26 0A STA $OA26 set indirect address
OA25 6C 28 0A JMP ($0A28) Execute command

Jump table of 10 functions

OA28 3F 0A Function 0, READ SECTOR
OA2A 57 0A Function 1, WRITE SECTOR
OA2C 86 0A Function 2, KEYBOARD INQUIRY
OA2E 8F 0A Function 3, SCREEN OUTPUT
OA30 99 0A Function 4, GET PRINTER STATUS
OA32 9F 0A Function 5, PRINTER OUTPUT
OA34 49 0B Function 6, FORMAT DISK

179

<!-- TOC PAGE_190: Disk sector read/write code -->

===========================================================
                      PAGE 190 OF 386                       
===========================================================

OA36 00 OE Function 7, AUX1, jump to $E00
OA38 00 OF Function 8, AUX2, jump to $F00
OA3A 3C OA Function 9, INDIRECT, Jump To ($906)

*** Function 9, INDIRECT
OA3C 6C 06 09 JMP ($0906) indirect jump to ($906)

*** Function 0, READ SECTOR
OA3F A9 31 LDA #$31 "1" for "U1" equals block read
OA41 20 F2 OA JSR $OAF2 sends block read command to diskette
OA44 20 DE OB JSR $OBDE Entry of random access channel
OA47 A2 00 LDX #$00
OA49 20 CF FF JSR $FFCF Get character
OA4C 9D 00 08 STA $0800,X store in buffer
OA4F E8 INX
OA50 D0 F7 BNE $0A49 already 256 characters?
OA52 F0 60 BEQ $OAB4 CLRCH
OA54 20 97 OB JSR $OB97 Initialize diskette

*** Function 1, WRITE SECTOR
OA57 20 F4 OB JSR $OBF4 Output to the command channel of the diskette
OA5A A0 08 LDY #$08 8 characters
OA5C BD 80 OB LDA $0B80,X "B-P 2 0" , set pointer to start of sector
OA5F 20 D2 FF JSR $FFD2 issued
OA62 E8 INX
OA63 88 DEY
OA64 D0 F6 BNE $0A5C
OA66 20CC FF JSR $FFCC CLRCH
OA69 20 CE OB JSR $OBCE Read error channel
OA6C D0 E6 BNE $0A54 Error, then initialize and again
OA6E 20CC FF JSR $FFCC CLRCH
OA71 20 E9 OB JSR $OBE9 Output on channel 2
OA74 A2 00 LDX #$00

180

<!-- TOC PAGE_191: 6502 assembly disk write routine -->

===========================================================
                      PAGE 191 OF 386                       
===========================================================

OA76 BD 00 08 LDA $0800,X characters from buffer
OA79 20 D2 FF JSR Send $FFD2 to diskette
OA7C E8 INX
OA7D DO F7 BNE $0A76 already 256 characters
OA7F 20CC FF JSR $FFCC CLRCH
OA82 A9 32 LDA #$32 "2" for "U2" equals Block Write
OA84 DO 6C BNE $0AF2 Block Write command to diskette

***
OA86 20 9F FF JSR $FF9F Query keyboard
OA89 A5 C5 LDA $C5 Matrix number of the character read
OA8B 8D 05 09 STA $0905 passed to Z80
OA8E 60 RTS

***
OA8F A9 00 LDA #$00
OA91 85 D4 STA $D4 Delete apostrophe flag
OA93 AD 01 09 LDA $0901 Load characters
OA96 4C D2 FF JMP $FFD2 and output to screen

***
OA99 A9 00 LDA #$00
OA9B 8D 01 09 STA $0901 Status equals zero
OA9E 60 RTS

***
OA9F AD 01 09 LDA $0901 Character to be output
OAA2 C9 0A CMP #$0A Line Feed ?
OAA4 DO 01 BNE $0AA7 no?
OAA6 60 RTS yes, then suppress
OAA7 A2 04 LDX #$04 logical file number 4
OAA9 20 C9 FF JSR $FFC9 CKOUT, set output to printer
OAAC B0 09 BCS $0AB7 error?
OAAE AD 01 09 LDA $0901 Character to be output

181

<!-- TOC PAGE_192: Z80 assembly printer control code -->===========================================================
                      PAGE 192 OF 386                       
===========================================================

Send OAB1 20 D2 FF JSR $FFD2 to the printer
OAB4 4C CC FF JMP $FFCC CLRCH, output back to default

OAB7 C9 03 CMP #$03 File not open?
OAB9 D0 05 BNE $OACO no, other error
OABB 20 C6 0A JSR $OAC6 Open print file
OABE 90 DF BCC $OA9F no error, then output characters
OACO A9 FF LDA #$FF Code for error
OAC2 8D 01 09 STA $0901 passed to Z80
OAC5 60 RTS

OAC6 A0 07 LDY #$07 Secondary address 7 for VC printer
OAC8 20 DE 0A JSR $OADE Close and reopen the print file
OACB AD FF OC LDA $OCFF I/O type (printer type)
OACE 29 02 AND #$02
OADO F0 F3 BEQ $OAC5 1515 printer?
OAD2 A2 04 LDX #$04 logical file number
OAD4 20 C9 FF JSR $FFC9 CKOUT, output to printer
OAD7 A9 0D LDA #$0D carriage return
OAD9 20 D2 FF JSR $FFD2 to printer
OADC A0 00 LDY #$00 Secondary address 0
OADE A9 04 LDA #$04 logical file number 4
OAEO 20 C3 FF JSR $FFC3 CLOSE
OAE3 A9 04 LDA #$04 logical file number 4
OAE5 A2 04 LDX #$04 Device number 4
OAE7 20 BA FF JSR $FFBA Set file parameters
OAEA A9 00 LDA #$00 no filename
OAEC 20 BD FF JSR $FFBD Set parameters for file names
OAEF 4C CO FF JMP $FFCO OPEN

***
OAF2 8D 63 0B STA $OB63 Space for "1" or "2"
OAF5 AD 04 09 LDA $0904 Disk number
OAF8 20 89 0B JSR $OB89 Convert number to ASCII
182

<!-- TOC PAGE_193: Disk formatting assembly code -->

===========================================================
                      PAGE 193 OF 386                       
===========================================================

OAFB 8D 67 OB STA $0B67
and remember

OAFE AD 03 09 LDA $0903
Track number

OBO1 20 89 OB JSR $0B89
convert to ASCII

OBO4 8E 69 OB STX $0B69
and remember

OBO7 8D 6A OB STA $0B6A

OBOA AD 02 09 LDA $0902
Sector number

OBOD 20 89 OB JSR $0B89
convert to ASCII

OB10 8E 6C OB STX $0B6C
and remember

OB13 8D 6D OB STA $0B6D

OB16 A9 02 LDA #$02
2 attempts

OB18 8D 01 09 STA $0901

OB1B 20 F4 OB JSR $0BF4
CKOUT, output on channel 15

OB1E AO OD LDY #$OD
13 characters

OB20 BD 62 OB LDA $0B62,X
"U1: 2 0 tt ss" or "U2: 2 0 tt ss"

OB23 20 D2 FF JSR $FFD2
send to disk

OB26 E8 INX

OB27 88 DEY

OB28 DO F6 BNE $0B20

OB2A 20CC FF JSR $FFCC
CLRCH

OB2D 20 CE OB JSR $0BCE
Read error channel

OB30 FO OB BEQ $0B3D
OK

OB32 CE 01 09 DEC $0901
already second attempt?

OB35 FO OE BEQ $0B45
yes

OB37 20 97 OB JSR $0B97
Initialize diskette

OB3A 4C 1B OB JMP $0B1B
and try again

OB3D A9 00 LDA #$00
Flag for 'ok'

OB3F 8D 01 09 STA $0901
remember

OB42 4C CC FF JMP $FFCC
CLRCH, output back to default

OB45 A9 FF LDA #$FF
Flag for 'Error'

OB47 DO F6 BNE $0B3F
continue as above

*** Function 6, FORMAT DISK

183

<!-- TOC PAGE_194: CP/M disk operation code listing -->

===========================================================
                      PAGE 194 OF 386                       
===========================================================

184

OB49 20 F4 OB JSR $OBF4 Open command channel OPEN 15,8,15 and CHKOUT
OB4C AO 10 LDY #$10 16 characters
OB4E BD 70 OB LDA $OB70,X "NO:CP/M DISK,65"
Send OB51 20 D2 FF JSR $FFD2 to diskette
OB54 E8 INX
OB55 88 DEY
OB56 DO F6 BNE $OB4E
OB58 20CC FF JSR $FFCC CLRCH
OB5B 20 CE OB JSR $OBCE Read error channel
OB5E DO E5 BNE $OB45 Set error flag
OB60 FO DB BEQ $OB3D Set flag for 'ok'

*** Texts for diskette operation
OB62 55 31 3A 32 20 30 20 54 54 20 53 53 OD "U1:2 0 TT SS"
OB6F 23 "#" random access file
OB70 4E 30 3A 43 50 2F 4D 20 44 49 53 4B 2C 36 35 OD "NO:CP/M DISK,65"
OB80 42 2D 50 20 32 20 30 OD "B-P 2 0"
OB88 49 "I"

*** Hex number in battery according to ASCII in X/A
OB89 D8 CLD
OB8A A2 30 LDX #$30 "0"
OB8C 38 SEC
OB8D E9 0A Remove SBC #$0A 10
OB8F 90 03 BCC $OB94
OB91 E8 INX X contains tens digit
OB92 BO F9 BCS $OB8D
OB94 69 3A ADC #$3A battery contains units digit
OB96 60 RTS

<!-- TOC PAGE_195: 6502 assembly disk file code -->===========================================================
                      PAGE 195 OF 386                       
===========================================================

185

Initialize and open direct access file

OB97 A9 OF LDA #$OF logical file number
OB99 20 C3 FF JSR $FFC3 CLOSE 15
OB9C A9 OF LDA #$OF logical file number 15
OB9E A2 08 LDX #$08 Device number 8
OBAO AO OF LDY #$OF Secondary Dress 15
OBA2 20 BA FF JSR $FFBA Set file parameters
OBA5 A9 01 LDA #$01 Length of file name equal to one
OBA7 A2 88LDX #$88
OBA9 AO OB LDY #$0B Pointer to "I"
OBAB 20 BD FF JSR $FFBD Set parameters for file names
OBAE 20 CO FF JSR $FFCO OPEN 15,8,15,"I"
OBB1 A9 02 LDA #$02 logical file number 2
OBB3 20 C3 FF JSR $FFC3 CLOSE 2
OBB6 A9 02 LDA #$02 logical file number 2
OBB8 A2 08 LDX #$08 Device number 8
OBBA AO 02 LDY #$02 Secondary address 8
OBBC 20 BA FF JSR $FFBA Set file parameters
OBBF A9 01 LDA #$01 Length of the file name equals one
OBC1 A2 6F LDX #$6F
OBC3 AO OB LDY #$0B Pointer to "#"
OBC5 20 BD FF JSR $FFBD Set parameters for file names
OBC8 4C CO FF JMP $FFCO OPEN 2,8,2,"#"
OBCB 20 97 OB JSR $0B97 Initialize diskette

Read error channel

OBCE A2 OF LDX #$OF logical file number 15
OBDO 20 C6 FF JSR $FFC6 CHKIN
OBD3 BO F6 BCS $OBCB error, then initialize the diskette
OBD5 20 CF FF JSR $FFCF Get characters from error channel
Compare OBD8 C9 30 CMP #$30 with "0".
OBDA 60 RTS

<!-- TOC PAGE_196: Assembly code disk operations -->

===========================================================
                      PAGE 196 OF 386                       
===========================================================

186

OBDB 20 B1 OB JSR $OBB1 Reopen direct access channel

***
OBDE A2 02 LDX #$02
OBEC 20 C6 FF JSR $FFC6
OBE3 BO F6 BCS $OBDB
OBE5 60 RTS
OBEB 20 B1 OB JSR $OBB1

***
OBE9 A2 02 LDX #$02
OBEB 20 C9 FF JSR $FFC9
OBEE BO F6 BCS $OBE6
OBFO 60 RTS
OBF1 20 97 OB JSR $OB97

***
OBF4 A2 OF LDX #$OF
OBF6 20 C9 FF JSR $FFC9
OBF9 BO F6 BCS $OBF1
OBFB A2 00 LDX #$00
OBFD 60 RTS

Set input to direct access channel
logical file number 2
CHKIN
Error, then reopen

Reopen direct access channel

Set output to direct access channel
logical file number 2
CKOUT
Error, then reopen channel

Initialize diskette

Set output to command channel
logical file number 15
CKOUT
Error, then initialize the diskette first
Pointer to zero

<!-- TOC PAGE_197: Commodore keyboard code table -->

===========================================================
                      PAGE 197 OF 386                       
===========================================================

187

Z80 addresses of the function key texts

OC00 10 FC 20 FC 30 FC 40 FC
OC00 50 FC 60 FC 70 FC 80 FC

Assignment of the function keys

OC10 44 49 52 OD 00 00 00 00 00 00 00 00 00 00 00 00 DIR
OC20 44 49 52 20 42 3A OD 00 00 00 00 00 00 00 00 00 DIR B:
OC30 53 54 41 54 20 2A 2E 2A OD 00 00 00 00 00 00 00 STAT *.*
OC40 53 54 41 54 20 42 3A 2A 2E 2A OD 00 00 00 00 00 00 STAT B:*.*
OC50 43 4F 50 59 OD 00 00 00 00 00 00 00 00 00 00 00 COPY
OC60 43 4F 4E 46 49 47 OD 00 00 00 00 00 00 00 00 00 CONFIG
OC70 44 44 54 OD 00 00 00 00 00 00 00 00 00 00 00 00 DDT
OC80 44 44 54 20 00 00 00 00 00 00 00 00 00 00 00 DDT

Keyboard code table

|  Commodore | button | normal | Shift |
| --- | --- | --- | --- |
|  OD00 08 08 08 18 | DEL | BS | CAN |
|  OD04 OD 0D 0D 0D | CR | CR |   |
|  OD08 1C 1C 1D 1D | Cursor right | FS | GS |
|  OD0C 86 86 87 87 | F7, F8 | F7 | F8 |
|  OD10 80 80 81 81 | F1, F2 | F1 | F2 |
|  OD14 82 82 83 83 | F3, F4 | F3 | F4 |
|  OD18 84 84 85 85 | F5, F6 | F5 | F6 |
|  OD1C 1E 1E 1F 1F | Cursor down | RS | US |
|  OD20 33 33 23 33 | 3# | 3 3 | 3 # 3 |
|  OD24 77 57 57 17 | W | w W | W ^W |
|  OD28 61 41 41 01 | A | a A | A ^A |
|  OD2C 34 34 24 34 | $4 | 4 4 | $4 |
|  OD30 7A 5A 5A 1A | Z | z Z | Z ^Z |
|  OD34 73 53 53 13 | S | s S | S ^S |
|  OD38 65 45 45 05 | E | e E | E ^E |
|  OD3C 00 00 00 00 | Shift | NUL |   |
|  OD40 35 35 25 35 | 5% | 5 5 | 5% 5 |

<!-- TOC PAGE_198: ASCII character encoding table -->===========================================================
                      PAGE 198 OF 386                       
===========================================================

| OD44 72 52 52 12 | R | r R R ^R |
| --- | --- | --- |
| OD48 64 44 44 04 | D | d D D ^D |
| OD4C 36 36 26 36 | 6 & | 6 6 & 6 |
| OD50 63 43 43 03 | C | c C C ^C |
| OD54 66 46 46 06 | F | f F F ^F |
| OD58 74 54 54 14 | T | t T T ^T |
| OD5C 78 58 58 18 | X | x
| OD60 37 37 27 37 | 7^| 7 7^7 |
| OD64 79 59 59 19 | Y | y Y Y ^Y |
| OD68 67 47 47 07 | G | g G G ^G |
| OD6C 38 38 28 7B | 8 ( | 8 8 ( ( |
| OD70 62 42 42 02 | B | b B B ^B |
| OD74 68 48 48 08 | H | h H H ^H |
| OD78 75 55 55 15 | U | u U U ^U |
| OD7C 76 56 56 16 | V | v V V ^V |
| OD80 39 39 29 7D | 9 ) | 9 9 ) } |
| OD84 69 49 49 09 | I | i I I ^I |
| OD88 6A 4A 4A 0A | J | j J Y ^J |
| OD8C 30 30 30 00 | O | O O O NUL |
| OD90 6D 4D 4D 0D | M | m M M ^M |
| OD94 6B 4B 4B 0B | K | k K K ^K |
| OD98 6F 4F 4F 0F | O | o O O ^O |
| OD9C 6E 4E 4E 0E | N | n N N ^N |
| ODAO 2B 2B 2B 2B | + | + + + + |
| ODA4 70 50 50 10 | P | p P P ^P |
| ODA8 6C 4C 4C 0C | L | l L L ^L |
| ODAC 2D 2D 2D 2D | - | - - - - |
| ODBO 2E 2E 3E 7D | . > | . . > } |
| ODB4 3A 3A 5B 7B | : [ | : : [ ( |
| ODB8 40 40 40 60 | @ | @ @ @ ^ |
| ODBC 2C 2C 3C 7B | , < | , , < } |
| ODCO 5C 5C 5C 7C | \ | \ \ \ | |
| ODC4 2A 2A 2A 2A | * | * * * * |
| ODC8 3B 3B 5D 7D | ; ] | ; ; ] } |

<!-- TOC PAGE_199: Commodore keyboard layout chart -->

===========================================================
                      PAGE 199 OF 386                       
===========================================================

|  ODCC 1B 1B 1B 7F | Home | ESC | DEL |
| --- | --- | --- | --- |
|  ODDO 00 00 00 00 | Shift | NUL |   |
|  ODD4 3D 3D 3D 3D | = | = = = = |   |
|  ODD8 5E 5E 5E 7E | ^ | ^ · · · |   |
|  ODDC 2F 2F 3F 5C | / ? | / / ? \ |   |
|  ODEO 31 31 21 31 | 1! | 1 1! 1 |   |
|  ODE4 5F 5F 5F 5F | Arrow left | _ _ _ _ |   |
|  ODE8 00 00 00 00 | CTRL | NUL |   |
|  ODEC 32 32 22 32 | 2 " | 2 2 " 2 |   |
|  ODFO 20 20 20 20 | Spacebar | Space bar |   |
|  ODF4 00 00 00 00 | Commodore | NUL |   |
|  ODF8 71 51 51 11 | Q | q Q Q ^Q |   |
|  ODFC 03 03 03 03 | STOP | ^C ^C ^C ^C |   |

<!-- TOC PAGE_200: Z80 boot routine documentation -->

===========================================================
                      PAGE 200 OF 386                       
===========================================================

6.7.3 Z80 BOOT ROUTINE

```asm
; Z80 BOOT routine for the Commodore 64
;
COPYRIGHT (C) 1982
; COMMODORE INTERNATIONAL
;
This routine is performed by Track 1, Sector 5 of the
Commodore 64 CP/M disk from a routine
loaded in BIOS65.
;
The loading address is 0000H (from the Z80's perspective
processor). When the Z80 is turned on, it charges
this routine the Z80 BIOS as well as the CCP and that
BIOS into RAM and jumps there.
;

3400 = CCP EQU 3400H ;Offset for 20K CP/M
;CCP EQU 0000H ;for BOOTO.HEX
;CCP EQU 0100H ;for BOOT1.HEX
001C = NSECTS EQU 1CH ;Number of sectors to load
F903 = TRACK EQU OF903H ;Register for track number
F902 = SECTOR EQU OF902H ;Sector number register
F904 = DISKNO EQU OF904H ;Disk number register
FCFF = IOTYPE EQU OFCFFH ;IO configuration byte in BIOS65
4A33 = KYBDMD EQU CCP+1633H ;Capital mode flag
0000 = VICRD EQU 0 ;Read command number for sector
F900 = CMD EQU OF900H ;Command register
0001 = OFF EQU 01H ;Value for switching off the Z80
CE00 = MODESW EQU OCE00H ;Address to switch off the Z80
F901 = DATA EQU OF901H ;transfer register for data
F800 = BUFFER EQU OF800H ;Disk buffer
4A00 = BOOT EQU CCP+1600H ;BOOT address of the BIOS
;
```

190

<!-- TOC PAGE_201: Z80 assembly disk load code -->===========================================================
                      PAGE 201 OF 386                       
===========================================================

191

0000 ORG 0000H ;Z80 reset address

0000 00 NOP ;required by the hardware
0001 110034 LXI D,CCP ;first loading address
0004 3E00 MVI A,O
0006 3204F9 STA DISKNO ;Loading drive A
0009 2601 MVI H,1 ;Start at Track 1, Sector 6
000B 2E06 MVI L,6
000D 7C LOAD1 MOV A,H
000E 3203F9 STA TRACK
0011 7D MOV A,L
0012 3202F9 STA SECTOR
0015 3E00 MVI A,VICRD ;Sector read command
0017 3200F9 STA CMD
001A 3E01 MVI A,OFF
001C 3200CE STA MODESW ;Switch off Z80
001F 00 NOP
0020 3A01F9 LDA DATA ;Transmission OK?
0023 B7 ORA A
0024 C20D00 JNZ LOAD1 ;again if not

; Output '*' for each loaded sector

0027 3E2A MVI A,'*'
0029 3201F9 STA DATA
002C 3E03 MVI A,3 ;Output on screen
002E 3200F9 STA CMD
0031 3E01 MVI A,OFF
0033 3200CE STA MODESW ;handed over to 6510
0036 00 NOP

; transferred read sector into memory

0037 0100F8 LXI B,BUFFER ;BC points to disk buffer

<!-- TOC PAGE_202: Assembly code boot loader -->

===========================================================
                      PAGE 202 OF 386                       
===========================================================

192

003A 0A
LOAD2: LDAX B ;Byte from buffer
003B 12
STAX D ;transfer to memory
003C 0C
INR C
003D 1C
INR E ;increase pointer
003E C23A00
JNZ LOAD2

; Increase track/sector number

0041 14
INR D
0042 2C
INR L ;Increase sector number
0043 7D
MOV A,L ;and in battery

; check for end of track

0044 FE11
CPI 17 ;Sector 17 already reached?
0046 DA4C00
JC LOAD3 ;no
0049 24
INR H ;Increase track number
004A 2E00
MVI L,O ;Sector number to zero
004C 7C
LOAD3: MOV A,H ;Track number in battery

; Done if H points to track 3

004D FE03
CPI3
004F C20D00
JNZ LOAD1 ;read another sector

0052 3AFFF C
LDA IOTYPE ;Upper/lowercase mode
0055 E620
ANI 20H
0057 C25F00
JNZ LOAD4
005A 3E01
MVI A,1
005C 32334A
STA KYBDMD ;Set flag in BIOS

;
LOAD4: ;Jump to the BOOT part of the BIOS
005F C3004A
JMP BOAT

<!-- TOC PAGE_203: CP/M 2.2 BIOS documentation -->

===========================================================
                      PAGE 203 OF 386                       
===========================================================

6.7.4 BIOS FOR CP/M 2.2 ON COMMODORE 64

```txt
COPYRIGHT (C) 1982
COMMODORE INTERNATIONAL
This version has the following features:
1. The BIOS is for a 52K RAM system
with I/O drivers set up via BIOS65
2. Floppy tables and vectors for
2 drives are included
3. The Intel I/O byte is not implemented
4. Punch and reader routines are still there
not implemented
5. Keyboard and function key assignment
are included in BIOS65
6. The Commodore 64 can handle a 20K to 48K CP/M
support (44K with IEEE card)
7. The VC-1541 creates a virtual
Drive B supported
8. With IEC bus a real drive B
supported
```

0000 = BASE EQU 0000H ;Start of addressable RAM

<!-- TOC PAGE_204: CP/M memory configuration code -->

===========================================================
                      PAGE 204 OF 386                       
===========================================================

194

002C = MSIZE EQU 44 ;Memory size of the CP/M in kilobytes
; "BIAS" is the address offset of 3400H for memory
; with more than 20 K (referred to as "B" in the text)
6000 = BIAS EQU (MSIZE-20)*1024
; Note: To generate MOVCPM you need
; The following assignments can be used:
;CCP EQU 0000H ;for BIOSO.HEX
;CCP EQU 0100H ;for BIOS1.HEX
9400 = CCP EQU 3400H+BIAS ;Base of the CCP
9C06 = BDOS EQU CCP+806H ;Base of the BDOS
AA00 = BIOS EQU CCP+1600H ;Base of the BIOS
0004 = CDISK EQU BASE+0004H ;current disk number
; 0..15 equals A..P
0003 = IOBYTE EQU BASE+0003H ;INTEL I/O bytes
0000 = TRANS EQU 0000H ;0 means no translation
0005 = ENTRY EQU 0005H ;BDOS entry vector
; The following assignments define the common
; Memory area for transferring data to and from the
; 6510 I/O routines
F800 = HSTBUF EQU OF800H ;256 byte disk buffer
F900 = CMD EQU OF900H ;Command register
F901 = DATA EQU OF901H ;Data register
F902 = SECTOR EQU OF902H ;Sector register
F903 = TRACK EQU OF903H ;Track register
F904 = DISKNO EQU OF904H ;Register for drive number
F905 = KYCHAR EQU OF905H ;Keyboard code register

<!-- TOC PAGE_205: Z80 assembly I/O configuration code -->===========================================================
                      PAGE 205 OF 386                       
===========================================================

195

FCFF = IOTYPE EQU OFCFFH ;IO configuration byte
; The Z80 switches on by registering
; 'OFF' into the memory cell 'MODESW' itself

0001 = OFF EQU 1
CE00 = MODESW EQU OCE00H
; The following are the commands for the 6510 I/O routines

0000 = VICRD EQU 0 ;Read the specified sector
0001 = VICWR EQU 1 ;Write the specified sector
0002 = VICIN EQU 2 ;keyboard query
0003 = VICOUT EQU 3 ;Output on the screen
0004 = VICPST EQU 4 ;Get printer status
0005 = VICPRT EQU 5 ;Output to printer
0006 = VICFMT EQU 6 ;Format diskette
0007 = AUX1 EQU 7 ;Jump to 6510 address $E00
0008 = AUX2 EQU 8 ;Jump to 6510 address $F00
0009 = INDIR EQU 9 ;Indirect jump over ($906)

AA00 ORG BIOS ;Start this program
0016 = NSECTS EQU ($-CCP)/256 ;Sector counter for warm start

; Jump vectors to the individual routines

AA00 C36CAA JMP BOAT ;cold start
AA03 C31DAB WBOOTE: JMP WBOOT ;warm start
AA06 C39EAB JMP CONST ;Console status
AA09 C30AAC JMP CONIN ;Get characters from console
AAOC C383AC JMP CONOUT ;Character output to console
AAOF C3C8AC JMP LIST ;Character output to LIST unit
AA12 C316AD JMP PUNCH ;Character output on PUNCH unit
AA15 C319AD JMP READER ;Get characters from READER

<!-- TOC PAGE_206: Floppy disk parameter table -->

===========================================================
                      PAGE 206 OF 386                       
===========================================================

196

|  AA18 | C31EAD | JMP | HOME | ;Reading head in HOME position |
| --- | --- | --- | --- | --- |
|  AA1B | C329AD | JMP | ZELDSK | ;Select floppy disk |
|  AA1E | C33DAD | JMP | SETTRK | ;Set track number |
|  AA21 | C343AD | JMP | SETSEC | ;Set sector number |
|  AA24 | C348AD | JMP | SETDMA | ;Set DMA address |
|  AA27 | C351AD | JMP | READ | ;read disk |
|  AA2A | C365AD | JMP | WRITE | ;Write disk |
|  AA2D | C3EBAC | JMP | LISTST | ;Get LIST status |
|  AA30 | C34EAD | JMP | SECTRAN | ;Sector Number Translate |
|   | ; |  |  |   |
|  AA33 | 00 | KYBDMD: | DB | 00H ;Capital mode flag |
|   | ; |  |  |   |
|   | ; | Fixed table for two drives |   |   |
|   | ; | Floppy disk parameter header for floppy disk 0 |   |   |
|  AA34 | 00000000 | DPBASE: | DW | TRANS,0000H |
|  AA38 | 00000000 |  | DW | 0000H,0000H |
|  AA3C | 1FAF54AA |  | DW | DIRBF,DPBLK |
|  AA40 | DDAF9FAF |  | DW | CHKOO,ALLOO |
|   | ; | Floppy Parameters Header for Floppy 1 |   |   |
|  AA44 | 00000000 |  | DW | TRANS,0000H |
|  AA48 | 00000000 |  | DW | 0000H,0000H |
|  AA4C | 1FAF54AA |  | DW | DIRBF,DPBLK |
|  AA50 | EDAFBEAF |  | DW | CHKO1,ALLO1 |
|   | ; |  |  |   |
|   | ; |  |  |   |
|   | ; | DPBLK: ;Floppy disk parameter block, common to all floppy disks |   |   |
|  AA54 | 2200 |  | DW | 34 ;sectors per track |
|  AA56 | 03 |  | DB | 3 ;Block displacement factor |
|  AA57 | 07 |  | DB | 7 ;Block Mask |
|  AA58 | 00 |  | DB | 0 ;zero mask |
|  AA59 | 8700 |  | DW | 135 ;Disk capacity - 1 |
|  AA5B | 3F00 |  | DW | 63 ;max. Directory entries |
|  AA5D | CO |  | DB | 192 ;Allocation 0 |
|  AA5E | 00 |  | DB | 0 ;Allocation 1 |

<!-- TOC PAGE_207: Commodore 64 boot code listing -->===========================================================
                      PAGE 207 OF 386                       
===========================================================

197

AA5F 1000 DW 16 ; checked entries
AA61 0200 DW 2 ;Track Offset

; End of the fixed table

; The following memory area is created at boot time
; initialized

AA63 40 LASTKY: DB 40H ;Vector of the last key pressed
AA64 00 TOGGLE: DB 00H ;Management for uppercase mode
AA65 00 CSTAT: DB 00H ;Flag ready for characters
AA66 0000 MSGPTR: DW 0000H ;Pointer to texts of the function keys
AA68 00FD TBLPTR: DW OFDOOH ;Keyboard decoding table
AA6A 00FC MSGTBL: DW OFCOOH ;Vector for function keys

; Other keyboard definitions

F28D = SHFTST EQU OF28DH ;Control, Commodore and Shift key
FOCC = FLASH EQU OFOCCH ;Turn on cursor
FOCF = CURSOR EQU OFOCFH ;Cursor character

; Individual routines for the individual functions
BOAT:

AA6C 3E20 MVI A,20H ;ASCII spaces
AA6E 32CFFO STA CURSOR ;as cursor character
AA71 AF XRA A ;Delete battery
AA72 320300 STA IOBYTE ;Delete I/O byte
AA75 320400 STA CDISK ;Select disk zero
AA78 321EAF STA CURDSK ;Pointer to virtual diskette
AA7B 3210AF STA HSTACT ;Host buffer inactive
AA7E 3212AF STA UNACNT ;Clear Unallocated counter
AA81 3EC3 MVI A,OC3H ;C3 is the opcode for JUMP
AA83 320000 STA O+BASE ;Jump to WBOOT
AA86 2103AA LXI H,WBOOTE ;WBOOT entry address

<!-- TOC PAGE_208: CP/M bootloader assembly code -->

===========================================================
                      PAGE 208 OF 386                       
===========================================================

198

AA89 220100 SHLD 1+BASE ;set

AA8C 320500 STA 5+BASE ;Jump to BDOS
AA8F 21069C LXI H,BDOS ;BDOS entry address
AA92 220600 SHLD 6+BASE ;set

AA95 018000 LXI B,8OH+BASE ;Default DMA address
AA98 CD48AD CALL SETDMA

AA9B 11A6AA LXI D,SIGNON ;DE points to power-on message
AA9E OE09 MVI C,9 ;String output function
AAAO CD0500 CALL ENTRY ;of the BDOS
AAA3 C38DAB JMP GOCPM1 ;ready for CCP

AAA6 OCOA SIGNON: DB OCH,OAH ;Clear screen
AAA8 2020202043 DB COMMODORE 64 20k CP/M vers 2.2'
AACC ODOAOA DB ODH,OAH,OAH
AACF 2020436F70 DB Copyright (C) 1979, Digital Research',ODH,OAH
AAF7 2020202020 DB Copyright (C) 1982, Commodore',ODH,OAH
AB1B OA24 DB OAH,'$' ;Identifier for end of string

WBOOT:

AB1D 318000 LXI SP,8OH+BASE ;The memory below the buffer
AB20 OE00 MVI C,0 ;Select disk 0
AB22 CD29AD CALL SELDSK
AB25 AF XRA A ;Drive A
AB26 3204F9 STA DISKNO ;select
AB29 CDA5AE CALL CHGDSK ;if not already done
AB2C CD1EAD CALL HOME ;reading head on track 0
AB2F 3EOD MVI A,ODH ;Carriage return
AB31 CDCOAC CALL COUT5 ;output

<!-- TOC PAGE_209: Z80 assembly disk read code -->

===========================================================
                      PAGE 209 OF 386                       
===========================================================

199

|   | ; |  |   |
| --- | --- | --- | --- |
|  AB34 110094 | LXI | D,CCP | ;Start loading |
|  AB37 0616 | MVI | B,NSECTS |   |
|  AB39 2601 | MVI | H,1 | ;Track number |
|  AB3B 2E06 | MVI | L.6 | ;Sector number |
|  AB3D 7C | LOAD1: | MOV | A,H |
|  AB3E 3203F9 | STA | TRACK |   |
|  AB41 7D | MOV | A,L |   |
|  AB42 3202F9 | STA | SECTOR |   |
|  AB45 3E00 | MVI | A,VICRD | ;Command to read floppy disks |
|  AB47 CD94AB | CALL | I06510 |   |
|   | ; |  |   |
|  AB4A 3A01F9 | LDA | DATA |   |
|  AB4D B7 | ORA | A |   |
|  AB4E C23DAB | JNZ | LOAD1 | ;if not null then error |
|  AB51 E5 | PUSH | H |   |
|  AB52 C5 | PUSH | B |   |
|  AB53 010001 | LXI | B,256 |   |
|  AB56 2100F8 | LXI | H,HSTBUF | ;Disk buffer |
|  AB59 ED | DB | OEDH | ;LDIR command of the Z80 |
|  AB5A BO | DB | OBOH |   |
|  AB5B OE2A | MVI | C,’*’ | ;a star is output after each sector |
|  AB5D CD83AC | CALL | CONOUT |   |
|  AB60 C1 | POP | B |   |
|  AB61 E1 | POP | H |   |
|  AB62 05 | DCR | B | ;Decrement sector counter |
|  AB63 CA73AB | JZ | GOCPM |   |
|  AB66 2C | INR | L | ;next sector |
|  AB67 7D | MOV | A,L |   |
|  AB68 FE11 | CPI | 17 |   |
|  AB6A DA3DAB | JC | LOAD1 |   |
|  AB6D 24 | INR | H |   |
|  AB6E 2E00 | MVI | L,O |   |
|  AB70 C33DAB | JMP | LOAD1 |   |

<!-- TOC PAGE_210: CP/M system initialization code -->===========================================================
                      PAGE 210 OF 386                       
===========================================================

200

End of loading operation; Set parameters and jump to CP/M
GOCPM:

AB73 3EC3 MVI A,OC3H ;C3 is the JUMP command
AB75 320000 STA O+BASE ;Jump to WBOOT
AB78 2103AA LXI H,WBOOTE ;WBOOT entry address
AB7B 220100 SHLD 1+BASE ;Set address field for Jump 0

AB7E 320500 STA 5+BASE ;Jump to BDOS
AB81 21069C LXI H,BDOS ;BDOS entry address
AB84 220600 SHLD 6+BASE ;Address field for Jump 5 to BDOS

AB87 018000 LXI B,8OH+BASE ;Default DMA address 8OH
AB8A CD48AD CALL SETDMA

AB8D 3A0400 GOCPM1: LDA CDISK ;Get diskette number
AB90 4F MOV C,A ;to the CCP for more
AB91 C30094 JMP CCP ;Send processing

Main routine for transferring program execution
to the 6510

AB94 3200F9 IO6510: STA CMD ;Battery contents in command register
AB97 3E01 MVI A,OFF
AB99 3200CE STA MODESW ;Switch off Z80
AB9C 00 NOP ;required by the hardware
AB9D C9 RET

CONST: ;Consol status, FFH if character ready, otherwise OOH
AB9E 2A66AA LHLD MSGPTR ;Function key mode?
ABA1 7C MOV A,H

<!-- TOC PAGE_211: Assembly code listing -->

===========================================================
                      PAGE 211 OF 386                       
===========================================================

201

ABA2 B5
ORA
L

ABA3 3EFF
MVI
A, OFFH
;Flag ready for data

ABA5 CO
RNZ
;Return if MSGPTR&lt;&gt;0

;

ABA6 3A65AA
LDA
CSTAT
;another sign yet?

ABA9 A7
ANA
A

ABAA CO
RNZ
;yes if not 0

;

ABAB 3EO2
MVI
A,VICIN
;Get character command

ABAD CD94AB
CALL
IO6510

;

ABBO 3A8DF2
LDA
SHFTST
;Get status of the control keys

ABB3 E602
ANI
02H
;check for Commodore button

FIG5 CAC9AB
JZ
CONSTO
;Jump if not pressed

;

FIG8 3A64AA
LDA
TOGGLE
;Was the button already pressed?

FIG A7
ANA
A

ABBC C2C9AB
JNZ
CONSTO
;no, wait until released

;

ABBF 3A33AA
LDA
KYBDMD
;Get flag for uppercase mode

ABC2 EEO1
XRI
01H
;Flip mode bit

ABC4 3233AA
STA
KYBDMD

ABC7 3EO1
MVI
A,1

ABC9 3264AA
CONSTO: STA
TOGGLE

;

ABCC 3AO5F9
LDA
KYCHAR
;Get characters

ABCF FE3A
CPI
3AH
;invalid control character

ABD1 CAEOAB
JZ
CONST1

;

ABD4 FE3D
CPI
3DH
;invalid control character

ABD6 CAEOAB
JZ
CONST1

;

ABD9 2163AA
LXI
H,LASTKY
;compare with last key

ABDC BE
CMP
M
;Check data

<!-- TOC PAGE_212: Assembly code keyboard handling routine -->

===========================================================
                      PAGE 212 OF 386                       
===========================================================

202

ABDD C2E5AB JNZ CONST2 ;if different then new key
;
ABEO AF CONST1: XRA A ;Flag ready for no data
ABE1 3265AA STA CSTAT ;remember for later
ABE4 C9 RET
;
ABE5 F5 CONST2: PUSH PSW
ABE6 01F401 LXI B,500
ABE9 OB CONST3: DCX B ;Delay for keyboard debounce
ABEA 79 MOV A,C
ABEB BO ORA B
ABEC C2E9AB JNZ CONST3
;
ABEF 3EO2 MVI A,VICIN ;get another character
ABF1 CD94AB CALL I06510
;
ABF4 F1 POP PSW
ABF5 2105F9 LXI H,KYCHAR
ABF8 BE CMP M
ABF9 C2EOAB JNZ CONST1 ;if not 0, key has not bounced
;
ABFC 3263AA STA LASTKY ;update last key
ABFF FE40 CPI 40H ;40H means no key pressed
ACO1 CAEOAB JZ CONST1
;
ACO4 3EFF MVI A,OFFH ;Flag ready for characters
ACO6 3265AA STA CSTAT ;remember for later
ACO9 C9 RET
;
CONIN: ;Get characters from console into register A
ACOA 3EO0 MVI A,O ;Switch on cursor
ACOC 32CCFO STA FLASH
;
ACOF 2A66AA LHLD MSGPTR ;Function key mode ?

<!-- TOC PAGE_213: Assembly code listing -->===========================================================
                      PAGE 213 OF 386                       
===========================================================

203

AC12 7C MOV A,H
AC13 B5 ORA L
AC14 C25FAC JNZ CONIN5

AC17 CD9EAB CONIN1: CALL CONST ;Check console status
AC1A B7 ORA A
AC1B CA17AC JZ CONIN1 ;wait for new character

AC1E AF XRA A
AC1F 3265AA STA CSTAT ;Clear status
AC22 3A33AA CONIN2: LDA KYBDMD ;without shift=0, capital=1
AC25 47 MOV B,A
AC26 3A8DF2 LDA SHFTST ;Get status for Shift/Ctrl
AC29 E601 ANI 01H ;is the shift key pressed?
AC2B CA30AC JZ CONIN3 ;Jump if not

AC2E 0602 MVI B,2 ;Shift=2
AC30 3A8DF2 CONIN3: LDA SHFTST ;Get status
AC33 E604 ANI 04H ;is the control button pressed?
AC35 CA3AAC JZ CONIN4 ;Jump if not

AC38 0603 MVI B,3 ;Control=3
AC3A 3A63AA CONIN4: LDA LASTKY ;Get key number
AC3D 87 ADD A ;*2
AC3E 87 ADD A ;*4
AC3F 80 ADD B ;Add number
AC40 2A68AA LHL D TBLPTR ;Keyboard table address
AC43 85 ADD L ;Pointer in table
AC44 6F MOV L,A
AC45 3E00 MVI A,O
AC47 8C ADC H
AC48 67 MOV H,A
AC49 7E MOV A,M ;Get characters from table

<!-- TOC PAGE_214: Assembly code listing page -->

===========================================================
                      PAGE 214 OF 386                       
===========================================================

204

|  AC4A FE80 | CPI | 80H | ;If >7FH then function key |
| --- | --- | --- | --- |
|  AC4C DA71AC | JC | CONIN7 | ;Jump if ASCII character |
|   | ; |  |   |
|  AC4F 2A6AAA | LHLD | MSGTBL | ;Start the text table |
|  AC52 E67F | ANI | 7FH | ;Delete bit 7 |
|  AC54 87 | ADD | A | ;*2 |
|  AC55 85 | ADD | L | ;pointer in table |
|  AC56 6F | MOV | L,A |   |
|  AC57 3E00 | MVI | A,O |   |
|  AC59 8C | ADC | H |   |
|  AC5A 67 | MOV | H,A |   |
|  AC5B 7E | MOV | A,M | ;Lo Byte |
|  AC5C 23 | INX | H |   |
|  AC5D 66 | MOV | H,M | ;Hi Byte |
|  AC5E 6F | MOV | L,A |   |
|  AC5F 46 | CONIN5: MOV | B,M | ;get characters |
|  AC60 23 | INX | H | ;check next character |
|  AC61 7E | MOV | A,M |   |
|  AC62 A7 | ANA | A |   |
|  AC63 C269AC | JNZ | CONIN6 | ;if 0 is the last character | in B
|   | ; |  |   |
|  AC66 210000 | LXI | H,0000H | ;End of text mode |
|  AC69 2266AA | CONIN6: SHLD | MSGPTR | ;Remember pointer to text |
|  AC6C 78 | MOV | A,B | ;Check characters |
|  AC6D A7 | ANA | A | ;is the first one already 0?  |
|  AC6E CA17AC | JZ | CONIN1 | ;if 0 then no character |
|   | ; |  |   |
|  AC71 F5 | CONIN7: PUSH | PSW | ;Remember characters |
|  AC72 3E01 | MVI | A,1 |   |
|  AC74 32CCFO | STA | FLASH | ;Turn off cursor |
|  AC77 OE20 | MVI | C,' | ;space |
|  AC79 CD83AC | CALL | CONOUT | ;output |
|  AC7C 3E9D | MVI | A.9DH | ;Cursor left |
|  AC7E CDCOAC | CALL | COUT5 | ;Skip filter |

<!-- TOC PAGE_215: Assembly code console output routine -->

===========================================================
                      PAGE 215 OF 386                       
===========================================================

205

AC81 F1 POP PSW ;Retrieve character
AC82 C9 RET ;done

CONOUT: ;Output characters from register C to console

AC83 3AFFFC LDA IOTYPE ;Configuration byte
AC86 E610 ANI 10H ;Bit 4 = 1 means ignore filter
AC88 79 MOV A,C ;Character in battery
AC89 C2COAC JNZ COUT5 ;output as received

AC8C CDF4AC CALL SWAP ;Swap uppercase and lowercase letters
AC8F FEOC CPI OCH ;Clear ASCII characters for screen?
AC91 C299AC JNZ COUT1 ;Jump if not

AC94 3E93 MVI A,93H ;Clear Commodore code for screen
AC96 C3COAC JMP COUT5

AC99 FE08 COUT1: CPI 08H ;ASCII backspace (backspace)
AC9B C2A3AC JNZ COUT2 ;Jump if not

AC9E 3E14 MVI A,14H ;Delete commodore code for characters
ACAO C3COAC JMP COUT5

ACA3 FEOA COUT2: CPI OAH ;Line Feed ?
ACA5 C2ADAC JNZ COUT3

ACA8 3E11 MVI A,17 ; Commodore code for line feed
ACAA C3COAC JMP COUT5

ACAD FEOD COUT3: CPI ODH ;Carriage Return ?
ACAF C2BAAC JNZ COUT4

ACB2 CDCOAC CALL COUT5
ACB5 3E91 MVI A,145 ;one line up to auto LF
ACB7 C3COAC JMP COUT5 ;ignore

<!-- TOC PAGE_216: Assembly code listing -->===========================================================
                      PAGE 216 OF 386                       
===========================================================

206

ACBA FE20
ACBC D8
ACBD FE80
ACBF DO

COUT4: CPI 20H
RC ;Return if other control character
CPI 80H
RNC ;Return if not an ASCII character

ACCO 3201F9
ACC3 3E03
ACC5 C394AB

COUT5: STA DATA ;Character passed in DATA
AVI A,VICOUT ;Command for screen output
JMP I06510

LIST: ;Send characters from register C to the LIST unit

ACC8 3AFFFC
ACCB E604
ACCD 79
ACCE C2E3AC

LDA IOTYPE ;Which printer type?
ANI 04H ;0 if 1515, 1 if 4022
MOV A,C ;Characters in register A
JNZ LIST2 ;skip if not swapped

ACD1 3AFFFC
ACD4 E608
ACD6 79
ACD7 C2E0AC

LDA IOTYPE
ANI 08H ;what type of swap?
MOV A,C ;Get characters
JNZ LIST1

ACDA CDF4AC
ACDD C3E3AC

CALL SWAP ;Swap uppercase and lowercase letters
JMP LIST2

ACEO CD08AD
ACE3 3201F9
ACE6 3E05
ACE8 C394AB

LIST1: CALL SWAP2 ;Swap routine for 4022
LIST2: STA DATA ;Pass characters
MVI A,VICPRT ;1515 accept
LIST3: JMP I06510

LISTST: ;List status (0 if not ready, 1 is ready)

ACEB 3E04
ACED CD94AB
ACFO 3A01F9
ACF3C9

MVI A,VICPST ;Command for printer status
CALL I06510
LDA DATA ;DATA is the status
RET

<!-- TOC PAGE_217: Commodore 64 assembly code -->

===========================================================
                      PAGE 217 OF 386                       
===========================================================

207

SWAP: ;Swap uppercase and lowercase letters for Commodore 64

ACF4 FE41 CPI 41H ;smaller than capital 'A'?
ACF6 D8 RC ;Return if yes

ACF7 FE5B CPI 5BH ;Capital letter ?
ACF9 DA05AD JC SWAP1 ;Jump if yes

ACFC FE61 CPI 61H ;less than small 'A'
ACFE D8 RC ;Return if yes

ACFF FE7B CPI 7BH ;lowercase letter ?
AD01 DO RNC ;Return if not

AD02 E65F ANI 5FH ;Delete bit 5
AD04 C9 RET

AD05 F620 SWAP1: ORI 20H ;Set bit 5
AD07 C9 RET

AD08 FE41 SWAP2: CPI 41H ;CY if smaller than capital 'A'
AD0A D8 RC
AD0B FE60 CPI 60H ;CY if 40H &lt; A &lt; 60H
AD0D D213AD JNC SWAP3

AD10 F680 ORI 80H
AD12 C9 RET

AD13 E65F SWAP3: ANI 5FH
AD15 C9 RET

PUNCH: ;Character from register C to the PUNCH unit
AD16 79 MOV A,C ;Characters in register
AD17 00 NOP

<!-- TOC PAGE_218: CP/M disk sector constants table -->

===========================================================
                      PAGE 218 OF 386                       
===========================================================

AD18 C9 RET ;Zero routine

;

;

READER: ;Character from READER unit to register A

AD19 3E1A MVI A,1AH ;Return End Of File Code (CTRL Z).

AD1B E67F ANI 7FH ;Delete parity bit

AD1D C9 RET

;

;

;

;

;

;

;

CONSTANT HOST DISK TO CP/M

;

;

0400 = BLKSIZ EQU 1024 ;CP/M allocation size

0100 = HSTSIZ EQU 256 ;Host disk sector size

0011 = HSTSPT EQU 17 ;Host disk sectors/track

0002 = HSTBLK EQU HSTSIZ/128 ;CP/M sectors/host buffer

0022 = CPMSPT EQU HSTBLK * HSTSPT ;CP/M sectors/track

0001 = SECMSK EQU HSTBLK-1 ;Sector mask

0001 = SECSHF EQU 1 ;LOG2(HSTBLK)

;

;

;

BDOS CONSTANTS ON WRITE ENTRY

;

;

0000 = WRALL EQU 0 ;WRITE to Allocated

0001 = WRDIR EQU 1 ;WRITE to Directory

0002 = WRUAL EQU 2 ;WRITE to Unallocated

;

HOME function of the selected diskette

HOME:

AD1E 3A11AF LDA HSTWRT ;Check for WRITE

<!-- TOC PAGE_219: Assembly code disk selection -->

===========================================================
                      PAGE 219 OF 386                       
===========================================================

209

AD21 B7 ORA A
AD22 C228AD JNZ HOMED
AD25 3210AF STA HSTACT ;Clear host active flag

HOMED:
AD28 C9 RET

SELDSK:
;Select floppy disk

AD29 210000 LXI H,0000H ;Return code error
AD2C 79 MOV A,C ;Number of the selected diskette
AD2D 3207AF STA SEKDSK ;Remember diskette number
AD30 FEO2 CPI 2 ;must be 0 or 1
AD32 DO RNC ;no carry if larger1
AD33 6F MOV L,A ;Floppy disk number according to HL
AD34 29 DAD H ;multiply by 16
AD35 29 DAD H
AD36 29 DAD H
AD37 29 DAD H
AD38 1134AA LXI D,DPBASE ;Base of the parameter blocks
AD3B 19 DAD D ;HL=DPB
AD3C C9 RET

SETTRK:
;Set track number from register BC

AD3D 60 MOV H,B
AD3E 69 MOV L,C
AD3F 2208AF SHLD SEKTRK ;track to search
AD42 C9 RET

SETSEC:
;Set sector number from register C

AD43 79 MOV A,C
AD44 320AAF STA SEKSEC ;Sector to search
AD47 C9 RET

<!-- TOC PAGE_220: CP/M disk read/write assembly code -->===========================================================
                      PAGE 220 OF 386                       
===========================================================

210

SETDMA:
;Set DMA address from register BC
AD48 60 MOV H,B
AD49 69 MOV L,C
AD4A 221BAF SHLD DMAADR
AD4D C9 RET

SECTRAN:
;Translate sector number from register BC
AD4E 60 MOV H,B
AD4F 69 MOV L,C
AD50 C9 RET

;
;
;
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;
; * THE READ JUMP POINT FOLLOWS THIS
; * PREVIOUS BIOS DEFINITION FOR READ
;
;
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

READ:
;Read the selected CP/M sector
AD51 AF XRA A
AD52 3212AF STA UNACNT
AD55 3E01 MVI A,1
AD57 3219AF STA READOP ;READ Operation
AD5A 3218AF STA RSFLAG ;Read data
AD5D 3E02 MVI A,WRUAL
AD5F 321AAF STA WRTYPE ;treat as Unallocated
AD62 C3DOAD JMP RWOPER ;Execute READ command

;
;
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; THE WRITE ENTRY POINT FOLLOWS THIS

<!-- TOC PAGE_221: Assembly code for disk write -->

===========================================================
                      PAGE 221 OF 386                       
===========================================================

211

;* PREVIOUS BIOS DEFINITIONS FOR WRITE *
;*
WRITE:

;Write the selected sector

AD65 AF XRA A ;O into the battery
AD66 3219AF STA READOP ;no READ command
AD69 79 MOV A,C ;WRITE Type to C
AD6A 321AAF STA WRTYPE
AD6D FEO2 CPI WRUAL ;WRITE Unallocated?
AD6F C289AD JNZ CHKUNA ;Check for Unallocated

; WRITE Unallocted, set parameters

AD72 3EO8 MVI A,BLKSIZ/128 ;next unallocated record
AD74 3212AF STA UNACNT
AD77 3AO7AF LDA SEKDSK ;floppy disk
AD7A 3213AF STA UNADSK ;UNADSK = SEKDSK
AD7D 2AO8AF LHLD SEKTRK
AD80 2214AF SHLD UNATRK ;UNATRK = SECTRK
AD83 3AOAAF LDA SEKSEC
AD86 3216AF STA UNASEC ;UNASEC = SEKSEC

CHKUNA:

;Check for WRITE to Unallocated sector

AD89 3A12AF LDA UNACNT ;UNALLOC left?
AD8C B7 ORA A
AD8D CAC8AD JZ ALLOC ;Jump if not

; More Unallocated Records left

AD90 3D DCR A ;UNACNT = UNACNT-1
AD91 3212AF STA UNACNT
AD94 3AO7AF LDA SEKDSK ;same diskette?
AD97 2113AF LXI H,UNADSK
AD9A BE CMP M ;SEKDSK = UNADSK?

<!-- TOC PAGE_222: CP/M disk allocation code snippet -->

===========================================================
                      PAGE 222 OF 386                       
===========================================================

212

AD9B C2C8AD
JNZ ALLOC ;Jump if not

; Same disks

AD9E 2114AF
LXI H,UNATRK

ADA1CD6BAE
CALL TRKCMP ;SEKTRK = UNATRK?

ADA4 C2C8AD
JNZ ALLOC ;Jump if not

; Same tracks

ADA7 3AOAAF
LDA SEKSEC ;same sector?

ADAA 2116AF
LXI H,UNASEC

ADAD BE
CMP M ;SEKSEC = UNASEC?

ADAE C2C8AD
JNZ ALLOC ;Jump if not

; Appropriate, next sector for future access

ADB1 34
INR M ;UNASEC = UNASEC+1

ADB2 7E
MOV A,M ;End of track?

ADB3 FE22
CPI CPMSPT ;CP/M sector counter

ADB5 DAC1AD
JC NOOVF ;Jump if no carry

; Carry over to next track

ADB8 3600
MVI M,O ;UNASEC = O

ADBA 2A14AF
LHLD UNATRK

ADBD 23
INX H

ADBE 2214AF
SHLD UNATRK ;UNATRK = UNATRK+1

NOOVF:
;Match, mark as unnecessary reading

ADC1 AF
XRA A ;O in battery

ADC2 3218AF
STA RSFLAG ;RSFLAG = O

ADC5 C3DOAD
JMP RWOPER ;for WRITE

; ALLOC:
;no unallocated record, requires prior reading

ADC8 AF
XRA A ;O in battery

<!-- TOC PAGE_223: Assembly code snippet -->===========================================================
                      PAGE 223 OF 386                       
===========================================================

ADC9 3212AF STA UNACNT ;UNACNT = 0
ADCC 3C INR A ;1 in battery
ADCD 3218AF STA RSFLAG ;RSFLAG = 1

;

;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;
;

;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;



<!-- TOC PAGE_224: Disk sector verification code -->

===========================================================
                      PAGE 224 OF 386                       
===========================================================

214

ADF6 C203AE
JNZ NOMTCH

; Same disk, same track, same buffer?
ADF9 3A0FAF
LDA SEKHST
ADFC 210EAF
LXI H,HSTSEC
;SEKHST = HSTSEC?
ADFF BE
CMP M
AE00 CA27AE
JZ MATCH
;Jump if match

; NOMTCH:
;Correct disk, but wrong sector

AE03 3A11AF
LDA HSTWRT
;host written?
AE06 B7
ORA A
AE07 C477AE
CNZ WRHST
;Clear host buffer

; FEEL:
;Fill host buffer

AE0A 3A07AF
LDA SEKDSK
AEOD 320BAF
STA HSTDSK
AE10 2A08AF
LHLD SEKTRK
AE13 220CAF
SHLD HSTTRK
AE16 3A0FAF
LDA SEKHST
AE19 320EAF
STA HSTSEC
AE1C 3A18AF
LDA RSFLAG
;READ required?
AE1F B7
ORA A
AE20 C4CAAE
CNZ RDHST
;yes, in 1
AE23 AF
XRA A
;Delete battery
AE24 3211AF
STA HSTWRT
;no WRITE

; MATCH:
;Copy data to or from the buffer

AE27 3A0AAF
LDA SEKSEC
;Number of the mask buffer
AE2A E601
ANI SECMSK
;isolate lowest bits
AE2C 6F
MOV L,A
;for to move
AE2D 2600
MVI H,O
;2 byte counter

<!-- TOC PAGE_225: Assembly code data transfer -->

===========================================================
                      PAGE 225 OF 386                       
===========================================================

215

AE2F 29 DAD H ;slide seven to the left
AE30 29 DAD H
AE31 29 DAD H
AE32 29 DAD H
AE33 29 DAD H
AE34 29 DAD H
AE35 29 DAD H

; HL contains relative host buffer address
AE36 1100F8 LXI D,HSTBUF
AE39 19 DAD D ;HL = host address
AE3A EB XCHG ; now in DE
AE3B 2A1BAF LHLD DMAADR ;Get/Write CP/M data
AE3E OE80 MVI C,128 ;Number of surface areas
AE40 3A19AF LDA READOP ;which direction
AE43 B7 ORA A
AE44 C24DAE JNZ RWMOVE ;Skip if reading

; Mark WRITE operation and swap direction
AE47 3EO1 MVI A,1
AE49 3211AF STA HSTWRT ;HSTWRT = 1
AE4C EB XCHG ;Swap source/destination

; RWMOVE:

;C contains 128, DE is source, HL is destination
AE4D 1A LDAX D ;Character from source area
AE4E 13 INX D
AE4F 77 MOV M,A ;Transfer to target area
AE50 23 INX H
AE51 OD DCR C ;128 times
AE52 C24DAE JNZ RWMOVE

; Data is transferred from/to the host buffer
AE55 3A1AAF LDA WRTYPE ;WRITE Type ?
AE58 FEO1 CPI WRDIR ;ins Directory ?

<!-- TOC PAGE_226: Assembly code error handling routine -->

===========================================================
                      PAGE 226 OF 386                       
===========================================================

216

AE5A 3A17AF
LDA SUCCESS ;if error

AE5D CO
RNZ ;no further processing

; Host buffer for WRITE in Directory

AE5E B7
ORA A ;Error?

AE5F CO
RNZ ;yes, then done

AE60 AF
XRA A ;Delete battery

AE61 3211AF
STA HSTWRT ;Buffer written

AE64 CD77AE
CALL WRHST

AE67 3A17AF
LDA SUCCESSED

AE6A C9
RET

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; * * AUXILIARY ROUTINE FOR 16-BIT COMPARISON * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

TRKCMP:
;HL = .UNATRK or .HSTTRK, compare with SEKTRK

AE6B EB
XCHG

AE6C 2108AF
LXI H,SEKTRK

AE6F 1A
LDAX D ;Compare lo bytes

AE70 BE
CMP M ;same

AE71 CO
RNZ ;Return if not

; Lo Byte same, test Hi Byte

AE72 13
INX D

AE73 23
INX H

AE74 1A
LDAX D

AE75 BE
CMP M ;set flags

AE76 C9
RET

<!-- TOC PAGE_227: Disk write subroutine code -->===========================================================
                      PAGE 227 OF 386                       
===========================================================

217

WRHST:
;HSTDSK = host diskettes#, HSTTRK = hosttrack #,
;HSTSEC = Hostsector#. Writes "HSTSIZ" bytes
;of the HSTBUF and returns error flag in ERFLAG
;SUCCESS non-zero if error

AE77 3EO1 MVI A,VICWR ;Disk write command
AE79 321DAF WRHSTO: STA RW ;write to command register
AE7C 3AOBAF LDA HSTDSK ;Get host diskette number
AE7F 3204F9 STA DISKNO ;and set
AE82 CDA5AE CALL CHGDSK ;correct virtual disk?
AE85 3AOCAF WRHST2: LDA HSTTRK ;Get host track number
AE88 3C INR A ;add one as offset
AE89 FE12 CPI 18 ;we want to skip track 18
AE8B DA8FAE JC WRHST3 ;Carry falls Track&lt;18
AE8E 3C INR A

AE8F 3203F9 WRHST3: STA TRACK ;write to common area
AE92 3AOEAF LDA HSTSEC ;Get host sector number
AE95 3202F9 STA SECTOR ;write to common area
AE98 3A1DAF LDA RW ;Disk command
AE9B CD94AB CALL IO6510
AE9E 3A01F9 LDA DATA ;Get disk status
AEA1 3217AF STA SUCCESS ;and save as SUCCESS
AEA4 C9 RET

AEAS 67 CHGDSK: MOV H,A ;Remember the disk number
AEA6 3AFFFC LDA IOTYPE ;Bit 0=0 for virtual
AEA9 E601 ANI 01

<!-- TOC PAGE_228: Assembly code disk operation -->

===========================================================
                      PAGE 228 OF 386                       
===========================================================

218

|  AEAB CO |  | RNZ |  | ;not 0 if 2 drives |
| --- | --- | --- | --- | --- |
|  AEAC 3204F9 |  | STA | DISKNO | ;Set drive A |
|  AEAF 7C |  | MOV | A,H | ;Recover disk number |
|   | ; |  |  |   |
|  AEBO 211EAF |  | LXI | H,CURDSK | ;is this our disk?  |
|  AEB3 BE |  | CMP | M |   |
|  AEB4 C8 |  | RZ |  | ;Return if yes |
|   | ; |  |  |   |
|  AEB5 77 |  | MOV | M,A | ;set new diskette number |
|  AEB6 C641 |  | FDI | 'A' | ;Create ASCII characters |
|  AEB8 32DDAE |  | STA | DSKMNT | ;insert in message |
|   | ; |  |  |   |
|  AEBB 21CFAE |  | LXI | H,MNTMSG | ; 'Insert Disk' message |
|  AEBE CDFAAE |  | CALL | PMSG | ;output |
|  AEC1 CDOAAC | CHGD1: | CALL | CONIN | ;wait for return |
|  AEC4 FEOD |  | CPI | ODH |   |
|  AEC6 C2C1AE |  | JNZ | CHGD1 |   |
|  AEC9 C9 |  | RET |  |   |
|   | ; |  |  |   |
|   | RDHST: |  |  |   |
|   |  | ;HSTDSK = Hostdisk #, HSTTRK = Hosttrack #, |   |   |
|   |  | ;HSTSEC = host sector #. Read "HSHSIZ" bytes |   |   |
|   |  | ;in HSTBUF and set error flag after ERFLAG |   |   |
|  AECA 3E00 |  | MVI | A,VICRD | ;Floppy disk READ command |
|  AECC C379AE |  | JMP | WRHSTO | ;Rest as with DISK WRITE |
|   | ; |  |  |   |
|  AECF ODOA496E73MNTMSG: | DB | ODH,OAH,'Insert disk ' |   |   |
|  AEDD 41 | DSKMNT: | DB | 'A' |   |
|  AEDE 20696E746F |  | DB | ' into drive O, press return' |   |
|  AEF9 00 |  | DB | OOH |   |
|   | ; |  |  |   |
|  AEFA 7E | PMSG: | MOV | A,M |   |
|  AEFB A7 |  | ANA | A |   |
|  AEFC C8 |  | RZ |  |   |

<!-- TOC PAGE_229: Assembly code memory map -->

===========================================================
                      PAGE 229 OF 386                       
===========================================================

219

|  AEFD E5 | PUSH | H |
| --- | --- | --- |
|  AEFE 4F | MOV | C,A |
|  AEFF CD83AC | CALL | CONOUT |
|  AFO2 E1 | POP | H |
|  AFO3 23 | INX | H |
|  AFO4 C3FAAE | JMP | PMSG |
|  ;  |
| --- |
|  ;  |
|  ;  |
|  ;  |
|  ;  |
|  ;  |
|  AF07 | SEKDSK: DS | 1 | ;SEEK disk number |
| --- | --- | --- | --- |
|  AF08 | SEKTRK: DS | 2 | ;SEEK track number |
|  AF0A | SEKSEC: DS | 1 | ;SEEK sector number |
|  AFOB | HSTDSK:DS | 1 | ;HOST disk number |
| --- | --- | --- | --- |
|  AFOC | HSTTRK: DS | 2 | ;HOST track number |
|  AFOE | HSTSEC:DS | 1 | ;HOST sector number |
|  AFOF | SEKHST: DS | 1 | ;SEEK Shift right SECSHF |
| --- | --- | --- | --- |
|  AF10 | HSTACT:DS | 1 | ;HOST Active Flag |
|  AF11 | HSTWRT: DS | 1 | ;HOST Written Flag |
|  AF12 | UNACNT: DS | 1 | ;UNALLOC record counter |
| --- | --- | --- | --- |
|  AF13 | UNADSK: DS | 1 | ;Last UNALLOC disk |
|  AF14 | UNATRK: DS | 2 | ;Last UNALLOC Track |
|  AF16 | UNASEC:DS | 1 | ;Last UNALLOC sector |
|  AF17 | SUCCESS: DS | 1 | ;error flag |
| --- | --- | --- | --- |
|  AF18 | RSFLAG: DS | 1 | ;READ sector flag |
|  AF19 | READOP: DS | 1 | ;1 for READ operation |
|  AF1A | WRTYPE: DS | 1 | ;WRITE Operation |

<!-- TOC PAGE_230: Memory allocation data structure -->===========================================================
                      PAGE 230 OF 386                       
===========================================================

220

|  AF1B | DMAADR: DS | 2 | ;Last DMA address |
| --- | --- | --- | --- |
|  AF1D | RW: DS | 1 | ;Temporary command register |
|  AF1E | CURDSK: DS | 1 | ;Virtual floppy disk pointer |
|   | ; |  |   |
|   | ; RAM for BDOS |  |   |
|  AF1F = | BEGDAT EQU | $| ;Start of data area |
|  AF1F | DIRBF:DS | 128 | ;Area for Directory |
|  AF9F | ALLOO: DS | 31 | ;Allocation vector 0 |
|  AFBE | ALLO1:DS | 31 | ;Allocation vector 1 |
|  AFDD | CHKOO: DS | 16 | ;Check vector 0 |
|  AFED | CHKO1:DS | 16 | ;Check Vector 1 |
|   | ; |  |   |
|  AFFD = | ENDDAT EQU | $| ;End of data area |
|  OODE = | DATSIZ EQU | $-BEGDAT; | Data area size |
|  AFFD | END |  |   |

<!-- TOC PAGE_231: BIOS custom I/O function guide -->

===========================================================
                      PAGE 231 OF 386                       
===========================================================

6.8 IMPLEMENTATION OF YOUR OWN INPUT/OUTPUT FUNCTIONS IN THE BIOS

If we look at the BIOS listing in the previous chapter, we can see that only the jump vectors exist for the PUNCH and READER routines, but the actual routines only consist of a return command. The READER routine simply returns Control Z, the end of text file flag. Here we can now incorporate our own routines. The PUNCH routine could, for example, support a printer with a Centronics interface, as is similarly described in Chapter 7.1. The driver routine itself can be formulated in 6510 code. To address the routines, we can use the previously unused command codes 7 and 8, which branch to the 6510 address $E00 and $F00, respectively. The call could, for example, look like this:

```
PUNCH: ;Output character on PUN: Centronics printer
MOV A,C ;Character in battery
STA DATA ;in transfer register
MVI A,7 ;Code for your own routine
STA CMD
CALL I06510 ;Call 6510 routine
RET
```

Our 6510 output routine should then start at address $E00; There are 256 bytes available for this. Since only the routine for outputting the data to the port and for the handshake is required, you will certainly have enough storage space available.

The READER routine can also be implemented in a similar way.

<!-- TOC PAGE_232: CP/M BIOS input routine code -->

===========================================================
                      PAGE 232 OF 386                       
===========================================================

222

READER: get ;sign from RDR:

MVI A,8 ;Code for your own routine
STA CMD
CALL IO6510 ;Call 6510 routine
LDA DATA ;Get characters
ANI 7FH ;Clear parity bit
RET

Command code 8 expects the input routine from address $F00; Here too you have 256 bytes available. As RDR: you can define any input device, e.g. the cassette recorder or a floppy disk drive. A V24 interface would also be ideal here for transferring data from other computers. The READER routine expects text files in standard ASCII format. The end of the file is generally marked with Control Z. For example, the PIP program expects this code at the end of the file.

This means you can operate your own input or output devices from the CP/M as you wish if you implement the routines in the BIOS as described above.

<!-- TOC PAGE_233: CP/M to Commodore 64 transfer guide -->===========================================================
                      PAGE 233 OF 386                       
===========================================================

223

# 6.9 TRANSFER OF CP/M PROGRAMS AND DATA INTO COMMODORE-BASIC AND VICE VERSA

If you work on the Commodore 64 under CP/M, you usually have no option to later use programs or data, e.g. text files, in the normal BASIC mode of the Commodore 64. These files can only be accessed in CP/M mode. However, this is possible with a small change in BIOS65.

You can output data to the printer in the CP/M. This output occurs in BIOS65 via the corresponding OPEN and PRINT# commands. We can now intervene here and simply change the device number in the OPEN command. If you put the number one here, all output that would otherwise go to the printer goes to the cassette recorder. We also need to specify a secondary address so that the tape file is opened for writing. We can easily make these changes from CP/M using the DDT program. To do this, enter the following commands (your entries are underlined):

```
DDT
-SFAC7
FAC7 07 01
FAC8 20
-SFADD
FADD 00 01
FADE A9
-SFAE6
FAE6 04 01
FAE7 20
-^C
```

<!-- TOC PAGE_234: Commodore data transfer instructions -->

===========================================================
                      PAGE 234 OF 386                       
===========================================================

If you now make an output with `P or PIP LST:=, the printer will no longer be addressed, but the cassette drive. The first time, the prompt 'press record &amp; play on tape' and the screen goes dark. Once all text has been output, please press Control C and then STOP and RESTORE at the same time during the warm start. The computer now reports 'ready' again in Commodore mode. Now you have to close the tape file with CLOSE 4. You can now read the tape file after turning the computer off and on again:

```
100 OPEN 1
110 GET#1, A$
...
200 IF ST&lt;&gt;64 THEN 110
210 CLOSE 1
```

The program fetches the file character by character in A$ and you can edit the data in Commodore mode.

If you want to transfer data from the CP/M more often, you can use the editor (ED) and the assembler (ASM) to write a small program that makes the changes so that you don't always have to work with the DDT. Using the editor, create the following small assembly program,

```
ED BAND.ASM
```

```
ORG 100H
MVI A,1
STA OFAC7H
STA OFADFH
STA OFAE6H
JMP O
```

224

<!-- TOC PAGE_235: Commodore to CP/M data transfer guide -->

===========================================================
                      PAGE 235 OF 386                       
===========================================================

and assemble it

ASM BAND.AAX

Then make it a .COM file

LOAD BAND

Now you can easily make the switch by calling the BAND program by entering the name.

The opposite way, transferring data from Commodore mode to the CP/M, is also possible with a trick. For example, if you want to transfer text or a program, you must first make it a program file with a load address of $1100. This is Z80 address 100H, the start of the Transient Program Area (TPA). If you want to transfer text from a sequential file, you can proceed as follows:

100 INPUT "FILE NAME ";N$
110 OPEN 2,8,2, N$
120 OPEN 1,8,1, N$+".CPM": OPEN REM PROGRAM FILE
130 PRINT#1, CHR$(0)CHR$(17);:REM START ADDRESS $1100
140 GET#2, A$:IF ST=64 THEN CLOSE 1:CLOSE 2: END
150 PRINT#1, A$: GOTO 140

Before we can load the program, we need to know the size. To do this, load the table of contents on the diskette. You get e.g

...

25 NAME.CPM PRG

...

225

<!-- TOC PAGE_236: CP/M file transfer instructions -->===========================================================
                      PAGE 236 OF 386                       
===========================================================

We have to remember the number 25. Now we load the program file.

LOAD "NAME.CPM",8.1

Now insert the CP/M disk and boot as usual. When the CP/M is loaded, we can save the file under CP/M.

SAVE 25 NAME.TXT

The number 25 indicates the number of 256-byte blocks to be stored and is identical to the block number in the Commodore directory. Now we have the file available under CP/M and can use it. Text files may have problems with lowercase/uppercase letters. If this is the case, you will need to perform an eventual conversion from A$ on line 140 of the program above to get the standard ASCII code.

226

<!-- TOC PAGE_237: Commodore 64 technical manual chapter -->

===========================================================
                      PAGE 237 OF 386                       
===========================================================

227

# CHAPTER 7 CONNECTION AND EXPANSION OPTIONS OF THE COMMODORE 64

## 7.1 A USEFUL USE OF THE USER PORT: INTERFACE FOR A CENTRONICS PRINTER

The Commodore 64 has an interface that is not normally used by the operating system and is available to you for your own applications. This interface consists of an 8-bit port and two handshake lines. The 8-bit port can be switched to both output and input, independently for each bit.

This interface is ideal for implementing a printer interface. Since most printers have a Centronics interface as standard (e.g. Epson printers, Centronics printers), we want to implement this interface. In addition, this interface is particularly easy to use. Here is the procedure in brief:

The 8 bits of a byte are simultaneously transmitted in parallel over eight data lines. To ensure that no data is lost during transmission, two so-called 'handshake lines' are used. Before the computer sends a byte of data to the printer, it checks whether the printer is ready to receive data. This is done via the BUSY line. If the BUSY line is high, the printer is busy and the computer has to wait. When the printer is ready, the computer places the data on the port and signals this to the printer via the STROBE line. The printer accepts the data and sets the BUSY line high until the data is processed (saved or printed). Now the next byte of data can be transferred. This procedure ensures that the printer also reads every byte of data

<!-- TOC PAGE_238: Commodore 64 printer interface guide -->

===========================================================
                      PAGE 238 OF 386                       
===========================================================

receives that the computer sends.

Now to program the interface. In order for the data to be sent to the printer with PRINT#, the software must be integrated into the operating system. However, there is another problem:

Most printers with a Centronics interface have an ASCII character set that differs from the Commodore 64 character set. We therefore have to perform a code conversion so that the printer receives the ASCII character that corresponds to the Commodore 64 character. This conversion is designed so that the characters as they appear on the screen in upper/lower case mode are also reproduced on the printer. In addition, however, it is sometimes necessary to transmit the characters as the computer sends them. This is necessary when, for example, data for single point graphics is transferred. In the program below this was solved like this:

If you do not specify a secondary address with the OPEN command, the data is converted so that the upper/lower case appears correctly. With a secondary address of one, the data is transmitted without conversion. 2 was chosen as the device address, which is normally the RS 232 interface. However, since this interface cannot be operated together with ours, there are no problems.

For example, if you want to output a program listing via this interface, the commands look like this:

OPEN 1,2 : CMD 1 : LIST

After the cursor appears again, enter

228

<!-- TOC PAGE_239: Commodore 64 printer interface guide -->===========================================================
                      PAGE 239 OF 386                       
===========================================================

PRINT#1 : CLOSE 1

to cancel CMD mode and close the channel. If you want to transfer graphic data, the programming looks like this:

OPEN 1,2,1
PRINT # 1, ...
CLOSE 1

For the hardware connection, all we need is a cable with a USER port plug on one side and a Centronics plug on the other. The pin assignment of the cable is given at the end of the assembler listing. When connecting the printer, proceed as follows: first connect the Commodore 64 to the printer using the cable, then switch on the computer and then the printer. Now load the machine program and initialize it with SYS 12*4096.

; Centronics interface for CBM 64
; Connection to USER port
; Definition of the I/O vectors
;

200: 031a *= $31a
210: 031c openv *= *+2
220: 031e closev *= *+2
230: 0320 chkinv *= *+2
240: 0322 chkoutv *= *+2
260: 0326 *= *+4
270: 0328 bsoutv *= *+2
280: 0328 xreg = $97 ; Memory for registers

;

<!-- TOC PAGE_240: Port definitions and initialization code -->

===========================================================
                      PAGE 240 OF 386                       
===========================================================

; Definition of the ports

284: dd00 *= $dd00 ; CIA2
285: dd01 porta *= *+1 ; Port
286: dd02 portb *= *+1
287: dd03 drra *= *+1 ; Data direction
288: dd0d drrb *= *+10
289: dd0e icr *= *+1 ; Interrupt control registers
290: dd0e lf = $b8
291: dd0e sa = $b9
292: dd0e fa = $ba
293: dd0e nmbfiles = $98
294: dd0e lftab = $259
295: dd0e fatab = $263
296: dd0e satab = $26d
297: dd0e srchfil = $f30f

; Initialization

330: c000 init *= $c000
340: c000 a9 58 lda #&lt; open
350: c002 a0 c0 ldy #&gt; open
360: c004 8d 1a 03 sta openv
370: c007 8c 1b 03 sty openv+1
380: c00a a9 8b lda #&lt; close
390: c00c a0 c0 ldy #&gt; close
400: c00e 8d 1c 03 sta closev
410: c011 8c 1d 03 sty closev+1
420: c014 a9 a3 lda #&lt; chkin
430: c016 a0 c0 ldy #&gt; chkin
440: c018 8d 1e 03 sta chkinv
450: c01b 8c 1f 03 sty chkinv+1
460: c01e a9 ba lda #&lt; chkout
470: c020 a0 c0 ldy #&gt; chkout

230

<!-- TOC PAGE_241: Assembly code for I/O operations -->

===========================================================
                      PAGE 241 OF 386                       
===========================================================

480: c022 8d 20 03 sta chkoutv
490: c025 8c 21 03 sty chkoutv+1
540: c028 a9 d1 lda #&lt; bsout
550: c02a a0 c0 ldy #&gt; bsout
560: c02c 8d 26 03 sta bsoutv
570: c02f 8c 27 03 sty bsoutv+1
580: c032 a9 ff lda #$ff
590: c034 8d 03 dd sta drrb ; Port B on output
600: c037 ad 00 dd lda porta.
610: c03a 09 04 ora #%100 ; Strobe hi
610: c03c 8d 00 dd sta porta
620: c03f 60 rts

; Output with handshake
; Data on port B
; Strobe on PA2
; BUSY via FLAG to ICR.

795: c040 8d 01 dd output sta portb ; Output data
800: c043 a9 10 lda #%10000 ; Mask for 'FLAG' bit
810: c045 2c 0d dd testbusy bit icr
820: c048 f0 fb beq testbusy
830: c04a ad 00 dd lda porta
840: c04d 29 fb and #%11111011 ; Strobe lo
850: c04f 8d 00 dd sta porta
860: c052 09 04 ora #%100 ; Strobe hi
870: c054 8d 00 dd sta porta
880: c057 60 rts

900: c058 a6 b8 open ldx lf ; logical file number
910: c05a f0 05 beq openerr
930: c05c 20 0f f3 jsr srchfil ; looks for file number
940: c05f d0 03 bne *+5
950: c061 4c fe f6 openerr jmp $f6fe ; 'file open error'

231

<!-- TOC PAGE_242: 6502 assembly file handling code -->===========================================================
                      PAGE 242 OF 386                       
===========================================================

232

960: c064 a6 98
ldx nmbfiles ; Number of open files

970: c066 e0 0a
cpx #10

980: c068 90 03
bcc *+5

990: c06a 4c fb f6
jmp $f6fb ; 'too many files error'

1000: c06d e6 98
inc nmb files

1010: c06f a5 b8
lda 1f

1020: c071 9d 59 02
sta lftab,x

1030: c074 a5 b9
lda sat

1040: c076 09 60
ora #$60

1050:c078 9d 6d 02
sta satab,x

1060: c07b a5 ba
lda fa

1070: c07d 9d 63 02
sta fatab,x

1080: c080 c9 02
cmp #2

1090: c082 d0 02
bne *+4

1100:c084 18
clc

1100:c085 60
rts ; finished

1110: c086 c9 00
cmp #0

1120: c088 4c 77 f3
jmp $f377 ; continue as usual

1300: c08b 20 14 f3 close
jsr $f314 ; looks for logical file number

1310: c08e f0 02
beq *+4

1320:c09018
clc

1320:c091 60
rts ; finished

1330: c092 20 1f f3
jsr $f31f ; sets file parameters

1340: c095 8a
txa

1340: c096 48
pha

1350: c097 a5 ba
lda fa

1360: c099 c9 02
cmp #2

1370: c09b f0 03
beq *+5

1380: c09d 4c 9d f2
jmp $f29d ; continue normally

1390: c0a0 4c f1 f2
jmp $f2f1 ; Delete entry in table

1400: c0a3 20 0f f3 chkin
jsr srchfil ; looks for file number

1410: c0a6 f0 03
beq *+5

<!-- TOC PAGE_243: 6502 assembly code listing -->

===========================================================
                      PAGE 243 OF 386                       
===========================================================

233

1420: c0a8 4c 01 f7 jmp $f701 ; 'file not open error'
1430: c0ab 20 1f f3 jsr $f31f ; sets file parameters
1440: c0ae a5 ba lda fa
1450: c0b0 c9 02 cmp #2
1460: c0b2 d0 03 bne *+5
1470: c0b4 4c 0a f7 jmp $f70a ; 'not input file error'
1480: c0b7 4c 19 f2 jmp $f219

;

1500: c0ba 20 0f f3 chkout jsr srchfil ; looks for file number
1510: c0bd f0 03 beq *+5
1520: c0bf 4c 01 f7 jmp $f701 ; 'file not open error'
1530: c0c2 20 1f f3 jsr $f31f ; sets file parameters
1540: c0c5 a5 ba lda fa
1550: c0c7 c9 02 cmp #2
1560: c0c9 d0 03 bne *+5
1570: c0cb 4c 75 f2 jmp $f275
1580: c0ce 4c 5b f2 jmp $f25b

;

1600: c0d1 48 bsout pha
1610: c0d2 a5 9a lda $9a ; Output device
1620: c0d4 c9 02 cmp #2
1630: c0d6 f0 03 beq *+5
1640: c0d8 4c cd f1 jmp $f1cd ; continue normally
1641: c0db a5 b9 lda sa ; Secondary address
1641: c0dd 29 0f and #%1111
1642: c0df d0 0a bne out ; not equal to zero
1642: c0e1 86 97 stx xreg
1643: c0e3 68 pla
1643: c0e4 aa tax
1643: c0e5 bd f3 c0 lda table,x ; Get code from table
1643: c0e8 a6 97 ldx xreg
1643: c0ea 24 .byt $24
1650: c0eb 68 out pla
1655: c0ec 48 pha

<!-- TOC PAGE_244: BASIC assembly code listing -->

===========================================================
                      PAGE 244 OF 386                       
===========================================================

1660: c0ed 20 40 c0 jsr issue ; Output characters
1660: c0f0 68 pla
1660: c0f1 18 clc
1660: c0f2 60 rts
1665: c0f3 table = *

c0f3 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f
c103 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f
c113 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f
c123 30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f
c133 40 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f
c143 70 71 72 73 74 75 76 77 78 79 7a 7b 7c 7d 7e 5f
c153 60 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f
c163 70 71 72 73 74 75 76 77 78 79 7a 7b 7c 7d 7e 7f
c173 80 81 82 83 84 85 86 87 88 89 8a 8b 8c 8d 8e 8f
c183 90 91 92 93 94 95 96 97 98 99 9a 9b 9c 9d 9e 9f
c193 a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 aa ab ac ad ae af
c1a3 b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 ba bb bc bd be bf
c1b3 c0 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f
c1c3 50 51 52 53 54 55 56 57 58 59 5a 5b 5c 5d de df
c1d3 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 ea eb ec ed ee ef
c1e3 f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 fa fb fc fd fe ff

Here is another loading program in BASIC

100 for i = 49152 to 49650
110 read x : poke i,x : s=s+x : next
120 data 169, 88, 160, 192, 141, 26, 3, 140, 27, 3, 169, 139
130 data 160, 192, 141, 28, 3, 140, 29, 3, 169, 163, 160, 192
140 data 141, 30, 3, 140, 31, 3, 169, 186, 160, 192, 141, 32
150 data 3, 140, 33, 3, 169, 209, 160, 192, 141, 38, 3, 140
160 data 39, 3, 169, 255, 141, 3, 221, 173, 0, 221, 9, 4
170 data 141, 0, 221, 96, 141, 1, 221, 169, 16, 44, 13, 221

<!-- TOC PAGE_245: Hexadecimal or binary data dump -->===========================================================
                      PAGE 245 OF 386                       
===========================================================

180 data 240,251,173, 0.221, 41,251,141, 0.221, 9, 4
190 data 141, 0.221, 96,166,184,240, 5, 32, 15,243,208
200 data 3, 76,254,246,166,152,224, 10,144, 3, 76,251
210 data 246,230,152,165,184,157, 89, 2,165,185, 9, 96
220 data 157,109, 2,165,186,157, 99, 2,201, 2,208, 2
230 data 24, 96,201, 0, 76,119,243, 32, 20,243,240, 2
240 data 24, 96, 32, 31,243,138, 72,165,186,201, 2,240
250 data 3, 76,157,242, 76,241,242, 32, 15,243,240, 3
260 data 76, 1,247, 32, 31,243,165,186,201, 2,208, 3
270 data 76, 10,247, 76, 25,242, 32, 15,243,240, 3, 76
280 data 1,247, 32, 31,243,165,186,201, 2,208, 3, 76
290 data 117,242, 76, 91,242, 72,165,154,201, 2,240, 3
300 data 76,205,241,165,185, 41, 15,208, 10,134,151,104
310 data 170,189,243,192,166,151, 36,104, 72, 32, 64,192
320 data 104, 24, 96, 0, 1, 2, 3, 4, 5, 6, 7, 8
330 data 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20
340 data 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32
350 data 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44
360 data 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56
370 data 57, 58, 59, 60, 61, 62, 63, 64, 97, 98, 99,100
380 data 101,102,103,104,105,106,107,108,109,110,111,112
390 data 113,114,115,116,117,118,119,120,121,122,123,124
400 data 125, 94, 95, 96, 97, 98, 99,100,101,102,103,104
410 data 105,106,107,108,109,110,111,112,113,114,115,116
420 data 117,118,119,120,121,122,123,124,125,126,127,128
430 data 129,130,131,132,133,134,135,136,137,138,139,140
440 data 141,142,143,144,145,146,147,148,149,150,151,152
450 data 153,154,155,156,157,158,159,160,161,162,163,164
460 data 165,166,167,168,169,170,171,172,173,174,175,176
470 data 177,178,179,180,181,182,183,184,185,186,187,188
480 data 189,190,191,192, 65, 66, 67, 68, 69, 70, 71, 72
490 data 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84
500 data 85, 86, 87, 88, 89, 90, 91, 92, 93,222,223,224
510 data 225,226,227,228,229,230,231,232,233,234,235,236

235

<!-- TOC PAGE_246: Userport to Centronics pinout guide -->

===========================================================
                      PAGE 246 OF 386                       
===========================================================

520 data 237,238,239,240,241,242,243,244,245,246,247,248
530 data 249,250,251,252,253,254,255
540 if s &lt;&gt; 58498 then print "error in datas!!" :end
550 sys 49152 : print "ok!"

The connecting cable between the user port and the printer interface has the following assignment:

|  USER PORT | - | CENTRONICS |
| --- | --- | --- |
|  A | GND | 16 |
|  B | FLAG - BUSY | 11 |
|  C | DO | 2 |
|  D | D1 | 3 |
|  E | D2 | 4 |
|  F | D3 | 5 |
|  H | D4 | 6 |
|  J | D5 | 7 |
|  K | D6 | 8 |
|  L | D7 | 9 |
|  M | PA2 - STROBE | 1 |

<!-- TOC PAGE_247: C64 data transfer guide -->===========================================================
                      PAGE 247 OF 386                       
===========================================================

237

# 7.2 DATA TRANSFER FROM AND TO OTHER COMPUTERS USING THE USER PORT

Let's assume the following case:

In addition to your CBM64, which you bought because of the color and sound options, you also have a CBM8032. How nice it would be if you could transfer data that comes from the 8032 to the CBM64 for color display, at the moment it is generated.

You could probably exchange data using a cassette if you have such a device, but that is a cumbersome and time-consuming process.

In order to show you the benefits of the user port (very few people know what to do with it), we chose this example and also wrote a small program that allows you to transfer data to and from your C64. In our case the partner is a CBM8032. However, it is certainly conceivable to try this procedure with other computers that have a similar facility to the user port.

The only requirement is that this device has eight data lines and two handshake lines. A Centronics interface, for example, would also be suitable, about which a lot is said in Section 7.1.

The program that will be discussed below naturally requires a connection between the two computers to run smoothly.

Instructions on what such a line should be like can be found behind the program listing.

First we will introduce you to the program. First of all, the variables and memory locations used, which in this case do not represent real memory, but addresses

<!-- TOC PAGE_248: CBM8032 Userport technical documentation -->

===========================================================
                      PAGE 248 OF 386                       
===========================================================

by which the user port is handled, and then a step-by-step explanation of the program.

First the variables:

X ASC value of a byte to be sent or received TI operating system clock; counts in steps of 1/60 sec. D$ complete string to be sent or received

Memory addresses used in the CBM8032:

59457 Userport data register
59459 Userport data direction register. As you may know, the user port can both send and receive data. Therefore, the data direction must be specified here, which is even possible for each individual bit.
59468 Bit 5 of this address controls line CB2 of the user port.
During transmission mode, this indicates the validity of the data on the line.
In reception mode, it serves as an acknowledgment signal that the data has been accepted. This ensures that no data is lost.
59469 Bit 1 reflects the status of the CA1 line of the user port.
In transmitting mode, the acknowledgment signal is waited for, while in receiving mode, the transmitter waits for the valid message.

Memory addresses in the CBM64

238

<!-- TOC PAGE_249: Microcontroller user port documentation -->===========================================================
                      PAGE 249 OF 386                       
===========================================================

56576 Bit 2 controls the line PA2 of the user port.
Use as described under 59468.
56577 Userport data register
56579 Userport data direction register
56589 Bit 4 reflects the status of the FLAG line of the user port.
Use as described under 59469.

Now the program in detail:

1000-1080 send routine
1000 The data direction register is set to output.
1010 The length of the send loop corresponds to the number of bytes to be transmitted.
1020 The byte indexed by I in D$ is written to the data register.
1030 To indicate that the data on the line is now valid, the corresponding signal =0 is set.
1040 This loop waits until the receiver acknowledges receipt of the byte.
1050-1060 The validity signal is then set =1 again and the next byte is transferred if there are more.
1070-1080 Now the user port is put back into idle state and the send routine is exited.
2000-2090 receiving routine
2000 The first byte is waited here.
2020-2030 The clock is set =0 and then waited until either a byte is received or two seconds have passed. If the latter is the case, it can be assumed that

239

<!-- TOC PAGE_250: C64/CBM8032 communication program guide -->

===========================================================
                      PAGE 250 OF 386                       
===========================================================

the transmission is over. The time limit in 2020 can be changed as necessary.

In our case, we asked in 2020 whether ti contains more than 120 time units, which corresponds to 2sec, namely 120*1/60sec. For 3sec the corresponding value would be 180.

2040-2050 First we wait for the validity report. Once this has arrived, the byte obtained in X is appended to D$.

2060-2080 As an acknowledgment of this, the corresponding line is temporarily set to =0 and then waited for the next character to arrive.

Using these routines is very simple.

After you have made an appropriate cable and connected the computers in question to it, you can actually get started.

The program described actually only consists of two subprograms: one for sending and one for receiving.

You should integrate these subprograms into your own program. If you want to send characters, create them in D$ and say GOSUB1000.

If you want to receive, say GOSUB2000 and when you return you have the characters in D$ available, it's that simple.

Below you will find two program listings: one for the C64 and one for the CBM8032. Both have the same structure, but the user port addresses are inevitably different.

They also differ in line 2010. A jump must be inserted here to take into account the different block that handles the user port in the C64.

240

<!-- TOC PAGE_251: CBM8032 data transfer subroutine -->

===========================================================
                      PAGE 251 OF 386                       
===========================================================

995 rem subroutine collection for transfer
of data via the user port
996 rem version for 6522 at address 59456 of CBM8032
998 rem
999 rem send a string
1000 poke 59459,255:rem data direction output
1005 poke 59468,peek(59468) or 224:rem cb2 high
1010 for i=1 to len(d$):rem send loop for d$
1020 x=asc(mid$(d$,i,1)):poke 59457,x:rem data output
1030 poke 59468,peek(59468) and 223:rem cb2 low
1040 wait 59469.2:
rem wait until data is received
1050 poke 59468,peek(59468) or 224:rem cb2 high
1060 next
1070 poke 59457,0:poke 59459,0:reset rem port
1080 returns
1996 rem
1997 rem received from d$
1998 rem
1999 rem
2000 wait 59469.2:
Wait until the transmission begins
2010 d$="":rem d$ prepare
2020 ti$="000000"
2030 if ti&gt;120 then 2090
2040 if (peek(59469) and 2)=0 then 2030:
rem waiting for data byte
2050 x=peek(59457):d$=d$+chr$(x)
2060 poke 59468,peek(59468) and 223:rem cb2 low
2070 poke 59468,peek(59468) or 224:
rem cb2 high = confirmation of receipt
2080 goto 2020
2090 returns

241

<!-- TOC PAGE_252: CBM64 data transfer subroutine -->===========================================================
                      PAGE 252 OF 386                       
===========================================================

995 rem subroutine collection for transfer
of data via the user port
996 rem version for 6526 at address 56576 of the CBM64
998 rem
999 rem send a string
1000 poke 56579,255:rem data direction output
1010 for i=1 to len(d$):rem send loop for d$
1020 x=asc(mid$(d$,i,1)):poke 56577,x:
output rem data
1030 poke 56576,147:rem pa2 low
1040 wait 56589.16:
rem wait until data is received
1050 poke 56576,151:rem pa2 high
1060 next
1070 poke 56577,0:poke 56579,0:reset rem port
1080 returns
1996 rem
1997 rem received from d$
1998 rem
1999 rem
2000 wait 56589.16:
Wait until the transmission begins
2010 d$="":goto 2050:rem d$ prepare
2020 ti$="000000"
2030 if ti&gt;120 then 2090
2040 if (peek(56589) and 16)=0 then 2030:
rem waiting for data byte
2050 x=peek(56577):d$=d$+chr$(x)
2060 poke 56576,147:rem pa2 low
2070 poke 56576,151:rem pa2 high:
rem confirmation of receipt
2080 goto 2020
2090 returns

242

<!-- TOC PAGE_253: Serial communication setup guide -->

===========================================================
                      PAGE 253 OF 386                       
===========================================================

A small example should illustrate the application of the routines:

Assuming you have loaded the corresponding routine in both computers, just add the line in the transmitter

10 d$="test":gosub1000:end

one, and in the receiver the line

10 gosub2000:print d$:end

Now start both programs and see what happens.

The connecting line must be made according to the diagram below.

We recommend a 10-core, shielded cable with a cross-section of the individual cores of 0.14-0.35 mm².

The shielding must be connected to the GND pin on both sides.

In our tests, the arrangement worked without errors with a cable length of 5m. It cannot be predicted whether significantly longer lengths are still possible. This also depends, among other things, on the environment and its interference fields. For example, electric motors (washing machines, vacuum cleaners) generate strong interference that can lead to errors in the transmission.

A cable length of 3m can be considered completely harmless.

243

<!-- TOC PAGE_254: Technical schematic diagram -->

===========================================================
                      PAGE 254 OF 386                       
===========================================================

244
![img-5.jpeg](img-5.jpeg)
C-64
CBM 8032
PIN NAME
PIN NAME
FLAG 2 B
PA 2 M
PB2C
1D
2 E
3 F
4H
5 yrs
6K
7L
GND N
ABSCDE FH J K L M N
B CA 1
M CB2
CPA0
D1
E2
Q3
H4
J5
K6
L7
N GND
SHIELDING

<!-- TOC PAGE_255: CP/M cartridge technical documentation -->

===========================================================
                      PAGE 255 OF 386                       
===========================================================

245

# 7.3 THE CP/M CARTRIDGE ON THE EXPANSION PORT A CASE STUDY

This section describes how to make optimal use of the C64's expansion slot using sophisticated additional hardware. For a better understanding of the processes described here, knowledge of the relevant chapters of our book '64 intern' is an advantage.

First: What is the CP/M cartridge?

The CP/M cartridge is a plug-in module developed by Commodore, which essentially contains a Z80 processor and some logic components necessary for communication with the C64.

This module makes it possible to operate the widely used CP/M operating system and the diverse software available for this on the C64.

We would like to explain to you here how to operate two processors on the same hardware.

At the end of the section you will find a block diagram of the CP/M cartridge, which is limited to the essentials so as not to make the representation unnecessarily complicated.

The following description of the individual processes refers to this figure and the names of the functional groups it contains.

We want to try to present the processes in such a way that you don't necessarily have to be a hardware expert to understand them.

First, a short one to get you in the mood for the topic

<!-- TOC PAGE_256: C64 expansion port technical guide -->===========================================================
                      PAGE 256 OF 386                       
===========================================================

Description of the expansion port lines insofar as they play a role in this context:

CDO-7 data lines of the system bus.
These can only be controlled by the 6510 processor in the C64 as long as DMA=1 and BA=1.
You should remember this fact as it is essential for the further process.

CAO-15 address lines of the system bus.
The above also applies to these.

I/O1 This line is =0 if any activity occurs in the address range $DEOO-DEFF (56832-57087).

RES When this line becomes =0 (usually only the case when switching on), all connected hardware is set to the basic state.

DMA This line is an input. If you set it =0, the processor 6510 is shut down, releasing the system bus for external control.

BA The video controller in the C64 signals on this line that it is accessing the memory (BA=0).
During this time, the system bus may not be accessed from the 6510 or from outside via the expansion port.

SO2 This is the system clock that controls all processes in the C64.
In order to carry out all activities synchronously with those in the C64, in our case the Z80 of the CP/M module is also controlled by this clock.

To describe the further processes, it is best to start with the idle state, i.e. the state that occurs after the device is switched on.

246

<!-- TOC PAGE_257: Z80 bus control technical explanation -->

===========================================================
                      PAGE 257 OF 386                       
===========================================================

First of all, the explanation of a line on the Z80, namely BUSREQ. This signal has a similar effect to AEC (caused by DMA=0) on the 6510. If BUSREQ=0, the Z80 stops all activities and releases its system bus.

If the device is switched on, the RES line is briefly =0, which means that the Z80 on the module returns to its initial state and the flip-flop FF is reset (Q=0, -Q=1).

This makes the output of the gate &amp; also =0, independent of BA.

This in turn means that buffers A1, A2 and D are locked and therefore cannot control the system bus.

Furthermore, the signal BUSREQ =0, i.e. the Z80 remains in the basic state.

You can now see that the functionality of the entire module depends only on the state of the flip-flop FF in conjunction with the signal BA (linked by the AND gate &amp;).

Only if FF is set (Q=1, -Q=0) and BA=1 at the same time will BUSREQ =1 so that the Z80 can work.

You can now work with your C64 as usual as long as you do not execute a specific command, namely POKE 56832.1.

As you can see from the block circuit and the description of the expansion solder, this POKE activates line I/01. Since we also poke the value 1, this command sets our flip-flop FF, and the Z80 starts running, because BA is =1 most of the time.

At the same time, the 6510 is switched off by DMA=0 and your computer crashes because it has no program in memory

247

<!-- TOC PAGE_258: Z80 processor memory addressing guide -->===========================================================
                      PAGE 258 OF 386                       
===========================================================

which the Z80 could now sensibly execute, which brings us to the next topic, namely: Where does a program have to be located so that the Z80 can execute it? To do this we need to go a little further.

In contrast to the 6510, the Z80 begins processing its program at memory address 0 after the reset (RES=0).

This is where the first case of conflict arises, because the 6510 has its I/O port at 0 and the zero page is located at the following addresses, an area that the processor absolutely needs for operation, as important operating system parameters are also stored here. It is therefore impossible to provide the Z80 with a program in this address space. On the other hand, you cannot cause it to start operating at an address other than 0.

This dilemma is solved very elegantly on the CP/M module. If you look at the block diagram, you will find a function block that we have labeled ADD. Behind it is a 4-bit full adder. This takes a 4-bit word at each of its inputs, adds the two together and makes the sum available at its output.

In our case, this adder is looped into the four most significant address bits. The address lines from the Z80 go into one input, the other input is hardwired to the value 1. As a result, the value of the upper four address bits increased by 1 appears at the output.

Looking at the entire address, this corresponds to an increase of $1000 (4096), since 4k steps are counted with the highest digit of a 2-byte address.

So, to stick with our example, if the Z80 outputs address 0 when starting up in order to get the first command from there, this corresponds to an effective address of $1000 (4096) when added.

248

<!-- TOC PAGE_259: Z80 cartridge programming guide -->

===========================================================
                      PAGE 259 OF 386                       
===========================================================

A program that can be used for the Z80 can easily be stored there without disturbing the operating system of the 6510. It also follows from the method described that a Z80 address of $F000 (61440) corresponds to an effective address of 0, since a carry to the next position is not taken into account during the addition.

The procedure described above is actually how you actually work with the module: After switching on the computer, a small start program is loaded into the memory (of course starting at $1000), and after setting the flip-flop FF, the Z80 begins to process its program there, which usually consists of loading the CP/M operating system and then executing the instructions given by the user.

You should also use this procedure if you want to run your own Z80 programs. Simply place the program you wrote at 4096 ($1000) and turn on the cartridge as described.

Since such a program is certainly not an end in itself, but should also produce some output, be it on the screen or a printer, precise knowledge of the C64 hardware addresses is of course essential so that you can carry out the correct actions from the Z80 program. However, always take into account the offset to the address made on the module. For example, if you want to transfer data to the user port, the address in your Z80 program should be $CD01 (52481), since the user port is addressed from the 6510 with $DD01 (56577). So always subtract $1000 (4096) from the desired addresses in your program.

But how do you get out of the Z80 operating mode? Nothing easier than that: If you have loaded the basic interpreter, say POKE 52736.0 to reset FF. This has the further consequences that BUSREQ again

249

<!-- TOC PAGE_260: C64 Z80 processor technical documentation -->===========================================================
                      PAGE 260 OF 386                       
===========================================================

=0, so the Z80 stops operating, and at the same time DMA =1, whereupon the 6510 continues where it previously left off.

The poke address must of course be 4096 lower than 6510, since this value is added back by ADD. However, it is not recommended to proceed in this way because the 6510 will not find a suitable program when it resumes operation, because there are still program parts in the memory that were intended for Z80 operation and the 6510 cannot do anything with them. The computer crashes.

For the sake of completeness, it should also be mentioned that the Z80 can of course access all of the hardware built into the C64, as it covers the entire address space of 64k.

So far, the BA management has been a little neglected. This should be done now.

In and of itself, BA is just an auxiliary signal that regulates the traffic on the data bus. However, it has a serious impact on the CP/M module, as can be seen from the link with &amp; This is clear, because regardless of the position of the FF, the Z80 will definitely stop at BA=0.

If we examine the origins of BA more closely, it becomes clear why this must be the case.

BA is generated by the video controller in the C64. Since the screen memory is in the usual address space and the video controller has to access it cyclically to refresh the image, no one else is allowed to use the system bus during this access time.

Normally this is not the case either, because the controller cleverly exploits the gaps for its access where the processor does not need the system bus anyway. However, there are some exceptions. One of these is the case when working with sprites. To

250

<!-- TOC PAGE_261: Technical hardware documentation page -->

===========================================================
                      PAGE 261 OF 386                       
===========================================================

The gaps mentioned are not sufficient for displaying sprites, as the memory has to be accessed several times in a row.

The video controller signals this situation with BA=0 and the Z80 must then enable the system bus.

We have deliberately kept the block diagram on the following page simple, although the processes in the area of ​​the data bus buffer D are much more complex. However, it is completely sufficient to understand the interactions between the 6510 and Z80.

251

<!-- TOC PAGE_262: Driver's license front side -->

===========================================================
                      PAGE 262 OF 386                       
===========================================================

![img-6.jpeg](img-6.jpeg)
252

<!-- TOC PAGE_263: C64 synthesizer stereo modification guide -->===========================================================
                      PAGE 263 OF 386                       
===========================================================

253

#7.4 SYNTHESIZER IN STEREO

If you have often worked with the synthesizer on your C64, you will have probably been annoyed by the somewhat meager sound that your television produces. This may also depend on the quality of the sound in the television.

If you have a stereo system, you'll be challenged to remedy this and produce a somewhat fuller sound.

We would now like to show you how you can do this in detail.

Since a stereo system is known to have two channels, we first need to think about how we split the synthesizer's single-channel output between these two channels.

Unfortunately, the device's individual voices are not available on separate connections, otherwise they would already be divided.

So we went and divided the sound signal into two frequency ranges. The division into lower and upper ranges occurs at 300 Hz.

This means that the range covered by the synthesizer is audibly divided in the middle, namely into three octaves below (up to 36 Hz) and four octaves above (up to 4800 Hz) 300 Hz.

This is achieved with two double-T filters with a slope of 6dB/octave and a cutoff frequency of 300 Hz (low pass) or 3 kHz (high pass).

You can of course change the cutoff frequencies to suit your taste by using other capacitors, but you should keep the resistance values ​​as they are tailored to the impedance of the connected devices.

<!-- TOC PAGE_264: Audio filter circuit instructions -->

===========================================================
                      PAGE 264 OF 386                       
===========================================================

For a given limit frequency F, the required capacitor value is calculated as $C = 1 / (3300 * F)$.

If you have any capacitors in your craft box and want to know what cutoff frequency this results in, use the formula $F = 1 / (3300 * C)$.

However, you can assume that the circuit with the specified values ​​represents an optimum, which we have achieved in our laboratory through extensive measurements and listening tests.

If a filter slope of 3dB/octave is sufficient for you, you can also leave out the components R2, C2, C4, R6. The sound will be acoustically located between the speakers over a wider area.

As you can see, the filter circuit is extremely simple. It is conveniently built on a small piece of perforated board and looped into the connecting cable to the stereo system. If you want to do the rest, you can cast this arrangement and the connected cable ends in silicone rubber. This gives you a solution that is also visually flawless.

We would now like to introduce you to a short program that produces a 'sweep' with the triangle oscillation.

You can clearly hear how the sound travels from one speaker to the other.

We chose the triangular wave because it has relatively few overtones and you can therefore observe the effect better.

For more complex, overtone-rich sounds, such as sawtooth oscillation, the overtones appear on one channel while you hear the fundamental oscillation from the other speaker, as long as it does not exceed 300 Hz.

One thing you will definitely notice is that the sound has become significantly more voluminous.

254

<!-- TOC PAGE_265: Basic Commodore 64 assembly code -->

===========================================================
                      PAGE 265 OF 386                       
===========================================================

Here is the program:

10s1=54272
20s2=54279
30s3=54286
60rs=54295
70pl=54296
80 poke s1+4.0:poke s2+4.0:poke s3+4.0
100 a=9:d=9:s=9:r=9:h=30
110 poke rs,0:poke pl,15
120 poke s3+5,16*a+d:poke s3+6,16*s+r
130 poke s3+4.17
140 for i=0 to h:poke s3+1,peek(54300):next i
150 poke s3+4,16
160 for i=0 to r*4:poke s3+1,peek(54300):next i

Due to its simplicity, we will not go into detail about the circuit below. The stereo pin assignment is intended for connection to the phono input.

![img-7.jpeg](img-7.jpeg)

<!-- TOC PAGE_266: Commodore 64 file management guide -->===========================================================
                      PAGE 266 OF 386                       
===========================================================

CHAPTER 8: FILE MANAGEMENT: NOT A SEALED BOOK

## Introduction

Who hasn't been faced with the task of collecting various data and accessing it again at a later point in time? But this task is often the most complicated topic in programming. Regardless of whether it is BASIC, FORTRAN, PASCAL or other languages ​​– file management and everything that has to do with processing data is a more or less complex problem everywhere. One would expect that at least computer or programming language manuals would provide more detailed information on this topic. Unfortunately, file management is discussed too briefly or not at all.

In this chapter we want to give you an insight into file management on the Commodore 64. We will not only convey dry theory, but also give examples. This way you too can understand and use the Commodore 64 even better. First of all, a few basic terms from the area of ​​file management must be explained.

## FILE

Everyone is talking about file management and files - but what are files actually? The easiest way to explain the term is to replace it with a term that everyone knows: CARDEI. As you know, a card index, for example in a library, consists of several index cards. These cards contain all the information about a specific object or person. So you always know, to stick with our example, which reader is currently reading which book or which book is on loan. These flashcards are arranged according to a very specific pattern. The most common method is alphabetical sorting. Another possibility is this

256

<!-- TOC PAGE_267: Database concepts explanation document -->

===========================================================
                      PAGE 267 OF 386                       
===========================================================

Sorting by item number or date. All cards together now form a card index. It's similar with a file (in the computer sense). A file there consists of several data sets (recordings see below). The individual information is now stored in these data sets – like on an index card.

The big advantage of a FILE over a CARDEI (as we just explained it) is the incredible flexibility of the FILE. Above all, this includes saving time when searching and sorting all the data; But space savings also play a major role today. The storage media used by small computers often has space for more than 1 million characters! Can you imagine how many index cards it would take to accommodate this amount of information?

## DATASET

As we discussed above, you can easily compare a data set to an index file from a large map. This data set contains all the data that would otherwise be on an index card, divided into one or more FIELDS.

## FIELDS

Here too you can use the example of the index card. If you can imagine a data set as an index card, the fields are the individual pieces of information on the card. You can imagine the connection between the three terms like this:

### FILE -&gt; DATASET -&gt; FIELD

So if I want to have certain information about a thing or a person, e.g. the name, I first have to access the corresponding file, then read the data record from this file and finally read the corresponding field from the data record. Graphically it can be done like this:

257

<!-- TOC PAGE_268: Address database example table -->===========================================================
                      PAGE 268 OF 386                       
===========================================================

are shown:

FILE: ADDRESS FILE

|   | FIELD
NAME | FIELD
FIRST NAME | FIELD
ROAD | FIELD
ZIP code | FIELD
LOCATION |
| --- | --- | --- | --- | --- | --- |
|  REC.: 1 | MEIER | HEINZ | A-STR. 1 | 1234 | BITDORF |
|  REC.: 2 | MULLER | EGON | B-STR. 5 | 6502 | CBM CITY |
|  REC.: 3 | SCHULZE | HANS | C-STR. 2 | 4711 | SCENT VILLAGE |

In this example of a file you can clearly see the differences and connections between file, data record and field. You should already understand these terms before you can actually start programming programs that manage files. In the following we will describe various access and storage methods - but the basis is in any case an understanding of what was discussed above.

258

<!-- TOC PAGE_269: Commodore 64 cassette programming guide -->

===========================================================
                      PAGE 269 OF 386                       
===========================================================

259

# 8.1 CASSETTE - DISK

After this somewhat more detailed introduction, we now want to deal with the actual programming of file management programs. To do this, we should first look at the devices that are available to us for storage on the Commodore 64: Datasette and floppy drive.

What is the difference between these two devices and their data carriers, cassettes and floppy disks? What can they be used for? In order to clarify these questions, we would first like to take a trip to the beginnings of IT.

Just a few years ago, terms like “floppy” or “magnetic disk” were virtually unknown. But even back then, of course, you couldn't do without a data storage medium, i.e. a device that can save data and read it again. Punch cards were developed for this purpose. With them they had found a simple and inexpensive way to save data at any time and feed it back to the computer. However, a huge disadvantage of the equipment required to work with punch cards was recognized quite early on, namely the punch card punch (for outputting information on punch cards) and the punch card reader. Both were far too slow as purely mechanical devices. But as time went on, people became more and more dependent on fast and secure data storage, something better had to be developed. The result: the magnetic tape. And with that we can now deal with today's cassette, the working principle of which is very similar to that of magnetic tape, which is still used quite frequently, especially in large-scale IT.

The principle of the cassette as a data medium is quite simple (if you only look at the basics at first). First, let's look at data storage. The Commodore 64 has a special device assignment for storage on cassette: The device number is 1. The command for writing is also 1. If you want to open a file on the cassette recorder, do so

<!-- TOC PAGE_270: Commodore 64 file commands guide -->===========================================================
                      PAGE 270 OF 386                       
===========================================================

The entire command for this is:

OPEN 1, 1, 1, "CBM 64 FILE"

The first '1' is the file number for the Commodore 64. If you want to open several files in the Commodore 64, you must choose different file numbers for the printer, cassette or floppy. Overall, all numbers from 1 to 255 are permitted. If the cassette recorder is set to RECORD &amp; PLAY is set, the Commodore 64 will write a special leader to the tape. For a file, this header only contains the file name. For a program, the start address is also saved. This so-called program or file header is saved twice in a row. The tape then stops. Now the data can be saved (or the program).

An additional way to save a file is in the sequence:

OPEN 1, 1, 2, "CBM 64 FILE"

With this command you write additional information to the tape after the file. This information, also called EOT (End Of Tape), tells the Commodore when read later that the tape ends here - so it cannot be described further.

Data that was saved at some point should of course be read again. The corresponding command for this is:

OPEN 1, 1, 0, "CBM 64 FILE"

The Commodore 64 now searches for a corresponding file until it has either found it or it has encountered an EOT.

260

<!-- TOC PAGE_271: Commodore 64 disk storage guide -->

===========================================================
                      PAGE 271 OF 386                       
===========================================================

IMPORTANT: When writing, the Commodore 64 does not look for a file with the specified name. He writes "without regard to losses" exactly where the tape is currently located. Therefore, if possible, you should not save more than one file per cassette to prevent unintentional destruction of stored data and programs.

After these magnetic tapes were no longer sufficient (we'll get to why in a moment), the technology was refined. Magnetic disks were now used. The Commodore 64 can also use a similar method. Here you can connect one or more so-called floppy drives. The associated data carriers, the floppy disks, can best be compared to records. There are different tracks here too. However, the material of the floppy disks is magnetic. So these “records” can not only be read but also written to. The syntax (notation) of the commands for reading or writing data is as follows:

OPEN 2, 8, 2, "O:CBM 64 FILE,S,W"

or

OPEN 2, 8, 2, "O:CBM 64 FILE,S,R"

The first '2' is again the Commodore internal file number, '8' is usually the device number for a floppy (but can also be set to '9' for example) and the second '2' is the channel number. But the most interesting thing is the name part. Here we first find the drive information (0 or 1), then the file name, then an 'S' for 'Sequential File' (more on that later) and then either a 'W' for 'Write' or 'R' for 'Read'. This means we can now open files on a floppy disk.

The main differences between floppy disks and cassettes

261

<!-- TOC PAGE_272: Cassette vs. floppy comparison analysis -->===========================================================
                      PAGE 272 OF 386                       
===========================================================

consist of:

- Costs
In terms of purchase costs, the cassette recorder is clearly the cheapest storage medium, even though floppy disk drives have recently become considerably cheaper and you can get a VC-1541 floppy for under 1000 DM. The situation is different when it comes to the costs for the actual data carriers. For example, to store the 170,000 characters that fit on a Commodore VC-1541 disk, you need about 4 C-60 cassettes. The cassette recorder no longer offers a price advantage here.

- Access time
This is where the advantages of the floppy disk become clear. For example, reading a 10K program takes 200 seconds on a cassette recorder, but only 20 seconds on the VC-1541 floppy. The situation is similar when searching a sequential file. For example, to read a file consisting of 50 addresses, each of which is 100 characters long, it takes 180 seconds on a cassette recorder and only 18 seconds on a floppy disk drive.

- Access types and programming convenience
While the cassette recorder only allows program files and sequential files, the floppy disk offers significantly more options with relative files and direct access.

This makes it clear that the cassette recorder is just an inexpensive device for beginners. If you want to do more with your Commodore 64 or even use it for commercial purposes, you can't avoid a floppy disk drive. In the following, we will first look at the technical basics of data storage on cassettes and then turn to the individual access types and file formats.

262

<!-- TOC PAGE_273: Commodore 64 data tape guide -->

===========================================================
                      PAGE 273 OF 386                       
===========================================================

The Datasette - or HOW DO THE BITS GET ON THE TAPE?

Now that we have explained the principle of the files (and hopefully you have understood it too), we would like to explain at this point how the individual information actually gets onto the tape. We have to get a little technical now, but who knows when which information might be needed. And since this topic seemed very important to us, we think that you should also receive this information.

We call the process used by Commodore to record the information (bits) onto the cassette tape PPM. PPM means PULSE POSITION MODULATION. This means that the Commodore 64, just like its other Commodore brothers, writes the digital signals directly to the tape and not in the form of two audio frequencies. These digital signals are transmitted in three different times: K (Short), L (Long) and M (Medium). From these three times, 3 different combinations are formed, which have the following meaning:

LLMM = BYTE ; This combination precedes every BYTE MMKK (=1), KKMM (=0).

This means that, for example, the letter "A" is saved on the tape in this form:

|  LLMM | MMKK | KKMM | KKMM | KKMM | KKMM | KKMM | MMKK | KKMM | MMKK |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
|  BYTE | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 1 |
|  BIT# | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | Parity ODD |

The entire storage looks like this:

|  Programs | Files |
| --- | --- |
|  --- | --- |
|  Program header | File header |
|  Start-end address, name | Name |
|  Program header (repeat) | File header (repeat) |

<!-- TOC PAGE_274: Commodore data transfer protocol -->===========================================================
                      PAGE 274 OF 386                       
===========================================================

264

Program (one block) Data block (one block)
Program (repeat) Data block (repeat)
End block End block

The head is structured like this:

|  Programs | Files |
| --- | --- |
|  Start address (xxxx) | Start address (0000) |
|  End address (xxxx) | End address (0000) |
|  Program name (16 characters) | Filename (16 characters) |
|  Fill character (for prg. name) | Fill character (for data name) |

A block consists of: (programs and files)

approx. 2.00 seconds of opening credits

9 BYTES count down ($89 $88 $87 $86 $85 $84 $83 $82 $81) on the first block

($09 $08 $07 $06 $05 $04 $03 $02 $01) in the reps

Data

Checksum (EXOR checksum over the entire data)

End mark (LLKK KKKK KKKK KKKK KKKK)

approx. 0.16 seconds of credits

As already mentioned, the recording process is the same for all Commodore devices. The problem with the data exchange between Commodore 64 and VC-20 lies in the different frequencies. The clock speed of the VC-20 is higher than that of the CBM, and the clock speed of the CBM is again higher than that of the Commodore 64. This means for you that you can use the programs of the VC-20 and the Commodore 64 on the large Commodore devices

<!-- TOC PAGE_275: VC-20 to C64 tape transfer guide -->

===========================================================
                      PAGE 275 OF 386                       
===========================================================

can run, but not a VC-20 program directly on the Commodore 64 and vice versa. However, if you want to exchange cassettes between the two computers, you will have to take the detour via a large CBM. The process could look like this:

You have a cassette that contains one or more VC-20 programs (or files). You want to transfer these programs (files) to your Commodore 64. To do this, take a normal dataset, connect it to a large CBM computer and load the first program (or file) as usual. Then take a new cassette and swap it with the VC-20 cassette in the recorder. Now save your program (or file) to the new tape using the usual commands. If you still have several programs (or data), start again from the beginning.

After all programs have been transferred, or better said converted, you have a cassette that can be loaded on both the VC-20 and the Commodore 64. Under certain circumstances, a few changes need to be made in the program, such as screen adjustment, different POKE's and the like, but that goes without saying.

Unfortunately, we are currently not aware of a software solution to the problem of program conversion between VC-20 and Commodore 64, but perhaps you already have an idea. We are always very happy about such suggestions.

But a consolation at the end. Programs that were written on the Commodore computers of the 3000 or 4000 series, for example, can be loaded directly - and which other computer can access this amount of software?

265

<!-- TOC PAGE_276: Sequential file management guide -->===========================================================
                      PAGE 276 OF 386                       
===========================================================

266

# 8.2 THE PRINCIPLE OF FILE MANAGEMENT: SEQUENTIAL FILES

We have just looked at the “history” of data carriers in detail. Let us now turn our attention only to the last two data carriers mentioned, i.e. magnetic tape and disk. Using these two devices, the different methods of file access can be easily explained. In this chapter we now only want to turn to the sequential method.

Sequential means something like “one after the other”. The individual data records are in the file in exactly the same way, one after the other. This can be compared to recording a piece of music using a cassette recorder. You wind the tape to a specific point and then press the recorder buttons. Then the piece of music is recorded. If you want to play a certain piece of music again, you usually first have to rewind to the very beginning of the tape so that when you fast forward, you can read from the counter which piece of music you are currently "passing through".

This is roughly how you can imagine the recording of data from the computer to tape. So if you want to record data that you later want to find based on a specific counter position, you must first determine the exact counter position. Of course, this is only correct if you have rewound the tape beforehand and then pressed the counter reset button. Only then can you start the actual recording. This somewhat cumbersome procedure at least allows you to access your data more quickly later using the fast forward and rewind buttons. However, it still becomes problematic if you search for a specific data record within a file. If you have a file full of addresses and you are looking for the name MÜLLER, it can of course happen that you have several MÜLLERs in the same file. However, you are often unable to note down the counter reading each time you save the data (also...

<!-- TOC PAGE_277: Commodore 64 data management guide -->

===========================================================
                      PAGE 277 OF 386                       
===========================================================

We want to avoid such manual work, otherwise we can just use index cards). So we have to do it a little differently. To do this, we rewind the tape back to the very beginning, open the file to read (see above) and then go through sentence by sentence until we have read the correct MÜLLER. Of course, this means a certain amount of effort - with 2000 data records in one file, you can perhaps go for a leisurely coffee in between. But you can still do a little file management with something as simple as a cassette recorder, especially since this cassette recorder is a really inexpensive option.

If you only have a cassette recorder but still want to manage data quickly and efficiently, you should use the following procedure: Design your files so that they basically fit into the free memory of the Commodore 64. Before you change, delete, add, or simply display data in your file on the screen, load the entire file into memory. Now you are no longer dependent on the slow speed of the recorder when accessing files, but can use the full computing speed of your Commodore. After working with your file, save the entire file back onto the cassette. You can of course also use this simple and practical procedure for larger files. Simply split your data into several small files. For example, you can split a large address file by name into A-C, D-F, etc., and thus obtain files that fit into the Commodore 64's memory. With a little skill and organization, you can achieve a lot of convenience in file management with a recorder.

If you imagine the data storage process visually, it will be easy to see why a cassette recorder can only store data sequential. All data is saved one after the other and read back into the computer one after the other.

267

<!-- TOC PAGE_278: Commodore 64 disk file handling -->===========================================================
                      PAGE 278 OF 386                       
===========================================================

The sequential file is also available as a file type on the diskette, but the options for handling it are greater than with the cassette recorder. Sequential files can be accessed quickly and directly without searching. The Commodore 64 immediately gets the location where the file is located via the diskette table of contents, in which all programs and data on a diskette are listed. This eliminates the hassle of searching, as is necessary with a cassette recorder.

So how do we handle a sequential file on the Commodore 64? First the file must be opened (see above). This requires file number, device number, channel number and name. If this file was opened like this, you can write to or read from the file with one command, but never both at the same time!

However, you cannot simply write to an existing file. For example, if you open the file "CBM 64 FILE" with the command

OPEN 2, 8, 2, "O:CBM 64 FILE,S,W"

and a file with that name was already on the disk, you will receive a FILE EXISTS error message. The command must therefore be modified by placing the character "@" in front of the drive number (also known in technical language as a "spider monkey"). The command is then:

OPEN 2, 8, 2, "@O:CBM 64 FILE,S,W"

and causes the file in question to be overwritten. The data previously saved in this file on the diskette will be lost!

It is therefore important: Even with a floppy disk, no data can be changed in an existing, sequential file.

268

<!-- TOC PAGE_279: Commodore 64 file management guide -->

===========================================================
                      PAGE 279 OF 386                       
===========================================================

To change data, the sequential file must always be read completely into memory and then saved again on diskette after the change has been made. If you want to base your file management on sequential files on the diskette despite the possibility of direct access, you should use the procedure described above for cassette recorders.

However, sequential files on the diskette offer another advantage over the cassette recorder in addition to the significantly higher speed, namely the ability to attach (APPEND) to a file. This binding has a big advantage: You don't have to read all the data back into the Commodore 64 and then write it away, but by simply changing the OPEN command you can cause the Commodore 64 to bind all the data that is now to be written to the diskette to an existing file. The OPEN command is then:

OPEN 2, 8, 2, "O:CBM 64 FILE,S,A"

Now all the data that needs to be entered will be appended to the file. This allows you, for example, to easily expand an existing address file without overwriting the other data or having to copy it into a new file.

Unfortunately, with a cassette recorder it is not possible to connect to a sequential file. So you always have to read all the data into the Commodore 64 first, then modify or expand it and then save it back onto the cassette. Now do you understand why we said that file management on floppy disk is far more useful than on cassette?

Below you will find a small file management system with sequential files for cassette recorders and floppy disk drives using sample programs. You can easily modify the individual programs for your individual application. First of all, the version for cassette recorders.

269

<!-- TOC PAGE_280: Commodore 64 data storage program -->===========================================================
                      PAGE 280 OF 386                       
===========================================================

#1. Writing the data

```txt
10 REM***
20 REM WRITING NAME AND FIRST NAME ON TAPE
30 REM VERSION FOR DATASETTE / COMMODORE 64
40 REM***
50 PRINT CHR$(147): CLEAR SCREEN
52 PRINT "OPENING THE FILE TO WRITE"
54 PRINT
56 OPEN 1,1,1,"CBM 64 FILE"
60 INPUT "NAME : ";NA$
70 INPUT "FIRST NAME : ";VN$
80 PRINTS
90 PRINT "WRITING - NAME = ";NA$
100 PRINT " - FIRST NAME = ";VN$
110 PRINTS
120 PRINT#1,NA$
130 PRINT#1,VN$
140 PRINTS
150 INPUT "CONTINUE (Y/N) ";JN$
155 PRINTS
160 IF JN$="J" THEN GOTO 60
170 IF JN$="N" THEN GOTO 200
180 PRINT "WRONG ENTRY!"
190 GOTO 140
200 CLOSE 1
210 END
```

This program is designed to store any number of first and last names on tape. Needless to say, this program can only be used with a cassette recorder. The next program is the “counterpart” to the previous one. This program reads the data into the Commodore 64 and displays it on the screen (or printer). But first you have to rewind the tape to the beginning. Once this is done, you can apply the program.

270

<!-- TOC PAGE_281: Commodore 64 data read program -->

===========================================================
                      PAGE 281 OF 386                       
===========================================================

271

#2. Reading the data

```txt
10 REM***
20 REM READING NAME AND FIRST NAME FROM TAPE
30 REM VERSION FOR DATASETTE / COMMODORE 64
40 REM***
50 PRINT CHR$(147): CLEAR SCREEN
52 PRINT "OPEN FILE FOR READING"
54 PRINT
56 OPEN 1,1,0,"CBM 64 FILE"
60 INPUT#1,NA$
70 INPUT#1,VN$
80 IF ST AND 64 THEN GOTO 130: REM END OF FILE?
90 PRINT "READ - NAME = ";NA$
100 PRINT " - FIRST NAME = ";VN$
110 PRINTS
120 GOTO 60
130 PRINT "END OF FILE - NAME = ";NA$
140 PRINT " - FIRST NAME = ";VN$
150 CLOSE 1
160 END
```

This program now reads all the data that was written to the cassette with the first program and outputs it to the screen. However, if you want to output your data to a printer instead of the screen, you have to change a few lines:

```txt
58 OPEN 4.4
90 PRINT#4,"READ - NAME = ";NA$
100 PRINT#4," - FIRST NAME = ";VN$
110 PRINT#4
130 PRINT#4,"END OF FILE - NAME = ";NA$
140 PRINT#4," - FIRST NAME = ";VN$
155 CLOSE 4
```

The other lines remain unchanged. Now there is another one

<!-- TOC PAGE_282: Commodore 64 data appending code -->

===========================================================
                      PAGE 282 OF 386                       
===========================================================

another option, namely appending data. As discussed above, when using the cassette recorder as a disk, you cannot easily attach additional data. The file must first be completely read into memory. You then rewind the tape, open the file for writing and write the data you just read back onto tape. Finally, append the new data. Of course, the individual data can also be changed or deleted using the same procedure.

## 3. Appending data

```basic
10 REM***
20 REM ADD NAME AND FIRST NAME TO TAPE
30 REM VERSION FOR DATASETTE / COMMODORE 64
40 REM***
50 PRINT CHR$(147): CLEAR SCREEN
52 PRINT "OPEN FILE FOR READING"
54 PRINT
56 OPEN 1,1,0,"CBM 64 FILE"
60 DIM NA$(100),VN$(100): I=1: REM MAXIMUM 100 NAMES
70 INPUT#1,NA$: NA$(I)=NA$
80 INPUT#1,VN$: VN$(I)=VN$
90 IF STAND AND 64 THEN GOTO 130
100 IF I=100 THEN GOTO 130
110 I=I+1
120 GOTO 70
130 END=I
135 PRINT
140 PRINT "REWIND THE TAPE!"
150 PRINTS
160 INPUT "DONE (Y/N) ";JN$
170 IF JN$="N" THEN GOTO 130
180 IF JN$="J" THEN 210
190 PRINT "WRONG ENTRY!"
200 GOTO 150
210 PRINT "OPEN FILE TO ATTACH"
```

<!-- TOC PAGE_283: BASIC program data entry code -->===========================================================
                      PAGE 283 OF 386                       
===========================================================

220 PRINTS
230 OPEN 1,1,1,"CBM 64 FILE"
240 FOR I=1 TO END
250 PRINT#1,NA$(I)
260 PRINT#1,VN$(I)
270 NEXT I
280 PRINT "APPEND DATA:"
290 PRINTS
300 INPUT "NAME : ";NA$
310 INPUT "FIRST NAME : ";VN$
320 PRINTS
330 PRINT "WRITE - NAME = ";NA$
340 PRINT " - FIRST NAME = ";VN$
350 PRINTS
360 PRINT#1,NA$
370 PRINT#1,VN$
380 PRINTS
390 INPUT "CONTINUE (Y/N) ";JN$
400 IF JN$="J" THEN GOTO 300
410 IF JN$="N" THEN GOTO 440
420 PRINT "WRONG ENTRY!"
430 GOTO 380
440 CLOSE 1
450 END

You now have your own small address management system. The information about the addresses is still missing, but anyone with a little experience in programming should be able to expand the file to include the relevant information or be able to change the program.

Now we want to take a closer look at sequential file management on the floppy. Here, too, we want to use the three examples that we already discussed with the dataset. This will quickly show you the difference, but also the similarities in the application.

273

<!-- TOC PAGE_284: Commodore 64 disk writing routine -->

===========================================================
                      PAGE 284 OF 386                       
===========================================================

274

#1. Writing the data

This routine is of course similar to the routine that we already got to know when using the cassette recorder. This is quite understandable, since the principle of the sequential file is the same on the floppy. So the routine is:

```txt
10 REM***
20 REM WRITING NAME AND FIRST NAME ON DISK
30 REM VERSION FOR FLOPPY 1541 / COMMODORE 64
40 REM***
50 PRINT CHR$(147): CLEAR SCREEN
52 PRINT "OPENING THE FILE TO WRITE"
54 PRINT
56 OPEN 2,8,2,"CBM 64 FILE,S,W"
60 INPUT "NAME : ";NA$
70 INPUT "FIRST NAME : ";VN$
80 PRINTS
90 PRINT "WRITING - NAME = ";NA$
100 PRINT " - FIRST NAME = ";VN$
110 PRINTS
120 PRINT#2,NA$
130 PRINT#2,VN$
140 PRINTS
150 INPUT "CONTINUE (Y/N) ";JN$
155 PRINTS
160 IF JN$="J" THEN GOTO 60
170 IF JN$="N" THEN GOTO 200
180 PRINT "WRONG ENTRY!"
190 GOTO 140
200 CLOSE 2
210 END
```

Just like the program for writing to the cassette recorder discussed above, this program writes any number of names and first names to the disk, in sequential form. Of course, this only works until the...

<!-- TOC PAGE_285: Floppy disk capacity explanation -->

===========================================================
                      PAGE 285 OF 386                       
===========================================================

Floppy disk, or rather the space for a file is full. Although you need a lot of data to fill up a diskette like this, you should still make sure during programming that there are no errors or even a program crash because the diskette is suddenly full. So that you can get a certain impression of the capacity of the diskette, we would like to show a small calculation example at this point:

The Floppy 1541 has a total of space for 174,848 bytes (characters). These can be used for the files:

Sequential files: 168,656 characters
Relative files: 167,132 characters

A maximum of 144 programs (files) can be saved.

Now imagine that you want to program a complete address management system. For example, you need the following data:

|  DESCRIPTION | LENGTH |
| --- | --- |
|  number | 3 |
|  First name | 20 |
|  Last name | 20 |
|  Street, No. | 25 |
|  ZIP code | 4 |
|  Place of residence | 25 |
|  Country | 3 |
|  Telephone | 16 |
|  Remark | 50 |
|  Total: | 166 |

So your record is 166 characters long. Added to this are the terminating characters (CHR$(13)). So we have to for everyone

275

<!-- TOC PAGE_286: Floppy disk data storage guide -->===========================================================
                      PAGE 286 OF 386                       
===========================================================

Add one more character to the designation. This results in a total of 175 characters. How many data sets can we save on the diskette?

The invoice we need for this looks like this:

MAX: BYTES FOR SEQUENTIAL FILE / LENGTH OF A RECORD

or in our example:

$$
168,656 / 175 = 963.74857
$$

But since we can't easily create 963.74857 data records, and a little space on the disk never hurts, we would be able to create 950 data records in this case. This number is usually sufficient for normal applications. However, if you still want to create more data sets, you will either have to rewrite the program so that you can use multiple data disks, or use a larger floppy. For example, when using a Commodore 8250 floppy, the capacity increases by a factor of 6 per drive. So that would mean that you could store more than 5500 addresses with the Commodore 8250 Floppy.

And you even have this option with your Commodore 64. All you need is the floppy itself and the necessary IEC bus. Together with the DATA BECKER IEC bus, you also have the floppy disk commands of BASIC-4, i.e. the BASIC that the big Commodore also speaks.

## 2. Reading the data

Now to read the data. Here too, the program is virtually identical to the cassette version. For the sake of clarity, we would like to introduce this program again:

<!-- TOC PAGE_287: Commodore 64 BASIC data program -->

===========================================================
                      PAGE 287 OF 386                       
===========================================================

277

```basic
10 REM***
20 REM READING NAME AND FIRST NAME FROM DISK
30 REM VERSION FOR FLOPPY 1541 / COMMODORE 64
40 REM***
50 PRINT CHR$(147): CLEAR SCREEN
52 PRINT "OPEN FILE FOR READING"
54 PRINT
56 OPEN 2,8,2,"CBM 64 FILE,S,R"
60 INPUT#2,NA$
70 INPUT#2,VN$
80 IF ST AND 64 THEN GOTO 130: REM FILE END ?
90 PRINT "READ - NAME = ";NA$
100 PRINT " - FIRST NAME = ";VN$
110 PRINTS
120 GOTO 60
130 PRINT "END OF FILE - NAME = ";NA$
140 PRINT " - FIRST NAME = ";VN$
150 CLOSE 2
160 END
```

As you can see, there are no significant differences in this program from the cassette version. We have already said that there are no major programming deviations when processing files sequentially. The only difference is appending data. This is much easier with a floppy than with a cassette.

## 3. Appending data

```basic
10 REM***
20 REM ADD NAME AND FIRST NAME TO FILE
30 REM VERSION FOR FLOPPY 1541 / COMMODORE 64
40 REM***
50 PRINT CHR$(147): CLEAR SCREEN
52 PRINT "OPEN FILE TO ATTACH"
54 PRINT
56 OPEN 2,8,2,"CBM 64 FILE,S,A"

<!-- TOC PAGE_288: CBM 64 file handling code -->

===========================================================
                      PAGE 288 OF 386                       
===========================================================

60 INPUT "NAME : ";NA$
70 INPUT " : ";VN$
80 PRINTS
90 PRINT "WRITING - NAME = ";NA$
100 PRINT " - FIRST NAME = ";VN$
110 PRINTS
120 PRINT#2,NA$
130 PRINT#2,VN$
140 PRINTS
150 INPUT "CONTINUE (Y/N) ";JN$
155 PRINTS
160 IF JN$="J" THEN GOTO 60
170 IF JN$="N" THEN GOTO 200
180 PRINT "WRONG ENTRY!"
190 GOTO 140
200 CLOSE 2
210 END

As you have probably already noticed, this program is very similar to the program for writing data - with one exception: the OPEN command was used by

OPEN 2,8,2,"CBM 64 FILE,S,W"

on

OPEN 2,8,2,"CBM 64 FILE,S,A"

changed. This means that all data that is now written into the file with PRINT#2 does not overwrite the other data, but is appended to the existing file. This special feature enables relatively convenient handling of sequential files.

At the end of this chapter, let us point out useful areas of application for sequential files. They are for file management when it comes to quick access and

278

<!-- TOC PAGE_289: Sequential file description and usage -->===========================================================
                      PAGE 289 OF 386                       
===========================================================

The ability to easily change data is only suitable to a very limited extent. Sequential files are therefore mainly used in IT when a file needs to be created in a very specific form for a very specific purpose. An example would be exchanging data media with other computers. Sequential files, as long as they are saved in the same recording format (ASCII), can in principle be easily read from any other computer. This is usually not possible with relative or direct access files because the structure of such files often varies from operating system to operating system. Another example are log files that are created continuously and in which changes do not occur or are even not allowed to occur, e.g. the booking journal in financial accounting.

279

<!-- TOC PAGE_290: Commodore 64 file copying guide -->

===========================================================
                      PAGE 290 OF 386                       
===========================================================

280

#8.3 COPYING SINGLE AND DUAL DRIVE FILES

As described above, there are various ways to expand or change/delete existing sequential files. Sequential file management can be simple - but it shouldn't just be seen as a primitive way to save and re-read data.

In addition, it is often very useful or even necessary to duplicate data or files so that even after the corresponding file has been edited, all data is still in its original state, or so that a copy is available in the event of data loss.

Let's first look at copying files. In our example we assume that it is a file that was saved sequentially. There are several options to copy this file.

First, we could read the entire file into the Commodore 64's memory and then copy these records into the new file. However, this normally requires a very large amount of RAM (the floppy disk has around 170,000 characters, whereas the Commodore 64 only has around 30,000 under BASIC + program) or is limited to smaller files. In addition, a "middle ground" would be conceivable, in which the data sets are read in blocks of a certain number and then saved again in these blocks. But we want to stick to the simple method and read each sentence individually and write it down.

To do this, we need to create a second file that will be identical to the original file after the copying process. The only problem that arises here is that we have to know from the start how many fields each data record has. To make the program a little more convenient, we also want to show which data record we are currently reading and what the fields are.

<!-- TOC PAGE_291: BASIC file copy program code -->

===========================================================
                      PAGE 291 OF 386                       
===========================================================

50000 AD$="ORGINAL FILE": REM NAME OF THE FILE (ANY CHOICE)
50010 ND$="NEW FILE": REM NAME OF NEW FILE ( " )
50011 ND$=" :"+ND$+",S,W": REM NEW FILE TO WRITE
50020 INPUT "HOW MANY FIELDS PER RECORD ";AF$
50030 AF=VAL(AF$)
50040 DIM FB$(AF): REM DIMENSIONING OF THE FIELD NAMES
50045 DIM DF$(AF): REM " " DATA FIELDS
50050 FOR I=1 TO AF: REM ENTER ALL FIELD TITLES
50060 INPUT FB$(I)
50070 NEXT I
50080 PRINT
50090 PRINT "COPYING IN PROCESS!"
50100 OPEN 1,8,2,AD$: OPEN REM FILE FOR READING
50110 OPEN 2,8,3,ND$: OPEN REM FILE FOR WRITE
50112 DS=1: REM START WITH DATA SET 1
50115 PRINT "READ DATA RECORD NO.";DS: PRINT
50120 FOR I=1 TO AF: REM READ ALL DATA FIELDS
50130 INPUT#1,DF$(I)
50140 PRINT FB$(I);" : ";DF$(I)
50145 DZ=ST: REM DZ = FILE STATUS
50150 NEXT I
50160 PRINT
50170 PRINT "WRITE RECORD NO. ";DS: PRINT
50180 FOR I=1 TO AF: REM WRITE ALL DATA FIELDS
50190 PRINT#2,DF$(I)
50200 NEXT I
50210 PRINT
50220 IF DZ AND 64 THEN 51000: REM END OF FILE?
50230 DS=DS+1: REM NEXT DATA RECORD
50240 GOTO 50115
51000 PRINT "ALL DATA SETS TRANSFERRED!"
51010 PRINT
51020 CLOSE 2: REM CLOSE THE FILES
51030 CLOSE 1
51040 PRINT "END."
51050 END

281

<!-- TOC PAGE_292: Floppy disk file copy guide -->===========================================================
                      PAGE 292 OF 386                       
===========================================================

With this program you can now easily copy your existing sequential files as long as you know the structure - more precisely the number of data fields per data record.

But this routine does have one problem. If you want to copy a very large file, you will soon reach the limits of the floppy. You will see that you cannot easily copy files that are, for example, 100,000 characters long (approx. 100 KB) with this program, since you create a target file that not only has the same structure as the original file, but also exactly the same size.

In order to be able to copy larger files, you either have to work with 2 drives or with 2 different floppy disks.

The easiest and safest way to accomplish such a duplication is with 2 drives. To do this, one of your drives must be defined as device 8 and the other as device 9. This can be done either by changing the software or by making a small change to one of the floppy disks, which the technician can easily carry out.

If you now have a floppy as device 9, you can modify the program specified above so that large files can also be copied.

50110 OPEN 2,2,3,ND$: OPEN REM FILE FOR WRITE

Data is now read from drive 8, displayed on the screen and saved again on drive 9.

Another tip on the side. Many programmers use data record 0 (or 1) or a second file for their files as a special data record (or file) with information about the structure of the file. For example, it would be very useful if you had the number of fields and the number of records as the first information

282

<!-- TOC PAGE_293: BASIC program file editing -->

===========================================================
                      PAGE 293 OF 386                       
===========================================================

would have saved. This would then eliminate the need for manual entry. In addition, you would now know at any time how many data records still need to be read and how large the data actually is. Once you have saved these two variables (in the ORGINALDFILE file), you will of course have to modify the program a little.

50012 OPEN 1,8,2,AD$: OPEN REM ORGINAL FILE FOR READING
50013 INPUT#1,AF$: REM NUMBER OF FIELDS
50014 INPUT#1,AD$: REM NUMBER OF DATA RECORDS
50015 CLOSE 1

Delete line 50020.

50035 AD=VAL(AD$)
50111 INPUT#1,AF$: INPUT#2,AD$: PRINT#2,AF$: PRINT#2,AD$
50112 FOR DS=1 TO AD

Delete lines 50145 and 50220.

50230 NEXT DS

Delete line 50240.

A **parameterized** file like this is much easier and clearer to edit.

Appending records follows the same principle as copying. First, the file is copied with the program shown above, then file 2, i.e. the new file, is not closed, but is written to further using the usual PRINT# commands. Once this file has been expanded in this way, it can be copied back to the original file.

283

<!-- TOC PAGE_294: Commodore 64 relative file guide -->===========================================================
                      PAGE 294 OF 386                       
===========================================================

8.4 HOW TO DO IT FASTER: RELATIVE FILES

The larger Commodore computers with their BASIC 4.0 and everyone who uses the Commodore 64 MAXI or the DATA BECKER IEC-BUS have a much more convenient and powerful file type for data storage available with relative files. In a relative file, each record has a number that also indicates its location on the disk relative to the beginning of the file. For example, you can set up a file management system with direct access for a relative file. There are basically two options:

1.) You use the ordering criterion of the relative file, namely the consecutively assigned number, as an access key for your file. For example, in an invoice file you can equate the record number with the invoice number. This would always allow quick, direct access to the respective invoice using the invoice number. The same applies to article numbers and other keys that can be assigned arbitrarily.

2.) You create a corresponding table in which the record number and key are compared. For example, if you have organized your address file by name and want to find the address with the name MÜLLER, you first look for the record number that belongs to the name MÜLLER from the table and then access this data record directly. This method is significantly faster and more elegant than reading a sequential file until it finds the name.

Unfortunately, the owner of a standard Commodore 64 that has not been supplemented with the BASIC 4.0 diskette commands via MAXI 64, IEC-BUS 64 or MASTER 64, for example, cannot normally work with such powerful relative files. The Floppy VC-1541 knows its operating system, DOS,

284

<!-- TOC PAGE_295: Commodore 64 relative file guide -->

===========================================================
                      PAGE 295 OF 386                       
===========================================================

the relative files, but the necessary commands are not included in the BASIC of the standard Commodore 64.

We would like to show you below how you can still use relative files with the Commodore 64.

It is possible to use various CHR$ sequences to tell the computer which data record you want to read or write. So the whole process consists of two different parts:

1.) Open the relative file with the usual OPEN command:

OPEN file number, device address, channel number, "Name,L,"+CHR$(length)

We already know the first part of this OPEN command from the sequential file. After specifying the name, however, an 'L' now follows. This 'L' stands for LENGTH - the Floppy 1541 now knows that a relative file should be opened. This is followed by a very important CHR$ command. This command now specifies the length of a data record. If you still remember our sequential file management, with which we wanted to process an address management, we would have to specify the length 175 here. The Commodore 64 or the floppy operating system allows a maximum data record length of 254 characters. If a data record is to have more than 254 characters, you must either open another file and split the one data record into two data records, or you can write to the same file and consider every second data record as the first part of the 'large data record'.

2.) The positioning of the data record pointer:

PRINT # Channel number, "P"+CHR$(channel number)+CHR$(low)+CHR$(high)

The special feature of this command actually begins after specifying the file number. The 'P' here means POSITION, and tells the operating system that the following CHR$ sequence is the

285

<!-- TOC PAGE_296: Data record positioning instructions -->===========================================================
                      PAGE 296 OF 386                       
===========================================================

should set the data record pointer to the data record specified by LOW and HIGH (we will show you later how LOW and HIGH are calculated).

The command can even be expanded. If you place another CHR$ command at the end of the CHR$ sequence, this indicates at which point within the data record it should be positioned. So you can search specifically for a very specific character or word.

There is another very important feature that should be taken into account when programming both the sequential and the realative file:

A terminating character (CHR$(13)) must be placed after each FIELD that was written into the data record. Otherwise the computer will not be able to distinguish between the different fields. For this reason, we always put the PRINT# commands on two lines, so that a carriage return, i.e. CHR$(13), is automatically saved.

A concrete example makes it easier to see what we are trying to explain here. That's why we've added a fully functional warehouse management program to this chapter. This makes it easier for you to see all the functions in this chapter applied in a program. We believe that the effort of entering this program is worth it, considering that even small changes to this program can be used to create address management, video cassette management, and the like.

But now something about the HIGH and LOW addresses mentioned above. These HIGH and LOW addresses together result in the actual data record number. The formula for this is:

$$
\text{data record number} = \text{HIGH} \times 256 + \text{LOW}
$$

<!-- TOC PAGE_297: Data address calculation guide -->

===========================================================
                      PAGE 297 OF 386                       
===========================================================

This means we can also read records whose address is greater than 255. If, for example, the 78th sentence is to be read, LOW and HIGH must first be calculated:

$$
\text{HIGH} = \text{INT} \left( \frac{\text{record number}}{256} \right)
$$

$$
\text{LOW} = \text{record number} - \text{HIGH} \times 256
$$

or using a concrete example:

$$
\text{HIGH} = \text{INT} \left( \frac{78}{256} \right) : \text{LB} = 78 - \text{HB} \times 256
$$

and as a result for HIGH and LOW:

$$
\text{HIGH} = 0, \text{LOW} = 78
$$

This calculation in itself is quite pointless, since we want to read a data set that is smaller than 256. But this example still shows what such a calculation should look like.

This result must now be inserted into the formula for positioning the pointers. This formula then reads like this:

$$
\text{PRINT} \# \text{channel number}, \text{"P";CHR$(channel number)} + \text{CHR$(0)} + \text{CHR$(78)}
$$

In our warehouse management program you will find, for example, the following structure:

$$
\text{PRINT} \# 15, \text{"P"} + \text{CHR$(3)} + \text{CHR$(231)} + \text{CHR$(3)} + \text{CHR$(1)}
$$

This now means that the pointer should be set to the 999 data record, namely to the first character.

However, before you can use the file, it must first be prepared for relative use. This is done by

287

<!-- TOC PAGE_298: Diskette formatting instructions manual -->===========================================================
                      PAGE 298 OF 386                       
===========================================================

288

First the pointer in the command channel (15) is opened (see above), and then this data record is described with the character 255 (CHR$(255)). This character tells the operating system that there is a data record at this location that already exists, but in which nothing has been saved yet. In our example, all 999 records are marked with this 255.

The data records can now be written to this file - of course not more than was specified when the file was opened. However, if you try to write a data record that is outside the permitted range, the computer reports the error message RECORD NOT PRESENT - so this data record does not exist.

But now something about our program. After you start it with RUN, the question appears as to whether the floppy disk device is ready. This message will appear until you press the 'J' key. You will then be asked if you want to use a new diskette. In this case, new not only means that the diskette can be unformatted, but also that no file is yet available. But be careful, the disk will be formatted in any case. So don't use your program or your data disk for this. When the process is finished, the main menu appears. Here you can now call up one of the 6 possible functions.

If you want to design a data record, remember that the input must not be longer than is specified in the DATA lines (30-82). These lines are structured so that the name is listed first and then the length of the description. If you want to delete a data record that has already been entered, go to the CHANGE routine and write a spider monkey (@) as the first character of the product type. This sentence is therefore marked as deleted.

If you are asked to enter an item number in any subprogram, you can do so by entering

<!-- TOC PAGE_299: VAT rate selection guide -->

===========================================================
                      PAGE 299 OF 386                       
===========================================================

"END" to return to the main or main menu.

Lines 11 to 14 represent the current VAT rate. ME(1) and ME(2) are the two old rates of 6.5% and 13%. The next two are the new rates of 7% and 14%. So if you are asked for the VAT rate, simply enter a '1' for 6.5%, a '2' for 13%, a '3' for 7% and a '4' for 14%. The computer then calculates the respective VAT rate from this.

289

<!-- TOC PAGE_300: Program instructions and guidelines -->

===========================================================
                      PAGE 300 OF 386                       
===========================================================

290

However, there is one special feature that needs to be taken into account with this program. Item numbers that range from 800 to 999 (999 is the largest possible number) are not counted as items but as miscellaneous expenses or income. This means you can also monitor your private accounts, bank accounts, etc. at the same time as the various items. These accounts are entered in the RECEIPT ENTRY subprogram. If the first entry, i.e. the first "receipt" or more precisely the invoice, was a number greater than 799, the computer expects further entries of this type. This means that you cannot enter items and invoices alternately, but only separately.

It is also important to ensure that the printer and floppy are always switched on when working with this program. But if you don't have a printer, you have to rewrite the program. You can see from the Print#4 commands which lines should be output to the printer.

If you support additional branches or people with this program, we recommend that you create a new diskette for each branch or person. Then you will always know about your financial situation.

We hope that with the help of this program you have gained an insight into data processing, and especially into data processing with relative files. At first glance it looks more difficult than it is. With a little practice, you will quickly be able to design such programs yourself.

<!-- TOC PAGE_301: BASIC inventory management program -->===========================================================
                      PAGE 301 OF 386                       
===========================================================

10 CLR
15 ME(1)=1.065: ME(2)=1.13: ME(3)=1.07 :ME(4)=1.14
20 FOR I=1 TO 7: READ TD$(I),TD(I): NEXT I
30 DATA "1) ITEM NO. :",3
32 DATA "2) TYPE OF GOODS :",20
34 DATA "3) NUMBER :",3
36 DATA "4) UNIT PRICE EK:",7
38 DATA "5) TOTAL PRICE EK:",8
40 DATA "6) UNIT PRICE Sales:",7
42 DATA "7) TOTAL PRICE Sales:",8
50 FOR I=1 TO 3: READ TI$(I),TI(I): NEXT I
56 DATA "1) ARTICLE NO. :",3
58 DATA "2) TYPE OF GOODS :",20
60 DATA "3) VAT GROUP :",1
70 FOR I=1 TO 4: READ TT$(I),TT(I): NEXT I
76 DATA "1) BRANCH NO. :",1
78 DATA "2) DATE :",8
80 DATA "3) INVOICE NO. :",8
82 DATA "4) DOCUMENT NO. :",8
100 PRINT CHR$(147)
110 PRINT "***","
120 PRINT "*FILE MANAGEMENT PROGRAM 1.0 *";
130 PRINT "***","
140 PRINT: PRINT
150 PRINT "DISKET DEVICE CONNECTED (Y/N)?";
160 GET A$: IF A$="" THEN 160
170 IF A$&lt;&gt;"J" THEN 160
180 PRINT A$
190 OPEN 15,8,15,"IO": CLOSE 15
200 PRINT "CREATE NEW DATA DISK (Y/N)?";
210 GET A$: IF A$="" THEN 210
220 IF A$&lt;&gt;"J" THEN 300
222 PRINT A$
230 OPEN 15,8,15,"N:DATA DISK,AH"
240 OPEN 1,8,3,"O:ARTDAT,L,"+CHR$(64)
250 PRINT#15,"P"+CHR$(3)+CHR$(231)+CHR$(3)+CHR$(1)
260 PRINT#1,CHR$(255);

291

<!-- TOC PAGE_302: German inventory management program -->

===========================================================
                      PAGE 302 OF 386                       
===========================================================

270 RM=INT(167132/64)
280 CLOSE 1: CLOSE 15
300 CHR$PRINT(147)
310 PRINT "***";
320 PRINT "*FILE MANAGEMENT PROGRAM 1.0 *";
330 PRINT "***";
340 PRINT: PRINT
345 PRINT TAB(15);"MAIN MENU": PRINT: PRINT
350 PRINT "1) ENTER ITEM FILE": PRINT
355 PRINT "2) CHANGE THE ARTICLE FILE": PRINT
360 PRINT " 3) ENTERING THE RECEIPTS": PRINT
365 PRINT " 4) PRINTING THE ITEM LIST": PRINT
370 PRINT "5) PRINTING THE EVALUATION": PRINT
375 PRINT "6) END OF PROGRAM": PRINT: PRINT
380 PRINT "PLEASE SELECT (1-6) : ";
390 GET A$: IF A$="" THEN 390
400 A=VAL(A$): IF A&lt;1 OR A&gt;6 THEN 390
410 PRINT A$
420 FOR I=1 TO 1000: NEXT
430 ON A GOTO 1000, 2000, 3000, 4000, 5000, 6000
1000 OPEN 15,8,15: OPEN 8,8,8,"0:ARTDAT"
1002 GOSUB 12000
1005 PRINT CHR$(147)
1010 PRINT "***";
1020 PRINT "*FILE MANAGEMENT PROGRAM 1.0 *";
1030 PRINT "***";
1040 PRINT: PRINT
1050 PRINT TAB(7);"ENTERING ITEM FILE": PRINT: PRINT
1060 FOR I=1 TO 3
1065 TE$(I)="""
1070 PRINT TI$(I);
1080 INPUT TE$(I)
1090 PRINT
1092 IF TE$(1)="END" THEN 1200
1095 IF LEN(TE$(I))&gt;TI(I) THEN 1065
1100 NEXT
1102 FOR I=4 TO 8: TE$(I)="": NEXT

292

<!-- TOC PAGE_303: Article management program code -->

===========================================================
                      PAGE 303 OF 386                       
===========================================================

1110 RN=VAL(TE$(1))
1120 IF RN&lt;1 OR RN&gt;999 THEN 1005
1130 GOSUB 10000
1140 GOSUB 10070
1150 GOTO 1005
1200 CLOSE 8: CLOSE 15
1220 GOTO 300
2000 OPEN 15,8,15: OPEN 8,8,8,"O:ARTDAT"
2002 GOSUB 12000
2005 PRINT CHR$(147)
2010 PRINT "***";
2020 PRINT "*FILE MANAGEMENT PROGRAM 1.0*";
2030 PRINT "***";
2040 PRINT: PRINT
2050 PRINT TAB(8);"CHANGE ARTICLE FILE": PRINT: PRINT
2055 TE$(1)=""
2060 PRINT TI$(1);
2070 INPUT TE$(1)
2080 PRINT
2090 IF TE$(1)="END" THEN 2400
2100 IF LEN(TE$(1))&gt;TI(1) THEN 2055
2110 RN=VAL(TE$(1))
2120 IF RN&lt;1 OR RN&gt;999 THEN 2005
2130 GOSUB 10000
2140 GOSUB 10030
2142 IF VAL(TE$(1))&lt;&gt;RN THEN 2005
2150 PRINT CHR$(147)
2160 PRINT "***";
2170 PRINT "*FILE MANAGEMENT PROGRAM 1.0 *";
2180 PRINT "***";
2190 PRINT: PRINT
2200 PRINT TAB(8);"CHANGE ARTICLE FILE": PRINT: PRINT
2210 FOR I=1 TO 3
2220 PRINT TI$(I);"? ";
2230 PRINT TE$(I)
2240 PRINT CHR$(145);
2250 PRINT TI$(I);

293

<!-- TOC PAGE_304: BASIC data management program code -->===========================================================
                      PAGE 304 OF 386                       
===========================================================

2260 INPUT TE$(I)
2270 PRINT
2280 IF TE$(1)="END" THEN 2400
2290 IF LEN(TE$(I))&gt;TI(I) THEN 2250
2300 NEXT
2310 RN=VAL(TE$(1))
2320 IF RN&lt;1 OR RN&gt;999 THEN 2005
2330 GOSUB 10000
2340 GOSUB 10070
2400 CLOSE 4: CLOSE 8: CLOSE 15
2430 GOTO 300
2530 GOTO 3005
3000 OPEN 15,8,15: OPEN 8,8,8,"0:ARTDAT"
3002 GOSUB 12000
3005 PRINT CHR$(147)
3010 PRINT "***";
3020 PRINT "*FILE MANAGEMENT PROGRAM 1.0 *";
3030 PRINT "***";
3040 PRINT: PRINT
3050 PRINT TAB(7);"ENTERING THE RECEIPTS": PRINT: PRINT
3060 TE$(1)=""
3070 PRINT TE$(1);
3080 INPUT TE$(1)
3090 PRINT
3100 IF TE$(1)="END" THEN 3700
3110 IF LEN(TE$(1))&gt;TI(1) THEN 3060
3120 RN=VAL(TE$(1))
3130 IF RN&lt;1 OR RN&gt;999 THEN 3005
3132 IF DW=1 AND RN&gt;799 THEN 3005
3134 IF DW=2 AND RN&lt;800 THEN 3000
3140 GOSUB 10000
3150 GOSUB 10030
3152 IF VAL(TE$(1))&lt;&gt;RN THEN 3005
3154 IF LEFT$(TE$(2),1)="@" THEN 3005
3160 PRINT CHR$(147)
3170 PRINT "***";
3180 PRINT "*FILE MANAGEMENT PROGRAM 1.0 *";
294

<!-- TOC PAGE_305: Basic input validation code -->

===========================================================
                      PAGE 305 OF 386                       
===========================================================

295

3290 PRINT "***";"
3200 PRINT: PRINT
3210 PRINT TAB(7); "ENTERING THE RECEIPTS": PRINT: PRINT
3212 FOR I=1 TO 5
3214 TH$(I)=TE$(I+3)
3216 NEXT
3220 FOR I=1 TO 2
3230 PRINT TD$(I); "?"; TE$(I)
3235 TX$(I)=TE$(I)
3240 PRINT
3250 NEXT
3255 TX$(3)=TE$(3)
3260 PRINT TD$(3);
3270 INPUT TX$(4)
3275 TE$(4)=TX$(4)
3280 PRINT
3285 IF VAL(TE$(4))&lt;-999 OR VAL(TE$(4))&gt;999 THEN 3260
3287 IF LEN(TE$(4))&gt;TD(3) THEN 3260
3290 PRINT TD$(4);
3295 TE$(5)=""
3300 INPUT TX$(5)
3305 TE$(5)=TX$(5)
3310 PRINT
3315 IF LEN(TE$(5))&gt;TD(4) THEN 3290
3320 PRINT TD$(6);
3325 TE$(7)=""
3330 INPUT TX$(7)
3335 TE$(7)=TX$(7)
3340 PRINT
3345 IF LEN(TE$(7))&gt;TD(6) THEN 3320
3350 TH=VAL(TE$(5))*VAL(TE$(4))
3351 TX$(6)=STR$(TH)
3352 TH=TH+VAL(TH$(3))
3355 TE$(6)=STR$(TH)
3360 TH=VAL(TE$(7))*VAL(TE$(4))
3361 TX$(8)=STR$(TH)
3362 TH=TH+VAL(TH$(5))

<!-- TOC PAGE_306: BASIC program code listing -->

===========================================================
                      PAGE 306 OF 386                       
===========================================================

3365 TE$(8)=STR$(TH)
3370 TH=VAL(TE$(5))
3371 IF VAL(TE$(4))&lt;1 THEN TH=-TH
3372 TH=TH+VAL(TH$(2))
3375 TE$(5)=STR$(TH)
3380 TH=VAL(TE$(7))
3381 IF VAL(TE$(4))&lt;1 THEN TH=-TH
3382 TH=TH+VAL(TH$(4))
3385 TE$(7)=STR$(TH)
3390 TH=VAL(TE$(4))
3392 TH=TH+VAL(TH$(1))
3395 TE$(4)=STR$(TH)
3460 RN=VAL(TE$(1))
3470 GOSUB 10000
3480 GOSUB 10070
3485 FOR I=1 TO 8: TE$(I)=TX$(I): TX$(I)="": NEXT
3490 IF DW=0 AND VAL(TE$(1))&lt;800 THEN DW=1: GOSUB 5360: GOTO 3510
3500 IF DW=0 AND VAL(TE$(1))&gt;799 THEN DW=2: GOSUB 7005: GOTO 3520
3510 IF DW=1 THEN GOSUB 5520: GOTO 3530
3520 IF DW=2 THEN GOSUB 7120
3530 GOTO 3005
3700 IF DW=1 THEN GOSUB 5590: GOTO 3800
3710 IF DW=2 THEN GOSUB 7190
3800 DW=0: DV=0
3999 CLOSE 4: CLOSE 8: CLOSE 15: GOTO 300
4000 OPEN 15,8,15: OPEN 8,8,8,"0:ARTDAT"
4002 GOSUB 12000
4005 PRINT CHR$(147)
4010 PRINT "***";
4020 PRINT "*FILE MANAGEMENT PROGRAM 1.0 *";
4030 PRINT "***";
4040 PRINT: PRINT
4050 PRINT TAB(8);"PRINT ITEM LIST": PRINT: PRINT
4060 FOR I=1 TO 2
4070 TE$(I)=""
4080 PRINT TT$(I);
4090 INPUT TE$(I)

296

<!-- TOC PAGE_307: Article list print program -->===========================================================
                      PAGE 307 OF 386                       
===========================================================

4100 PRINTS
4110 IF TE$(1)="END" THEN 4999
4120 IF LEN(TE$(I))&gt;TT(I) THEN 4070
4130 NEXT
4135 TE$(3)="": TE$(4)=""
4140 IF DV=1 THEN RETURN
4200 PRINT CHR$(147)
4210 PRINT "***"
4220 PRINT "*FILE MANAGEMENT PROGRAM 1.0 *";
4230 PRINT "***"
4240 PRINT: PRINT
4250 PRINT TAB(8);"PRINT ITEM LIST": PRINT: PRINT
4260 PRINT "IS THE PRINTER TURNED ON (Y/N)?";
4270 GET A$: IF A$="" THEN 4270
4280 IF A$&lt;&gt;"J" THEN 4270
4290 PRINT A$
4300 OPEN 4.4
4310 PRINT#4,"BRANCH NO. ";TE$(1);
4330 PRINT#4,CHR$(16);"20";"DATE ​​";TE$(2);
4340 PRINT#4,CHR$(16);"40";"INVOICE NO. ";TE$(3);
4345 PRINT#4,CHR$(16);"60";"RECEIPT NO. ";TE$(4)
4350 PRINT#4
4360 PRINT#4,"ITEM NO.";
4375 PRINT#4,CHR$(16);"20";"PRODUCT TYPE";
4385 PRINT#4,CHR$(16);"60";"VAT GROUP"
4390 PRINT#4,"---";
4405 PRINT#4,CHR$(16);"20";"---";
4415 PRINT#4,CHR$(16);"60";"---"
4420 FOR RN=1 TO 999
4430 GOSUB 10000
4440 GOSUB 10030
4442 IF VAL(TE$(1))&lt;&gt;RN THEN 4480
4444 IF LEFT$(TE$(2,1)=" @ " THEN 4480
4450 PRINT#4,TE$(1);
4460 PRINT#4,CHR$(16);"20";TE$(2);
4470 PRINT#4,CHR$(16);"60";TE$(3)
4480 NEXT

<!-- TOC PAGE_308: BASIC data management program code -->

===========================================================
                      PAGE 308 OF 386                       
===========================================================

4490 FOR I=1 TO 3
4492 PRINT#4
4494 NEXT
4999 CLOSE 4: CLOSE 8: CLOSE 15: GOTO 300
5000 OPEN 15,8,15: OPEN 8,8,8,"O:ARTDAT"
5002 GOSUB 12000
5005 PRINT CHR$(147)
5010 PRINT "***";
5020 PRINT "*FILE MANAGEMENT PROGRAM 1.0 *";
5030 PRINT "***";
5040 PRINT: PRINT
5050 PRINT TAB(9);"PRINTING THE EVALUATION": PRINT: PRINT
5060 FOR I=1 TO 4
5070 TE$(I)=""
5080 PRINT TT$(I);
5090 INPUT TE$(I)
5100 PRINTS
5110 IF TE$(1)="END" THEN 5999
5120 IF LEN(TE$(I))&gt;TT(I) THEN 5070
5125 IF DV=0 AND I=2 THEN I=4
5130 NEXT
5140 IF DV=1 THEN RETURN
5200 PRINT CHR$(147)
5210 PRINT "***";
5220 PRINT "*FILE MANAGEMENT PROGRAM 1.0 *";
5230 PRINT "***";
5240 PRINT: PRINT
5250 PRINT TAB(9);"PRINTING THE EVALUATION": PRINT: PRINT
5252 SA=0: SE=0: SG=0: SF=0: SH=0
5255 FOR I=1 TO 4: M1(I)=0: M2(I)=0: NEXT
5260 PRINT "IS THE PRINTER TURNED ON (Y/N)?";
5270 GET A$: IF A$="" THEN 5270
5280 IF A$&lt;&gt;"J" THEN 5270
5290 PRINT A$
5300 OPEN 4.4
5310 PRINT#4,"BRANCH NO. ";TE$(1);
5330 PRINT#4,CHR$(16);"20";"DATE ​​";TE$(2);

298

<!-- TOC PAGE_309: Invoice data output code -->

===========================================================
                      PAGE 309 OF 386                       
===========================================================

5335 IF DV=0 THEN PRINT#4: GOTO 5350
5340 PRINT#4,CHR$(16);"40";"INVOICE NO. ";TE$(3);
5345 PRINT#4,CHR$(16);"60";"RECEIPT NO. ";TE$(4)
5350 PRINT#4
5355 IF DV=1 THEN RETURN
5360 PRINT#4,"ART. NO.";
5370 PRINT#4,CHR$(16);"10";"ANZ.";
5375 PRINT#4,CHR$(16);"15";"PRODUCT TYPE";
5380 PRINT#4,CHR$(16);"40";"SINGLE EK";
5390 PRINT#4,CHR$(16);"50";"GESA. EK";
5400 PRINT#4,CHR$(16);"60";"SINGLE VK";
5410 PRINT#4,CHR$(16);"70";"TOTAL. VK"
5420 PRINT#4,"---";
5425 PRINT#4,CHR$(16);"10";"---";
5430 PRINT#4,CHR$(16);"15";"---";
5440 PRINT#4,CHR$(16);"40";"---";
5450 PRINT#4,CHR$(16);"50";"---";
5460 PRINT#4,CHR$(16);"60";"---";
5470 PRINT#4,CHR$(16);"70";"---"
5475 IF DV=1 THEN RETURN
5480 FOR RN=1 TO 799
5490 GOSUB 10000
5500 GOSUB 10030
5510 IF VAL(TE$(1))&lt;&gt;RN THEN 5580
5515 IF LEFT$(TE$(2,1)=" @ " THEN 5580
5520 PRINT#4,TE$(1);
5525 PRINT#4,CHR$(16);"10";TE$(4);
5530 PRINT#4,CHR$(16);"15";TE$(2);
5540 PRINT#4,CHR$(16);"40";TE$(5);
5550 PRINT#4,CHR$(16);"50";TE$(6);
5560 PRINT#4,CHR$(16);"60";TE$(7);
5570 PRINT#4,CHR$(16);"70";TE$(8)
5571 SA=SA+VAL(TE$(4))
5572 SE=SE+VAL(TE$(5))
5573 SG=SG+VAL(TE$(6))
5574 SF=SF+VAL(TE$(7))
5575 SH=SH+VAL(TE$(8))

<!-- TOC PAGE_310: VAT calculation program code -->===========================================================
                      PAGE 310 OF 386                       
===========================================================

5576 IF VAL(TE$(3)) &lt; 1 OR VAL(TE$(3)) &gt; 4 THEN 5579
5577 M1(VAL(TE$(3)))=M1(VAL(TE$(3)))+(VAL(TE$(6))*ME(VAL(TE$(3)))-VAL(TE$(6)))
5578 M2(VAL(TE$(3)))=M2(VAL(TE$(3)))+(VAL(TE$(8))-VAL(TE$(8))/ME(VAL(TE$(3))))
5579 IF DV=1 THEN RETURN
5580 NEXT
5590 PRINT#4, "---";
5600 PRINT#4, CHR$(16); "10"; "---";
5605 PRINT#4, CHR$(16); "15"; "---";
5610 PRINT#4, CHR$(16); "40"; "---";
5620 PRINT#4, CHR$(16); "50"; "---";
5630 PRINT#4, CHR$(16); "60"; "---";
5640 PRINT#4, CHR$(16); "70"; "---"
5650 PRINT#4, "SUM:";
5660 PRINT#4, CHR$(16); "09"; SA;
5670 PRINT#4, CHR$(16); "39"; SE;
5680 PRINT#4, CHR$(16); "49"; SG;
5690 PRINT#4, CHR$(16); "59"; SF;
5700 PRINT#4, CHR$(16); "69"; SH
5710 FOR I=1 TO 3: PRINT#4: NEXT
5720 PRINT#4, "VAT EK 6.5% = ";M1(1);
5725 PRINT#4, CHR$(16); "40"; "VAT EK 7% = ";M1(3)
5730 PRINT#4, "VAT EK 13.0% = ";M1(2);
5735 PRINT#4, CHR$(16); "40"; "VAT EK 14% = ";M1(4)
5740 PRINT#4, "VAT sales 6.5% = ";M2(1);
5745 PRINT#4, CHR$(16); "40"; "VAT Sales 7% = ";M2(3)
5750 PRINT#4, "VAT sales 13.0% = ";M2(2);
5755 PRINT#4, CHR$(16); "40"; "VAT Sales 14% = ";M2(4)
5756 FOR I=1 TO 3: PRINT#4: NEXT
5760 PRINT#4, "TOTAL EK. = ";SG+M1(1)+M1(2)+M1(3)+M1(4)
5770 PRINT#4, "TOTAL SALES = ";SH-M2(1)-M2(2)-M2(3)-M2(4)
5775 FOR I=1 TO 3: PRINT#4: NEXT
5777 IF DV=1 THEN RETURN
5780 GOSUB 7000
5999 CLOSE 4: CLOSE 8: CLOSE 15: GOTO 300
6000 CLOSE 4: CLOSE 8: CLOSE 15

300

<!-- TOC PAGE_311: Financial report summary section -->

===========================================================
                      PAGE 311 OF 386                       
===========================================================

6030 PRINT CHR$(147)
6040 END
7000 S1=0: S2=0
7005 PRINT#4, "ART. NO.";
7010 PRINT#4, CHR$(16); "15"; "ART";
7020 PRINT#4, CHR$(16); "40"; "EXPENDITURE";
7030 PRINT#4, CHR$(16); "60"; "REVENUE";
7040 PRINT#4, "---";
7050 PRINT#4, CHR$(16); "15"; "---";
7060 PRINT#4, CHR$(16); "40"; "---";
7070 PRINT#4, CHR$(16); "60"; "---";
7075 IF DV=1 THEN RETURN
7080 FOR RN=800 TO 999
7090 GOSUB 10000
7100 GOSUB 10030
7110 IF VAL(TE$(1)) &lt;&gt; RN THEN 7180
7120 PRINT#4, TE$(1);
7130 PRINT#4, CHR$(16); "15"; TE$(2);
7140 PRINT#4, CHR$(16); "40"; TE$(5);
7150 PRINT#4, CHR$(16); "60"; TE$(7)
7160 S1=S1+VAL(TE$(5))
7170 S2=S2+VAL(TE$(7))
7171 IF VAL(TE$(3)) &lt; 1 OR VAL(TE$(3)) &gt; 4 THEN 7175
7172 M2(VAL(TE$(3))) = M2(VAL(TE$(3)) + (VAL(TE$(7)) - VAL(TE$(7)) / ME(VAL(TE$(3))))
7173 M1(VAL(TE$(3))) = M1(VAL(TE$(3)) + (VAL(TE$(5)) - VAL(TE$(5)) / ME(VAL(TE$(3))))
7175 IF DV=1 THEN RETURN
7180 NEXT
7190 PRINT#4, "---";
7200 PRINT#4, CHR$(16); "15"; "---";
7210 PRINT#4, CHR$(16); "40"; "---";
7220 PRINT#4, CHR$(16); "60"; "---"
7230 PRINT#4, "BUZZ.";
7240 PRINT#4, CHR$(16); "39"; S1;
7250 PRINT#4, CHR$(16); "59"; S2
7260 FOR I=1 TO 3: PRINT#4: NEXT

<!-- TOC PAGE_312: VAT calculation program code -->

===========================================================
                      PAGE 312 OF 386                       
===========================================================

7270 PRINT#4,"VAT EK 6.5% = ";M1(1);
7280 PRINT#4,CHR$(16);"40";"VAT EK 7% = ";M1(3)
7290 PRINT#4,"VAT EK 13.0% = ";M1(2);
7300 PRINT#4,CHR$(16);"40";"VAT EK 14% = ";M1(4)
7310 PRINT#4,"VAT sales 6.5% = ";M2(1);
7320 PRINT#4,CHR$(16);"40";"VAT sales 7% = ";M2(3)
7330 PRINT#4,"VAT sales 13.0% = ";M2(2);
7340 PRINT#4,CHR$(16);"40";"VAT VK 14% = ";M2(4)
7350 FOR I=1 TO 3: PRINT#4: NEXT
7360 PRINT#4,"OUTPUT = ";S1-M1(1)-M1(2)-M1(3)-M1(4)
7370 PRINT#4,"REVENUE " ";S2-M2(1)-M2(2)-M2(3)-M2(4)
7380 FOR I=1 TO 3: PRINT#4: NEXT
7999 RETURN
8000 PRINT CHR$(147)
8010 PRINT "***";
8020 PRINT "*FILE MANAGEMENT PROGRAM 1.0 *";
8030 PRINT "***";
8040 PRINT: PRINT
8050 PRINT TAB(7);"ENTERING THE RECEIPTS": PRINT: PRINT
8060 SA=0: SE=0: SG=0: SF=0: SH=0: S1=0: S2=0
8070 FOR I=1 TO 4
8072 M1(I)=0
8074 M2(I)=0
8076 NEXT
8080 PRINT "IS THE PRINTER TURNED ON (Y/N)?";
8090 GET A$: IF A$="" THEN 8090
8100 IF A$&lt;&gt;"J" THEN 8090
8110 PRINT A$
8120 OPEN 4.4
8130 RETURN
8500 PRINT CHR$(147)
8510 PRINT "***";
8520 PRINT "*FILE MANAGEMENT PROGRAM 1.0 *";
8530 PRINT "***";
8540 PRINT: PRINT
8550 PRINT TAB(7);"ENTERING THE RECEIPTS": PRINT: PRINT
8560 GOSUB 5060

302

<!-- TOC PAGE_313: BASIC program error handling code -->===========================================================
                      PAGE 313 OF 386                       
===========================================================

8570 GOSUB 5310
8580 RETURN
10000 HB=INT(RN/256): LB=RN-HB*256
10010 PRINT#15,"P"+CHR$(8)+CHR$(LB)+CHR$(HB)+CHR$(1)
10015 GOSUB 12000
10020 RETURN
10030 INPUT#8,TE$(1),TE$(2),TE$(3),TE$(4),TE$(5),TE$(6),TE$(7),TE$(8)
10060 RETURN
10070 TE$=TE$(1)+CHR$(13)+TE$(2)+CHR$(13)+TE$(3)+CHR$(13)+TE$(4)+CHR$(13)
10072 TE$=TE$+TE$(5)+CHR$(13)+TE$(6)+CHR$(13)+TE$(7)+CHR$(13)+TE$(8)
10080 PRINT#8,TE$
10110 RETURN
12000 INPUT#15,X,X$,Y$,Z$
12010 IF X=0 OR X=50 THEN RETURN
12020 PRINT "ERROR:";X,X$;Y$;Z$
12030 CLOSE 8: CLOSE 15
12040 FOR I=1 TO 6000: NEXT
12060 GOTO 100

Have fun with this program

<!-- TOC PAGE_314: Direct access disk method guide -->

===========================================================
                      PAGE 314 OF 386                       
===========================================================

304

#8.5 ANOTHER METHOD: DIRECT ACCESS

Unfortunately, this type of access to data and diskettes is often completely neglected. Although it is very complicated and time-consuming, it also has some very interesting aspects. What can be achieved with direct access?

1.) Accessing files - Random files

This method has a lot in common with sequential file management, without having its drawbacks, and a lot in common with relative file management.

2.) Access to individual tracks on the diskette

This access gives you options that you haven't even thought of before, and the purpose of which you may not yet understand. More on that later.

## 1. Random files

In contrast to sequential and relative files, the individual block here is always 256 bytes long - a total of 664 such blocks go on a diskette. Nevertheless, you can also save smaller data sets. For example, it is conceivable that you store a total of 4 data sets each 64 bytes long in a block. You then just have to make sure that you access exactly the sentence within such a block that you actually want to process. You must first open a sequential file to note the tracks where you saved the records. So in total you need 3 files:

1.) Sequential file for the pointers
2.) Command file
3.) Data file for direct storage

<!-- TOC PAGE_315: BASIC disk file allocation code -->

===========================================================
                      PAGE 315 OF 386                       
===========================================================

10 OPEN 4,8,4,"CBM 64 FILE,S,W": REM SEQUENT. FILE
20 OPEN 15,8,15: REM COMMAND CHANNEL
30 OPEN 5,8,5,"#": REM DATA FILE
40 TE$="DATA BECKER GMBH"
50 PRINT#5,TE$;",";1: REM TEXT, RECORD#
60 T=1: S=1: REM TRACK=1, SECTOR=1
70 PRINT#15,"B-A:";O,T,S: REM DRIVE, TRACK, SECTOR
80 INPUT#15,ER,NA$,TR,BL: REM READ ERROR
90 IF ER=65 THEN T=TR: S=BL: GOTO 70
100 PRINT#15,"B-W:";5,O,T,S: REM WRITE RECORD
110 PRINT#4,T;",";p
120 CLOSE 5
130 CLOSE 15
140 CLOSE 4
150 END

Now what does this program do? First, the 3 necessary files are opened, then a text is defined that should be saved directly. This text is initially cached in the data file. Now the operating system starts looking for a free block on the floppy disk. The search starts at track 1, sector 1, i.e. the start of the diskette. Line 70 is required for this. "B-A:" means BLOCK-ALLOCATE or translates as BLOCK-SEARCH. A block is searched for on the diskette that has not yet been written to or has been released again. To see whether the block you are looking for is free, the command channel must be read. If the error code is 65, it means that this block is not free and the computer continues its search. However, if it has found a free block, it writes the text that was provided in the data file to the diskette with the block addresses found. The addresses are then saved in the sequential file so that the record can be found again later. At the same time, the operating system automatically locks this track so that it is not accidentally overwritten. The files are closed and the program ends.

305

<!-- TOC PAGE_316: CBM 64 disk access code -->===========================================================
                      PAGE 316 OF 386                       
===========================================================

Reading the data again is just as interesting:

10 OPEN 4,8,4,"CBM 64 FILE"
20 OPEN 15,8,15
30 OPEN 5,8,5,"#"
40 INPUT#4,T,S: REM READING OF ADDRESSES
50 PRINT#15,"B-R:";5,O,T,S
60 INPUT#5,TE$,RE
70 PRINT#15,"B-F:";O,T,S
80 CLOSE 5
90 CLOSE 4
100 PRINT#15,"S:CBM 64 FILE"
110 CLOSE 15

And also a brief explanation of this program: After the files have been opened, the address of the block in which the actual data, in our case the text, is stored is read. After this has happened, this block is released again using the BLOCK-FREE command. Of course, this can only happen if the block can be deleted. The sequential and data files are then closed again, the sequential file is deleted again and the command channel is also closed again.

## 2. Direct disk access

This access, as its name suggests, allows direct access to any TRACKS and SECTORS, i.e. reading information directly from disk without opening files first. For example, you can easily read the table of contents without having to use the LOAD "$",8 command and potentially destroy a program that is in memory. Or you can change a program on a diskette without having to load it - even destroyed programs can sometimes be repaired.

306

<!-- TOC PAGE_317: Commodore 1541 floppy disk commands -->

===========================================================
                      PAGE 317 OF 386                       
===========================================================

However, these accesses are so dangerous that we would like to warn every programmer not to use them without precise knowledge of the structure of the diskette, the directory, BAM or the program itself. Entire files and diskette contents can quickly be lost. Please also read the manual for the Commodore Floppy 1541 carefully. You will understand that we cannot go into detail about the entire structure of the directory, BAM, etc. at this point. That would go beyond the scope of this book. However, if you would like to experiment with these options, we recommend working with a test disk - then at least no "vital" data can be lost.

To clarify the commands used, here is a list of the commands that can directly access a block:

|  Description | Application |
| --- | --- |
|  BLOCK READING | "B-R:";Channel;Drive;Track;Block |
|  BLOCK WRITING | "B-W:";Channel;Drive;Track;Block |
|  BLOCK OCCUPY | "B-A:";Drive;Track;Block |
|  BLOCK RELEASE | "B-F:";Drive;Track;Block |
|  BUFFER POINTER | "B-P:";Channel;Position |

These are the most important commands for direct access. What they all have in common is that you access the floppy controller **directly**. So you have options that you would never have with a normal type of access.

307

<!-- TOC PAGE_318: Disk error recovery guide -->===========================================================
                      PAGE 318 OF 386                       
===========================================================

308

# 8.6 SAVING A FILE THAT IS NOT PROPERLY CLOSED

Admittedly, it doesn't happen often. But when it does happen, the hassle and workload associated with it is even greater.

What is “it”?

By "it" we mean the following process:

You have put a lot of effort into organizing your record collection and would like to immortalize them on a diskette so that you can quickly find certain titles.

The most common method for doing this is simply to save the disk name and the titles on it in one or more sequential files.

So you're in the middle of entering the desired data on the keyboard and you're almost done (you've already recorded 500 tracks) when the fuse blows or your wife (or husband) trips over the power plug.

It doesn't matter, you think, I'm sure I have the data you've entered so far on the diskette.

You go back into your program, change the OPEN command for your sequential file to APPEND (A instead of W) and want to continue.

The shock wears off, the error light on the disk station lights up.

A subsequent query of the error channel brings the solution to the puzzle: WRITE FILE OPEN.

If you now look at the table of contents of the diskette, you will find a '*' in front of the file type identifier.

This means that the file is still open for writing, i.e. no CLOSE occurred after a write access, and that is exactly what happened during the power failure. The same thing happens when you remove the diskette

<!-- TOC PAGE_319: Disk recovery program instructions -->

===========================================================
                      PAGE 319 OF 386                       
===========================================================

Remove the drive without first issuing a CLOSE.

You no longer have a chance of accessing your data using normal methods. It's a shame about the record collection. Since this has happened to us often enough, we have made a virtue of necessity and developed a small program that makes it possible to at least make files that have been damaged in this way readable again.

If you read Section 8.1 again in parallel to what follows, you will also understand what exactly is done in this program.

Of course, we will explain every step of the program in detail.

First, the variables used are introduced to you:

- E Position of filename within the directory sector
- S sector number for the direct commands
- T Track number for the direct commands
- TY file type (derived from T$)
- X running variable to determine the actual file name
- A$ Interim variable to build S$
- F$ desired file name
- S$ full sector
- T$ file type
- X$ File name read from the directory, expanded to 16 characters, later real file name
- X1$ duplicate of X$

309

<!-- TOC PAGE_320: Floppy disk directory access code -->===========================================================
                      PAGE 320 OF 386                       
===========================================================

Now the program step by step:

70 Open a data channel for direct access
80 Open the command channel
100 Enter the file name to be treated
110 Track and sector number assignment.
On the Floppy VC-1541 and CBM4040, the table of contents begins on track 18, sector 1.
On the floppy CBM8050, which you can also handle if an IEC bus is present, it is on track 39. In this case, this line must be changed accordingly.
120 In this line, the sector specified by T and S is first read from the floppy disk (Drive O) into the floppy's internal buffer.
150 The buffer contents are brought to S$ via A$.
160 A sector can hold eight directory entries. This is first searched for the desired file name before the next sector is read.
170 Here the file name is isolated from the entry, in the full length of 16 bytes, and brought to X$.
200-210 The end criterion for the real length of the file name is CHR$(160) (shifted space). The file name is then searched for and then brought back to X$ in its real length.
220-230 If the searched name is found, it continues with 300, otherwise the remaining entries still contained in this sector are examined.
240-260 At the beginning of each sector is the track and sector address of the following block, if there is one. If there is none, i.e. the directory is over, the track number is =0.

310

<!-- TOC PAGE_321: Floppy disk file recovery guide -->

===========================================================
                      PAGE 321 OF 386                       
===========================================================

300-310 The file type (this is the byte from which the file type for the screen is generated) is isolated and brought to T$, or as a numerical value to T.

320 T=0 indicates an empty entry in the directory.

360 The bit that is set here is the cause of all the evil. This bit indicates whether a file is open for writing or not. The `*` for the screen is also derived from this bit.

370 Now the entire sector is reassembled with the identifier for a closed file.

390-410 Now the buffer pointer in the floppy is reset again, the sector is brought into the buffer and the buffer contents are written back to the floppy disk.

420-490 These lines should serve as a reminder of how to proceed.

Using the program is quite simple:

You load the program, insert the diskette to be processed into the drive (for double drives it must be drive 0), start it and enter the file name to be processed.

If the file is on the disk, you can count on a successful outcome of the action.

However, there is one limitation:

Unfortunately, this procedure cannot be used for relative files because their structure differs completely from other file types. The organization of relative files can only be reconstructed with a much greater effort, although intimate knowledge of their structure is an absolute prerequisite.

So now that you have saved your file, you should read it sentence by sentence and every sentence that belongs to this file

311

<!-- TOC PAGE_322: File recovery instructions and code -->===========================================================
                      PAGE 322 OF 386                       
===========================================================

Transfer entry to a new file.

This is necessary because the data has been saved, but the logical end can no longer be recognized, i.e. following your data, others may appear that no longer have anything to do with your file.

At this point you should abort the process and be sure to close the new file and delete the broken file.

Only now can you continue recording your record collection with peace of mind.

We hope that this program has provided you with a useful tool that you hopefully won't have to use too often.

```txt
10 print chr$(147);"
20 print chr$(5);
70 open 2,8,2,"#":rem direct access
80 open 15,8,15:rem command channel
90 print:print
100 input "filename ";f$:print:print
110 t=18:s=1:rem 1541 directory ** t=39 at cbm8050
120 print#15,"u1 2 0"t;s:rem read
130 s$="":rem variable for read
140 : :rem sector
150 for i=1 to 255:get#2,a$:s$=s$+left$(a$+chr$(0),1):next
160 for i=0 to 7:rem 8 entries
170 x$=mid$(s$,i*32+6,16):x1$=x$
Isolate 180 rem filenames
190x=1
200 if mid$(x$,x,1)&lt;&gt;chr$(160) then x=x+1:if x&lt;17 then 200
210 x$=left$(x$,x-1)
```

312

<!-- TOC PAGE_323: BASIC file handling code snippet -->

===========================================================
                      PAGE 323 OF 386                       
===========================================================

220 if x$=f$ then e=i:goto 300
230 next i
240 t=asc(s$):s=asc(mid$(s$,2,1))
250 rem read next sector
260 if t&lt;&gt;0 then 120
270 rem end
280 print"file "f$" not on this disk"
290 close 2:close 15:end
300 t$=mid$(s$,e*32+3)
310 ty=asc(t$) and 15
320 if ty=0 then next i:goto 240
330 if ty&lt;&gt;4 then 340
335 print "relative files cannot be processed"
337 goto 290
340 ty$="delseqprgusrrel"
350 print"file "x1$" "mid$(ty$,ty*3+1,3):print
360 t$=chr$(asc(t$) or 128)
370 s$=left$(s$,e*32+1)+t$+mid$(s$,e*32+3)
380 rem * delete and write back
390 print#15,"b-p 2 0"t;s
400 print#2,s$;
410 print#15,"u2 2 0"t;s
420 close 2:close 15
425 print"File data can now be read."
430 print "after copying the valid data"
440 print "the following commands should be given"
450 print"be :":print
460 print"open 15,8,15"
470 print chr$(17)"print#15,"chr$(34)"s:"f$chr$(34)
480 print chr$(17)"print#15,"chr$(34)"v0"chr$(34)
490 print chr$(17)"close 15"
500 end

313

<!-- TOC PAGE_324: Block follower program documentation -->

===========================================================
                      PAGE 324 OF 386                       
===========================================================

314

#8.7 - THE BLOCK CHASER -

Haven't you always wanted to take a look at the structure of your diskette and the organization of the individual files? Do you want to know exactly how long a program is? Maybe you would like to take a look at the saved data to determine why your own file management always fails with a "String too long error"? This and a few other functions are possible with the block tracker.

The program is largely modular. This means that additional functions can be implemented without much effort.

```basic
100 HX$="0123456789ABCDEF":DIMK$(75):FOR
I=IT075:READK$(I):NEXTI
110 REM***
120 REM BLOCK TRACKING
130 REM***
140 PRINT CHR$(147)
150 PRINT"&lt;1&gt; DIRECTORY "
160 PRINT"&lt;2&gt; BLOCK CHAINING "
170 PRINT"&lt;3&gt; BLOCK OUTPUT ASC"
180 PRINT"&lt;4&gt; BLOCK ISSUE TOKENS"
190 PRINT"&lt;5&gt; BANG OF ERROR"
200 PRINT:PRINT"MAKE YOUR CHOICE"
210 GOSUB 990
220 IF A &lt; 1 OR A &gt; 5 THEN GOTO 210
230 ON A GOSUB 250,450,540,710,880
240 GOTO 140
250 REM DIRECTORY ***
260 T=18 : S=1
270 OPEN1,8,15 : OPEN2,8,2,"#"
280 PRINTCHR$(147);"ENTRY TR SE"
290 PRINT#1,"U1:"2;0;T;S
300 GOSUB 1030 : T = TX : S = SX
310 FOR I = 0 TO 7
320 PRINT#1,"B-P:"2;I*32+2
330 GET#2,A$:IFA$=""THENA$=CHR$(0)
340 IFASC(A$) &lt; 128 THEN 410
350 GOSUB1030
360 FOR U = 1TO16
370 GET#2,A$:IFA$=""THENA$=" "
380 IF ASC(A$) =160 THENA$=" "
390 N$ = N$ + A$ : NEXT U

<!-- TOC PAGE_325: BASIC error handling subroutine -->===========================================================
                      PAGE 325 OF 386                       
===========================================================

810 NEXT U
820 PRINT N$:N$="""
830 NEXT I
840 PRINT:PRINT"PLEASE ONE KEY OR FO
LEG BLOCK WITH 'F'"
850 GOSUB 990 : IF A$ &lt;&gt; "F" THEN CLOSE1
:CLOSE2:RETURN
860 T=TX: S=SX :IF T=0 THEN CLOSE1:CLOSE
2:RETURN
870 GOTO 730
880 REM ERROR CHANNEL ***
890 OPEN1,8,15
900 INPUT#1,A,S$,D,F
910 PRINT CHR$(147)
920 PRINT "ERROR NUMBER :";A
930 PRINT:PRINT"TYPE : ";S$
940 PRINT:PRINT"BLOCK :";D
950 PRINT:PRINT" SECTOR :";F
960 CLOSE1
970 PRINT:PRINT"ONE BUTTON PLEASE"
980 GOSUB 990 : RETURN
GET 990 REM CHARACTERS***
1000 GET A$ : IF A$ = "" THEN GOTO 1000
1010 A = VAL(A$)
1020 RETURN
1030 REM FETCH 2 BYTES ***
1040 GET#2,A$:IFA$=""THENA$=CHR$(0)
1050 TX = ASC(A$)
1060 GET#2,A$:IFA$=""THENA$=CHR$(0)
1070 SX = ASC(A$)
1080 RETURN
1090 REM INPUT TRACK SECTOR ***
1100 PRINT CHR$(147)
1110 INPUT "TRACK";T
1120 INPUT" SECTOR ";p
1130 OPEN1,8,15:OPEN2,8,2,"#"
1140 RETURN
1150 REM BLOCK READ***
1160 PRINT#1,"U1:"2;0;T;S
1170 GOSUB1030:PRINT#1,"B-P:"2;0
1180 RETURN
1190 REM HEX TRANSFORMATION
1200A=ASC(A$)
1210 A1=INT(A/16)
1220 A2=A-A1*16
1230 H$=MID$(HX$,A1+1,1)
1240 H$=H$+MID$(HX$,A2+1,1)
1250 RETURNS

315

<!-- TOC PAGE_326: BASIC program listing snippet -->

===========================================================
                      PAGE 326 OF 386                       
===========================================================

400 PRINTN$;TX;SX:N$="""
410 NEXT I
420 IF T&lt;&gt; 0 GOTO 290
430 PRINT:PRINT"ONE BUTTON PLEASE"
440 CLOSE1:CLOSE2:GOSUB990:RETURN
450 REM CHAINING ***
460 GOSUB 1090:C=1
470 PRINT"BLOCK NO.";C;" TR:";T;" SE
:";S
480 PRINT#1,"U1:"2;0;T;S
490 GOSUB 1030:T=TX:S=SX:C=C+1:IFT=0THEN
GOTO510
500 GOTO 470
510 PRINT"LAST BLOCK HAS :";S;"BYTES"
520 CLOSE1:CLOSE2:PRINT:PRINT"PLEASE ONE
BUTTON"
530 GOSUB 990 : RETURN
540 REM OFF ASC ***
550 GOSUB 1090
560 GOSUB 1150
570 FOR I = 0 TO 31
580 FOR U = 0 TO 7
590 GET#2,A$:IFA$=""THENA$=CHR$(0)
600 GOSUB 1190
610 IFASC(A$)&lt;32ORASC(A$)&gt;127ANDASC(A$)&lt;
160THENA$="."
620 N$=N$+A$
$630 PRINTH; " ";
640 NEXT U
650 PRINT N$:N$="""
660 NEXT I
670 PRINT:PRINT"PLEASE ONE BUTTON OR FO
LOEBLOCK WITH 'F'"
680 GOSUB 990 : IF A$ &lt;&gt; "F" THEN CLOSE1
:CLOSE2:RETURN
690 T=TX: S=SX :IF T=0 THEN CLOSE1:CLOSE
2:RETURN
700 GOTO 560
710 REM FROM TOKEN ***
720 GOSUB 1090
730 GOSUB 1150
740 FOR I = 0 TO 31
750 FOR U = 0 TO 7
760 GET#2,A$:IFA$=""THENA$=CHR$(0)
770 GOSUB 1190
780 IF ASC(A$)&lt;32THENA$="."
790 IFASC(A$)&gt;127ANDASC(A$)&lt;203THENA$=K$
(ASC(A$)-127)
800 N$=N$+A$:PRINTH$; " ";

<!-- TOC PAGE_327: BASIC programming reference guide -->

===========================================================
                      PAGE 327 OF 386                       
===========================================================

1260 DATAEND, FOR, NEXT, DATA, INPUT#, INPUT, DIM, READ, LET, GOTO, RUN, IF, RESTORE, GOSUB
1270 DATARETURN, REM, STOP, ON, WAIT, LOAD, SAVE, VERIFY, DEF, POKE, PRINT#, PRINT, CONT
1280 DATALIST, CLR, CMD, SYS, OPEN, CLOSE, GET, NEW, TAB&lt;, TO, FN, SPC&lt;, THEN, NOT, STEP
1290 DATA+, -, /, +, AND, OR, &gt;, =, &lt;, SGN, INT, ABS, USR, FRE, POS, SQR, RND, LOG, EXP, COS, SIN
1300 DATATAN, ATN, PEEK, LEN, STR$, VAL, ASC, CHR$, LEFT$, RIGHT$, MID$,

## Explanation of the listing

100 string for hexadecimal conversion and structure of the basic keywords
110-200 Output of the menu
210-240 Calling the selected subprogram with subsequent return to the menu
250-300 advance reading of the directory
310-330 Positioning on an entry
340 Check for "file scratched"
350-410 Structure and output of an entry
420 Read out subsequent block of the directory
430-440 caster
450-460 advance of block chaining
470 Output of the block number with the associated values
Get 480-500 follow-up block
510-530 caster
540-580 forward ASC output
590 Get a byte
600 Convert to hexadecimal format
610 Check for printable ASC value
620-660 Output of the hex values and structure of the ASC string
670-700 caster
710-750 Advance Token Issue
760 Get a byte
770 Convert to hexadecimal format

<!-- TOC PAGE_328: Program code block descriptions -->===========================================================
                      PAGE 328 OF 386                       
===========================================================

780-790 Check whether token or ASC value
800-830 Output of the hex values and the ASC/Token string
840-870 caster
880-980 Error channel read, output and overrun
990-1020 Subprogram 1 - Wait for a key and determine its numerical value
1030-1080 Get the 1st and 2nd bytes of a block and convert them into the address of the following block
1090-1140 Simple input query for the freely selectable starting point of block tracking
1150-1180 Read a block and reset the buffer pointer
1190-1250 Convert a 1 byte decimal value to hexadecimal form
1260-1300 Name of the basic key values

<!-- TOC PAGE_329: Chapter 9: Machine code routines -->

===========================================================
                      PAGE 329 OF 386                       
===========================================================

CHAPTER 9 POKE'S AND OTHER USEFUL ROUTINES

## 9.1 THE CASSETTE BUFFER AS PROGRAM MEMORY

If you want to use small machine programs together with BASIC, the question always arises in which memory area you should store such programs.

When making the selection, it must be noted that this area must not be overwritten by BASIC programs or variables. From this point of view, there are two basic options for storing machine programs.

Firstly, you can select memory areas that are not used by the BASIC interpreter; secondly, it is possible to relocate the start of the BASIC program or the end of the BASIC memory.

There are three areas again that are not used by BASIC. The first option is the cassette buffer. It is located from address 828 to 1019 ($033C to $03FB). This area is only used by the program when you save or load data with the cassette recorder. Otherwise this area is unused. It is therefore ideal for storing small machine programs up to 192 bytes long. If you use sprites 13, 14 or 15, the cassette buffer is occupied by the sprites. Another small area is available from address 704 to 767 ($02CO to $02FF) (64 bytes). However, this area is occupied by Sprite 11. You have a large area of ​​4 KBytes in the RAM above the BASIC interpreter from address 49152 to 53247 ($COOO to $CFFF), which should be sufficient for even the longest machine programs.

Do you only need a few memory cells, e.g.

<!-- TOC PAGE_330: Commodore 64 memory management guide -->

===========================================================
                      PAGE 330 OF 386                       
===========================================================

To store variable values that should be retained even after a CLR or NEW command, you have 16 bytes available 'behind' the screen memory. The 64 has 1K bytes = 1024 bytes available for screen memory; However, only 25*40 = 1000 bytes are required for the video RAM. So 24 bytes are left. However, the last 8 bytes are used as pointers for the sprites. So there are 16 bytes left that you can use for your purposes. These are the addresses 2024 to 2039 (hexadecimal $07E9 to $07F8).

If the areas described above are occupied or you need more storage space, it makes sense to limit the area for BASIC programs and thus make it usable for machine programs. You can set the BASIC end down (the most common method) or the BASIC start up. Now let's see how to do this.

The BASIC interpreter has two pointers, each pointing to the start and end of BASIC memory. The BASIC start is in 43/44 ($2B/$2C), the end is in 55/56 ($37/$38). With

PRINT PEEK(43)+256*PEEK(44) or
PRINT PEEK(55)+256*PEEK(56)

get the values; Normally it says 2049 or 40960. If we want to create space for a 1000 byte long machine program, we can move the BASIC end down by 1000. So the end should now be at 39960. Now we can set the new value using POKE.

HB = INT (39960/256) : LB = 39960 - HB*256
POKE 55, LB : POKE 56, HB : CLR

320

<!-- TOC PAGE_331: BASIC programming code snippet -->===========================================================
                      PAGE 331 OF 386                       
===========================================================

The CLR command is absolutely necessary, otherwise you can get incorrect variable values. If we want to set the start to 3049, the following commands are required:

HB = INT (3049/256) : LB = 3049 - HB*256

POKE 43, LB : POKE 44, HB : POKE 3049-1.0 : NEW

Here the NEW command is required to set all other BASIC pointers correctly.

321

<!-- TOC PAGE_332: String sorting algorithm guide -->

===========================================================
                      PAGE 332 OF 386                       
===========================================================

322

#9.2 SORTING STRINGS

A task that every programmer often encounters is sorting some data. These can be, for example, names, addresses and series of numbers. There are various well-known algorithms for sorting, but they are all very time-consuming when a large number of data have to be sorted. The simplest methods are generally also the slowest. If you need significantly faster sorting methods, you have to formulate the algorithms not in BASIC, but in machine language. For such tasks, solutions in machine language are a good 100 times faster than a BASIC routine. The following program is suitable for sorting a string array. In order to keep the program as short as possible, the following requirements were assumed:

1. The field to be sorted must first be dimensioned with DIM.
2. An empty string must follow the last array element to be sorted.

Point 2 also has the advantage that even a partially filled array can be sorted without all the empty strings being at the beginning of the array after sorting. With these agreements, the program becomes so short that it has space in the cassette buffer. It is simply called with SYS 828. The program checks whether the first array is a one-dimensional string array. If this is not the case, the machine program is ended immediately.

<!-- TOC PAGE_333: Assembly code listing page -->

===========================================================
                      PAGE 333 OF 386                       
===========================================================

323

|  100: | 033c |  | * = 828 |
| --- | --- | --- | --- |
|  105: | 033c |  | .opt p1 |
|  110: | 033c a0 00 |  | ldy #0 |
|  120: | 033e b1 2f |  | lda ($2f),y ; first letter |
|  130: | 0340 30 0d |  | bmi 11 |
|  135: | 0342 c8 |  | iny |
|  140: | 0343 b1 2f |  | lda ($2f),y ; second character |
|  150: | 0345 10 08 |  | bpl 11 |
|  160: | 0347 a0 04 |  | ldy #4 |
|  170: | 0349 b1 2f |  | lda ($2f),y ; Dimensions |
|  180: | 034b c9 01 |  | cmp #1 |
|  190: | 034d f0 01 |  | beq 12 |
|  200: | 034f 60 | 11 | rts |
|  210: | 0350 18 | 12 | clc |
|  220: | 0351 a5 2f |  | lda $2f ; Array start |
|  230: | 0353 69 07 |  | adc #7 ; plus 7 |
|  240: | 0355 85 6e |  | sta $6e |
|  250: | 0357 a5 30 |  | lda $30 |
|  260: | 0359 69 00 |  | adc #0 |
|  270: | 035b 85 6f |  | sta $6f |
|  280: | 035d a0 00 | 13 | ldy #0 |
|  290: | 035f b1 6e |  | lda ($6e),y |
|  300: | 0361 f0 ec |  | beq 11 ; Length zero, done |
|  310: | 0363 85 22 |  | sta $22 |
|  320: | 0365 c8 | 14 | iny |
|  330: | 0366 b1 6e |  | lda ($6e),y |
|  340: | 0368 99 22 00 |  | sta $22,y ; Pointer to String |
|  350: | 036b c0 02 |  | cpy #2 |
|  360: | 036d d0 f6 |  | bne 14 |
|  370: | 036f a5 6e |  | lda $6e |
|  380: | 0371 85 71 |  | sta $71 |
|  390: | 0373 a5 6f |  | lda $6f |
|  400: | 0375 85 72 |  | sta $72 |
|  410: | 0377 18 | 15 | clc |

<!-- TOC PAGE_334: 6502 assembly code listing -->===========================================================
                      PAGE 334 OF 386                       
===========================================================

324

420: 0378 a5 71 lda $71
430: 037a 69 03 adc #3 ; add three
440: 037c 85 71 sta $71
450: 037e 90 02 bcc 16
460: 0380 e6 72 inc $72
470: 0382 a0 00 16ldy #0
480: 0384 b1 71 lda ($71),y
490: 0386 f0 3d beq 113
500: 0388 85 4d sta $4d ; Length
510: 038a c5 22 cmp $22 ; compare with first length
520: 038c 90 02 bcc 17
530: 038e a5 22 lda $22
540: 0390 85 55 17 sta $55 ; Comparison length
550: 0392 c8 18 iny
560: 0393 b1 71 lda ($71),y
570: 0395 99 4d 00 sta $4d,y
580: 0398 c0 02 cpy #2
590: 039a d0 f6 bne 18
600: 039c a0 00ldy #0
610: 039e b1 23 19 lda ($23),y ; String comparison
620: 03a0 d1 4e cmp ($4e),y
630: 03a2 f0 04 beq 110 ; straight away, then continue
640: 03a4 b0 0b bcs 111 ; bigger then exchange
650: 03a6 90 cf bcc 15 ; smaller then next string
660: 03a8 c8 110 iny
670: 03a9 c4 55 cpy $55 ; all characters the same?
680: 03ab d0 f1 bne 19
690: 03ad c4 22 cpy $22 ; first string longer
700: 03af b0 c6 bcs 15 ; no then ok
710: 03b1 a0 02 111 ldy #2
720: 03b3 b1 6e 112 lda ($6e),y ; Swap string pointers
730: 03b5 aa tax
740: 03b6 b1 71 lda ($71),y
750: 03b8 91 6e sta ($6e),y

<!-- TOC PAGE_335: 6502 assembly and BASIC loader -->

===========================================================
                      PAGE 335 OF 386                       
===========================================================

760: 03ba 99 22 00 sta $22.y
770: 03bd 8a txa
780: 03be 91 71 sta ($71),y
790: 03c0 88 dey
800: 03c1 10 f0 bpl 112
810: 03c3 30 b2 bmi 15
820: 03c5 18 113 clc ; Pointer to next string
830: 03c6 a5 6e lda $6e
840: 03c8 69 03 adc #3
850: 03ca 85 6e sta $6e
860: 03cc 90 8f bcc 13
870: 03ce e6 6f inc $6f
880: 03d0 d0 8b bne 13

Here again the loading program in BASIC.

100 for i = 828 to 977
110 read x : poke i,x : s=s+x : next
120 data 160, 0.177, 47, 48, 13,200,177, 47, 16, 8,160
130 data 4,177, 47,201, 1,240, 1, 96, 24,165, 47,105
140 data 7,133,110,165, 48,105, 0.133,111,160, 0.177
150 data 110,240,236,133, 34,200,177,110,153, 34, 0.192
160 data 2,208,246,165,110,133,113,165,111,133,114, 24
170 data 165,113,105, 3,133,113,144, 2,230,114,160, 0
180 data 177,113,240, 61,133, 77,197, 34,144, 2,165, 34
190 data 133, 85,200,177,113,153, 77, 0.192, 2,208,246
200 data 160, 0.177, 35,209, 78,240, 4,176, 11,144,207
210 data 200,196, 85,208,241,196, 34,176,198,160, 2,177
220 data 110,170,177,113,145,110,153, 34, 0,138,145,113
230 data 136, 16,240, 48,178, 24,165,110,105, 3,133,110
240 data 144,143,230,111,208,139
250 if s &lt;&gt; 17663 then print "error in datas!!" :end
260 print "ok!"

325

<!-- TOC PAGE_336: BASIC program speed test -->

===========================================================
                      PAGE 336 OF 386                       
===========================================================

You can demonstrate the speed of the machine program with a small test program.

The program creates a predetermined number of strings of random letters with a maximum length to be entered, displays them on the screen, then sorts them and outputs them again along with the time for sorting.

```txt
100 input "number, length";a,l
110 dim a$(a):a=a-1
120 for i=0 to a
130 for j=1 to rnd(1)*l
140 a$(i) = a$(i)+chr$(rnd(1)*26+65)
150 next:next
160 for i=0 to a : print a$(i) : next
170 t=ti : sys 828 : t=ti-t
180 print "sorting time" t/60 "seconds"
190 for i=0 to a : print a$(i) : next
```

Run the program once with different lengths and numbers of strings and note the sorting time. 100 strings are sorted in under a second. A corresponding BASIC program would take minutes to do this.

If you want to use the program for your purposes, please note that the last element (up to which you want to sort) must be an empty string and that the array must be dimensioned first.

326

<!-- TOC PAGE_337: BASIC code for min/max -->===========================================================
                      PAGE 337 OF 386                       
===========================================================

327

# 9.3 MINIMUM AND MAXIMUM OF FIELD VARIABLES

When calculating with dimensioned variables, you often need the smallest or largest value of the field. Although the calculation can be solved with a small BASIC loop, it takes a relatively long time for larger fields. This is a typical case for machine programming. The program uses the same algorithm as the corresponding BASIC variant.

```txt
100 DIM A(N)
...
200 GOSUB 1000
...
1000 MIN = A(O)
1010 FOR I=1 TO N
1020 IF A(I) &lt; MIN THEN MIN = A(I)
1030 NEXT
1040 RETURN
```

A field A is dimensioned from 0 to N. By calling the subprogram from line 1000, the minimum is calculated and returned in the variable MIN. If you are looking for the maximum, just replace line 1020 with

1020 IF A(I) &gt; MAX THEN MAX = A(I)

MAX = A(0) is written accordingly in line 1000.

The machine program has the advantage over the above BASIC program in that it is not limited to variable A

<!-- TOC PAGE_338: Assembly min/max function code -->

===========================================================
                      PAGE 338 OF 386                       
===========================================================

but that the variable name is passed as a parameter to the USR function. The program can process both real numbers (A) and integer arrays (A%) and is located in the free RAM area starting at address $C800.

; Min/Max function

|  120: | c800 | intflg = 14 ; Flag for integer variable |
| --- | --- | --- |
|  130: | c800 | store = $26 |
|  140: | c800 | arrtab = $2f ; Pointer to array table |
|  150: | c800 | arrend = $31 ; Pointer to end of array |
|  160: | c800 | varnam = $45 ; Variable name |
|  170: | c800 | temp = $5f |
|  180: | c800 | setarr = $b196 ; Pointer to first array element |
|  190: | c800 | memfac = $bba2 ; Get constant in FAC |
|  200: | c800 | compare = $bc5b ; Compare constant with FAC |
|  210: | c800 | errout = $a445 |
|  220: | c800 | int = $14 ; Storage for integer variable |
|  230: | c800 | intfloat = $b391 ; Integer to FAC |
|  240: | c800 | * = $c800 |
|  300: | c800 a6 2f | minmax ldx arrtab |
|  310: | c802 a5 30 | lda arrtab+1 ; Pointer to start of array table |
|  320: | c804 86 5f | 13 stx temp |
|  330: | c806 85 60 | sta temp+1 ; running pointer |
|  340: | c808 c5 32 | cmp arrend+1 |
|  350: | c80a d0 04 | bne 11 |
|  360: | c80c e4 31 | cpx arrend ; End of array table?  |
|  370: | c80e f0 1d | beq notfound |
|  380: | c810 a0 00 | 11ldy #0 |
|  390: | c812 b1 5f | lda (temp),y ; first letter of name |
|  400: | c814 c8 | iny |
|  410: | c815 c5 45 | cmp varnam ; compare with searched name |
|  420: | c817 d0 06 | bne 12 |
|  430: | c819 a5 46 | lda varnam+1 |

<!-- TOC PAGE_339: Assembly code snippet -->===========================================================
                      PAGE 339 OF 386                       
===========================================================

329

440: c81b d1 5f cmp (temp),y ; compare second character
450: c81d f0 17 beq found ; found ?
460: c81f c8 12 iny
470: c820 b1 5f lda (temp),y
480: c822 18 clc
490: c823 65 5f adc temp ; Add offset for next array
500: c825 aa tax
510: c826 c8 iny
520: c827 b1 5f lda (temp),y
530: c829 65 60 adc temp+1
540: c82b 90 d7 bcc 13
550: c82d a9 b8 notfound lda #<errmsg ;="" 560:="" 570:="" 580:="" 590:="" 600:="" :="" <table="" a4="" ac="" adc="" number="" anzyelement="" be="" b1="" c82="" c83="" c836="" c837="" c83e="" c83f="" c83e:="" c83e:c8="" c83e:c8="" c840:="" c841="" c843="" c845="" c846="" c847="" c848="" c849="" c850:="" c851="" c852="" c853="" c854="" c855="" c856="" c857="" c858="" c860:="" c861="" c862="" c863="" c864="" c865="" c866="" c867="" c868="" c869="" c870:="" c871="" c872="" c873="" c874="" c875="" c876="" c880:="" c881="" c882="" c883="" c884="" c885="" c886="" c887="" c888="" c889="" c890:="" c891="" c892="" c893="" c894="" c895="" c896="" c897="" c898="" c899="" c90:="" a0:="" a1="" a2="" a3="" a4="" a5="" a5f="" a6="" adc="" adl="" adl,="" anzyelement="" and="" another="" any="" are="" array="" arrayelement="" as="" at="" be="" bep="" beq="" ber="" bin="" b1="" b2="" b22="" b26="" b27="" b28="" b3="" b3e="" b4="" b460="" b470="" b480:="" by="" c850:="" c851="" c852="" c853="" c854="" c855="" c856="" c857="" c858="" c860:="" c861="" c862="" c863="" c864="" c865="" c866="" c867="" c868="" c869="" c870:="" c871="" c872="" c873="" c874="" c875="" c880:="" a0e="" a1="" a2="" a3="" a4="" a5="" a5f="" a6="" adl="" adl,="" anzyelement="" and="" another="" are="" array="" as="" at="" be="" bep="" bin="" bit="" bm="" bpl="" by="" c850="" c851="" c852="" c853="" c854="" c855="" c856="" c860="" c861="" c862="" c863="" c864="" </errmsg>

<!-- TOC PAGE_340: Assembly code array processing -->

===========================================================
                      PAGE 340 OF 386                       
===========================================================

330

790: c85a a5 5f lda temp
800: c85c a4 60 ldy temp+1
810: c85e 20 a2 bb lp1 jsr memfac ; Remember array element as min/max
820: c861 18 loop clc
830: c862 a5 5f lda temp
840: c864 69 05 adc #5 ; Pointer to next element
850: c866 85 5f sta temp
860: c868 90 02 bcc l4
870: c86a e6 60 inc temp+1
880: c86c a4 60 l4 ldy temp+1
890: c86e c5 26 cmp store ; End of array
900: c870 d0 e3 bne l5
910: c872 c4 27 cpy store+1
920: c874 d0 df bne l5
930: c876 60 rts
950: c877 a0 00 integer ldy #0 ; int array
960: c879 b1 5f lda (temp),y
970: c87b aa tax
980: c87c c8 iny
980: c87d b1 5f lda (temp),y
990: c87f 85 15 sta int+1 ; get first value after int
1000: c881 86 14 stx int
1010: c883 18 l12 clc
1020: c884 a5 5f lda temp
1030: c886 69 02 adc #2 ; Pointer to next element
1040: c888 85 5f sta temp
1050: c88a 90 02 bcc l10
1060: c88c e6 60 inc temp+1
1070: c88e c5 26 l10 cmp store
1080: c890 d0 0d bne l11
1090: c892 a5 60 lda temp+1
1100: c894 c5 27 cmp store+1 ; Already reached the end?
1110: c896 d0 07 bne l11
1120: c898 a5 14 lda int ; Get integer value

<!-- TOC PAGE_341: BASIC assembly code listing -->===========================================================
                      PAGE 341 OF 386                       
===========================================================

1130: c89a a4 15 ldy int+1
1140: c89c 4c 91 b3 jmp intfloat ; convert to FAC
1150: c89f a0 00 111 ldy #0
1160: c8a1 b1 5f lda (temp),y
1180: c8a3 c5 14 cmp int ; Compare high bytes
1180: c8a5 d0 07 bne 114
1190: c8a7 c8 iny
1190: c8a8 b1 5f lda (temp),y
1200: c8aa e5 15 sbc int+1 ; Compare Lo Bytes
1210: c8ac f0 d5 beq 112
1220: c8ae a9 01 114 lda #1 ; Flag for bigger
1230: c8b0 90 02 bcc 113
1230: c8b2 a9 ff lda #$ff ; Flag for smaller
1240: c8b4 30 c1 113 bmi integer
1245: c8b6 10 cb bpl 112
1250: c8b8 41 52 52 errmsg .asc "array not found"
1260: c8bb 41 59 20 4f 54 20 46 50 55 4f c4

Here is the BASIC loading program again:

100 FOR I = 51200 TO 51398
110 READ X : POKE I,X : S=S+X : NEXT
120 DATA 166, 47,165, 48,134, 95,133, 96,197, 50,208, 4
130 DATA 228, 49,240, 29,160, 0.177, 95,200,197, 69,208
140 DATA 6,165, 70,209, 95,240, 23,200,177, 95, 24,101
150 DATA 95,170,200,177, 95,101, 96,144,215,169,184,133
160 DATA 34,169,200, 76, 69,164,200, 24,177, 95,101, 95
170 DATA 133, 38,200,177, 95,101, 96,133, 39,200,177, 95
180 DATA 32,150,177,133, 95,132, 96, 36, 14, 48, 36, 16
190 DATA 9, 32, 91,188, 16, 7,165, 95,164, 96, 32,162
200 DATA 187, 24,165, 95,105, 5,133, 95,144, 2,230, 96
210 DATA 164, 96,197, 38,208,227,196, 39,208,223, 96,160
220 DATA 0.177, 95,170,200,177, 95,133, 21,134, 20, 24
230 DATA 165, 95,105, 2,133, 95,144, 2,230, 96,197, 38

331

<!-- TOC PAGE_342: BASIC array max/min function -->

===========================================================
                      PAGE 342 OF 386                       
===========================================================

240 DATA 208, 13,165, 96,197, 39,208, 7,165, 20,164, 21
250 DATA 76,145,179,160, 0.177, 95,197, 20,208, 7,200
260 DATA 177, 95,229, 21,240,213,169, 1,144, 2,169,255
270 DATA 48,193, 16,203, 65, 82, 82, 65, 89, 32, 78, 79
280 DATA 84, 32, 70, 79, 85, 78,196
290 IF S &lt;&gt; 22908 THEN PRINT "ERROR IN DATAS!!" :END
300 PRINT "OK!"

The printed version calculates the maximum of an array. If you want to calculate the minimum, you have to reverse the branching logic after the comparisons. To do this, you need to turn BMI commands into a BPL and vice versa. You must change the following addresses:

C858 from $10 becomes $30
C8B4 $30 becomes $10
C8B6 $10 becomes $30

If you want to use the function, you must first set the address for the USR function:

POKE 785.0 : POKE 786,200

After that, you can call the function with PRINT USR(A), where A is the name of the array. Integer arrays are also allowed. The USR function can be called like any other function, e.g. X = USR(A%)*SIN(3).

The following small program can be used to test the function.

100 POKE 785.0 : POKE 786,200
110 INPUT "ARRAY SIZE";N
120 DIM A(N)
130 FOR I=0 TO N

<!-- TOC PAGE_343: BASIC programming code snippet -->

===========================================================
                      PAGE 343 OF 386                       
===========================================================

140 A(I) = RND (1)*1000
150 PRINT A(I)
160 NEXT
170 PRINTS
180 PRINT USR(A)

Switching from MAX to MIN function can be done by changing the three values above using POKE:

POKE 51288.48 or 16
POKE 51380.16 or 48
POKE 51382.48 or 16

Also try these POKEs for the MIN function and use integer arrays too. Also note the time difference (only noticeable with very large arrays, e.g. DIM A%(5000)).

333

<!-- TOC PAGE_344: BASIC variable dump program -->===========================================================
                      PAGE 344 OF 386                       
===========================================================

334

# 9.4 DUMP COMMAND FOR VARIABLE OUTPUT

The following machine program is very useful for testing BASIC programs. It outputs all BASIC variables with their associated values. The program is in the cassette buffer and is called with SYS 828.

|  100: | 033c |  | * = 828 ; Cassette buffer |
| --- | --- | --- | --- |
|  110: | 033c a5 2d |  | lda $2d |
|  120: | 033e a4 2e |  | ldy $2e ; Pointer to variable start |
|  130: | 0340 85 14 | 10 | sta$14 ; remember |
|  140: | 0342 84 15 |  | sty $15 |
|  150: | 0344 c4 30 |  | cpy $30 ; compare with end of variable |
|  160: | 0346 d0 02 |  | bne 11 |
|  170: | 0348 c5 2f |  | cmp $2f |
|  180: | 034a b0 18 | 11 | bcs 13 ; over, then done |
|  190: | 034c 69 02 |  | adc #2 ; Pointer to variable value |
|  200: | 034e 90 01 |  | bcc 12 |
|  210: | 0350 c8 |  | iny |
|  220: | 0351 85 22 | 12 | sta $22 |
|  230: | 0353 84 23 |  | sty $23 |
|  240: | 0355 20 82 03 |  | jsr 17 ; Name issued |
|  250: | 0358 20 b6 03 |  | jsr 112 ; "=" output |
|  260: | 035b 8a |  | txa |
|  270: | 035c 10 07 |  | bpl 14 |
|  280: | 035e 20 bf 03 |  | jsr 113 ; Intger variable output |
|  290: | 0361 4c 71 03 |  | jmp 16 ; to the main loop |
|  300: | 0364 60 | 13 | rts |
|  310: | 0365 98 | 14 | tya |
|  320: | 0366 30 06 |  | bmi 15 |
|  330: | 0368 20 cf 03 |  | jsr 114 ; Floating point number output |
|  340: | 036b 4c 71 03 |  | jmp 16 |

<!-- TOC PAGE_345: 6502 assembly code listing -->

===========================================================
                      PAGE 345 OF 386                       
===========================================================

335

350: 036e 20 d8 03 15 jsr 116 ; Output string variable
360: 0371 a9 0d 16 lda #13 ; carriage return
370: 0373 20 d2 ff jsr $ffd2 ; output
380: 0376 a5 14 lda $14
390: 0378 a4 15ldy $15
400: 037a 18 clc
410: 037b 69 07 adc #7 ; Add 7 for next variable
420: 037d 90 c1 bcc 10
430: 037f c8 iny
440: 0380 b0 be bcs 10 ; to the main loop
450: 0382 a0 00 17ldy #0
460: 0384 b1 14 lda ($14),y ; first letter of the name
470: 0386 aa tax
480: 0387 29 7f and #$7f
490: 0389 20 d2 ff jsr $ffd2 ; output
500: 038c c8 iny
510: 038d b1 14 lda ($14),y ; second character
520: 038f a8 day
530: 0390 29 7f and #$7f
540: 0392 f0 03 beq 18
550: 0394 20 d2 ff jsr $ffd2 ; output
560: 0397 8a 18 txa
570: 0398 10 11 bpl 110 ; Test type
580: 039a 98 tya
590: 039b 30 0a bmi 19
600: 039d a9 21 lda #"!" ; Function, "!" output
610: 039f 20 d2 ff jsr $ffd2
620: 03a2 68 pla
630: 03a3 68 pla
640: 03a4 4c 71 03 jmp 16 ; Return to main loop
650: 03a7 a9 25 19 lda #"%" ; Integer variable
660: 03a9 d0 4e bne 119
670: 03ab 98 110 tya
680: 03ac 10 04 bpl 111

<!-- TOC PAGE_346: 6502 assembly code listing -->

===========================================================
                      PAGE 346 OF 386                       
===========================================================

336

690: 03ae a9 24 lda #" $" ; String variable
700: 03b0 d0 47 bne 119
710: 03b2 60 111 rts
720: 03b3 20 d2 ff jsr $ffd2 ; Output characters
730: 03b6 a9 20 112 lda #" "
740: 03b8 20 d2 ff jsr $ffd2 ; Output blank space
750: 03bb a9 3d lda #" ="
760: 03bd d0 3a bne 119 ; output
770: 03bf a0 00 113 ldy #0 ; Integer variable
780: 03c1 b1 22 lda ($22),y ; Lo Byte
790: 03c3 aa tax
800: 03c4 c8 iny
810: 03c5 b1 22 lda ($22),y ; Hi Byte
820: 03c7 a8 day
830: 03c8 8a txa
840: 03c9 20 95 b3 jsr $b395 ; convert to floating point
850: 03cc 4c d2 03 jmp 115 ; and spend
860: 03cf 20 a6 bb 114 jsr $bba6 ; Get floating point variable
870: 03d2 20 dd bd 115 jsr $bddd ; convert to ASCII string
880: 03d5 4c 1e ab jmp $ab1e ; and spend
890: 03d8 20 f7 03 116 jsr 118 ; String, output apostrophe
900: 03db a0 02 ldy #2
910: 03dd b1 22 lda ($22),y ; Address high
920: 03df 85 25 sta $25
930: 03e1 88 dey
940: 03e2 b1 22 lda ($22),y ; Address low
950: 03e4 85 24 sta $24
960: 03e6 88 dey
970: 03e7 b1 22 lda ($22),y ; Length
980: 03e9 85 26 sta $26
990: 03eb f0 0a beq 118
1000: 03ed b1 24 117 lda ($24),y ; Character of the string
1010: 03ef 20 d2 ff jsr $ffd2 ; output
1020: 03f2 c8 iny

<!-- TOC PAGE_347: BASIC machine code program -->===========================================================
                      PAGE 347 OF 386                       
===========================================================

1030: 03f3 c4 26 cpy $26 ; String over?
1040: 03f5 d0 f6 bne 117
1050: 03f7 a9 22 118 lda #$22 ; Quotation
1060: 03f9 4c d2 ff 119 jmp $ffd2 ; issued

Here again the BASIC program for entering the machine program.

100 for i = 828 to 1019
110 read x : poke i,x : s=s+x : next
120 data 165, 45, 164, 46, 133, 20, 132, 21, 196, 48, 208, 2
130 data 197, 47, 176, 24, 105, 2, 144, 1, 200, 133, 34, 132
140 data 35, 32, 130, 3, 32, 182, 3, 138, 16, 7, 32, 191
150 data 3, 76, 113, 3, 96, 152, 48, 6, 32, 207, 3, 76
160 data 113, 3, 32, 216, 3, 169, 13, 32, 210, 255, 165, 20
170 data 164, 21, 24, 105, 7, 144, 193, 200, 176, 190, 160, 0
180 data 177, 20, 170, 41, 127, 32, 210, 255, 200, 177, 20, 168
190 data 41, 127, 240, 3, 32, 210, 255, 138, 16, 17, 152, 48
200 data 10, 169, 33, 32, 210, 255, 104, 104, 76, 113, 3, 169
210 data 37, 208, 78, 152, 16, 4, 169, 36, 208, 71, 96, 32
220 data 210, 255, 169, 32, 32, 210, 255, 169, 61, 208, 58, 160
230 data 0, 177, 34, 170, 200, 177, 34, 168, 138, 32, 149, 179
240 data 76, 210, 3, 32, 166, 187, 32, 221, 189, 76, 30, 171
250 data 32, 247, 3, 160, 2, 177, 34, 133, 37, 136, 177, 34
260 data 133, 36, 136, 177, 34, 133, 38, 240, 10, 177, 36, 32
270 data 210, 255, 200, 196, 38, 208, 246, 169, 34, 76, 210, 255
280 if s &lt;&gt; 20988 then print "error in datas!!" :end
290 print "ok!"

If you run the following small program you will get the following expression:

337

<!-- TOC PAGE_348: BASIC programming code example -->

===========================================================
                      PAGE 348 OF 386                       
===========================================================

100 a=5
110 def fnx (y) = sin(y) * cos(y)
120 c$ = "program"
130b% = -101
140 sys 828

a = 5
x!
y = 0
c$="program"
b% = -101

You can call the DUMP function both from the program and in direct mode with SYS 828. If you have interrupted a program, you can view the current variable contents with DUMP and then continue the program with CONT. As you saw in the example above, defined user functions are indicated by a "!" marked.

338

<!-- TOC PAGE_349: Commodore 64 PEEK function modification -->

===========================================================
                      PAGE 349 OF 386                       
===========================================================

339

#9.5 MODIFIED PEEK FUNCTION

The following small machine program elegantly allows you to take advantage of the Commodore 64's additional RAM memory. At the same time, it is also possible to read out the character generator from BASIC. A few more explanations:

The memory areas $A000 to $BFFF (40960 to 49151) and $E000 to $FFFF (57344 to 65535) are each occupied twice: once by 8K BASIC or operating system ROM and twice by 8K RAM. However, these 16 KBytes cannot be easily used by BASIC. Every POKE instruction in this memory area writes directly to RAM, but a read attempt with PEEK always reads the switched-on ROM. Here we now replace the PEEK function with a self-written USR function. The function must carry out the following tasks: Before the value of a memory cell is read, the memory configuration that addresses the RAM must first be created. Now the value can be read. The old configuration must then be restored. In addition, the character generator located there should be able to be read out in the area from $D000 to $DFFF. It is therefore checked whether the PEEK address is between $D000 and $DFFF. If so, the memory configuration is set so that the character generator can be read out. Now the value is read and switched back to the old memory configuration.

; USR - PEEK

110: 033C ADR = $14 ; Integer address
120: 033C FACADR = $B7F7
130: 033C YFAC = $B3A2

<!-- TOC PAGE_350: Assembly code listing snippet -->===========================================================
                      PAGE 350 OF 386                       
===========================================================

340

|  190: | 033C |  | * = 828 ; Cassette buffer |
| --- | --- | --- | --- |
|  200: | 033C A5 14 |  | LDA ADR |
|  210: | 033E 48 |  | PHA ; Save integer address |
|  220: | 033F A5 15 |  | LDA ADR+1 |
|  230: | 0341 48 |  | PHA |
|  240: | 0342 20 F7 B7 |  | JSR FACADR ; Convert FAC to address format |
|  250: | 0345 A5 01 |  | LDA 1 |
|  260: | 0347 48 |  | PHA ; Remember configuration |
|  261: | 0348 A5 15 |  | LDA ADR+1 |
|  262: | 034A C9 DO |  | CMP #$DO ; less than $D000?  |
|  262: | 034C 90 07 |  | BCC RAM |
|  263: | 034E C9 EO |  | CMP #$EO ; roughly $E000?  |
|  263: | 0350 B0 03 |  | BCS RAM |
|  270: | 0352 A9 31 |  | LDA #$31 ; Read character generator |
|  270: | 0354 2C |  | .BYT $2C |
|  275: | 0355 A9 34 | RAM | LDA #$34 ; Read RAM |
|  280: | 0357 78 |  | BE |
|  280: | 0358 85 01 |  | STA 1 ; Set memory configuration |
|  290: | 035A A0 00 |  | LDY #0 |
|  300: | 035C B1 14 |  | LDA (ADR),Y ; Read Byte |
|  310: | 035E A8 |  | TAY ; and to Y |
|  320: | 035F 68 |  | PLA |
|  330: | 0360 85 01 |  | STA 1 ; Retrieve configuration |
|  330: | 0362 58 |  | CLI |
|  340: | 0363 68 |  | PLA |
|  350: | 0364 85 15 |  | STA ADR+1 |
|  360: | 0366 68 |  | PLA ; Retrieve address |
|  370: | 0367 85 14 |  | STA ADR |
|  380: | 0369 4C A2 B3 |  | JMP YFAC ; Convert Y to FAC |

The small program has space in the cassette buffer starting at address 828. Once you have entered the program, you must first set the USR vector to 828. This happens with two

<!-- TOC PAGE_351: BASIC POKE commands tutorial -->

===========================================================
                      PAGE 351 OF 386                       
===========================================================

POKE commands.

POKE 785, 828 AND 255

POKE 786, 828 / 256

For the 'non-machine programmers' here is another loader program in BASIC that initializes the USR vector directly.

```txt
100 FOR I = 828 TO 875
110 READ X : POKE I,X : S=S+X : NEXT
120 DATA 165, 20, 72,165, 21, 72, 32,247,183,165, 1, 72
130 DATA 165, 21,201,208,144, 7,201,224,176, 3,169, 49
140 DATA 44,169, 52,120,133, 1,160, 0.177, 20,168,104
150 DATA 133, 1, 88,104,133, 21,104,133, 20, 76,162,179
160 IF S &lt;&gt; 5085 THEN PRINT "ERROR IN DATAS!!" :END
170 POKE 785, 828 AND 255 : POKE 786, 828/256
180 PRINT "OK!"
```

If you now want to read out the RAM or the character generator, simply replace the PEEK function with the USR function. For example, if you want the character matrix of a character, you can use the following small program:

```txt
100CG=13*4096
110A = (PEEK(53248+24) AND 2) * 1024
120 INPUT "SCREEN CODE OF CHARACTER";B
120 FOR I=0 TO 7
130 PRINT I, USR(CG+A+8*B+I) : NEXT
140 GOTO 110
```

Line 110 selects the lower or upper half of the character generator, depending on whether uppercase/graphics or lowercase/capitalization is selected.

<!-- TOC PAGE_352: BASIC programming memory expansion -->

===========================================================
                      PAGE 352 OF 386                       
===========================================================

You can easily determine the screen code like this: Place the character in the upper left corner of the screen and then query the code with PEEK(1024).

Now you have an additional 16K of RAM that you can use for data storage from BASIC, for example.

342

<!-- TOC PAGE_353: Commodore 64 multitasking explanation -->===========================================================
                      PAGE 353 OF 386                       
===========================================================

9.6 MULTI-TASKING ON THE COMMODORE 64

Multi-tasking is a term that originally comes from large-scale IT and means the simultaneous processing of several programs on one computer. How does something like this work?

Strictly speaking, even a mainframe can only work on one program at a time, but here you use a trick:

For example, if the computer is to run 5 programs at the same time, the procedure is as follows: The computer first starts processing the first program, after a certain time (fractions of a second) it stops working on it, saves all current variables and begins processing the next program. This program is also interrupted again after a short time in order to continue with the next one. Once all programs have had their turn, the variables from the first program are retrieved and this program is continued. The computer's computing time is divided into small 'time slices' between the individual programs, hence the frequently used expression 'time sharing'.

To a limited extent, this procedure is also possible on your Commodore 64. There are actually two programs running in your computer at the same time: your BASIC program and the so-called interrupt program, which is called and executed 60 times a second controlled by a timer. During the execution of the interrupt program execution, your BASIC program is interrupted. The interrupt program, for example, ensures that the keyboard is switched off regularly.

<!-- TOC PAGE_354: Commodore 64 time display program -->

===========================================================
                      PAGE 354 OF 386                       
===========================================================

is asked and that you can actually enter anything using the keyboard.

We can now 'hang in' and let the computer carry out additional tasks during the interrupt.

One application for this would be, for example, outputting a text to the printer. With each interrupt, for example, a character from a text buffer can be sent to the printer. The user would not be noticeably disturbed in his BASIC program; the program would run as usual.

As an example of such an application, we have a little treat for you: a program that constantly shows you the current time on the screen to the tenth of a second. The program uses the Commodore 64's built-in hardware clock. The current time is entered once and then automatically always displayed in the top right corner of the screen. The program is written in machine language, but can also be entered into BASIC using a loader.

100: C800 .OPT P1
; TIME, SHOW TIME
; SYS AD, "HHMMSS", COLOR
;

140: C800 FRMEVL = $AD9E ; FETCH BASIC EXPRESSION
150: C800 FRESTR = $B6A3
160: C800 CHKCOM = $AEFD ; CHECK FOR COMMA
170: C800 CHRGOT = $79
180: C800 GETBYT = $B79E ; FET BYTA EXPRESSION

344

<!-- TOC PAGE_355: Assembly code memory map -->===========================================================
                      PAGE 355 OF 386                       
===========================================================

345

|  190: | C800 | ILLQUAN = | $B248 ; 'ILLEGAL QUANTITY' |
| --- | --- | --- | --- |
|  200: | C800 | ADR = | $22 |
|  210: | C800 | COLOR = | $2A7 ; MEMORY FOR COLOR VALUE |
|  220: | C800 | VIDEO = | $288 ; HI-BYTE VIDEO RAM |
|  230: | C800 | TEMP = | $FB |
|  240: | C800 | IRQ = | $314 ; IRQ VECTOR |
|  250: | C800 | PNT = | $FB |
|  260: | C800 | IRQVEC = | $EA31 ; NORMAL IRQ ROUTINE |
|  270: | C800 | COLOR = | $D800 ; COLOR RAM |
|  280: | C800 | TENTH = | $DC08 ; REAL TIME CLOCK CIA 1 |
|  290: | C800 | SECOND = | TENTH +1 |
|  300: | C800 | MINUTE = | SECOND +1 |
|  310: | C800 | HOUR = | MINUTE+1 |
|  320: | C800 | TRIGGER = | HOUR +3 ; 50/60HZ |
|  330: | C800 | SET = | TRIGGER +1 ; SET TIME/ALARM |
|  340: | C800 | * = | $C800 |
|  350: | C800 AD OE DC | LDA | TRIGGERS |
|  360: | C803 09 80 | ORA | #%10000000 ; 50 HZ MODE |
|  370: | C805 8D OE DC | STA | TRIGGERS |
|  380: | C808 AD OF DC | LDA | SET |
|  390: | C80B 29 7F | AND | #%1111111 ; SET TIME |
|  400: | C80D 8D OF DC | STA | SET |
|  410: | C810 20 79 00 | JSR | CHRGOT ; ANOTHER CODE?  |
|  420: | C813 F0 65 | BEQ | CHGIRQ ; TURN CLOCK |
|  430: | C815 20FD AE | JSR | CHKCOM |
|  440: | C818 20 9E AD | JSR | FRMEVL ; GET STRING |
|  450: | C81B 20 A3 B6 | JSR | FRESTR ; PARAMETERS |
|  460: | C81E C9 06 | CMP | #6 ; 6 CHARACTERS?  |
|  470: | C820 D0 6B | GNI | ILL ; ILLEGAL QUANTITY |
|  480: | C822 A0 00 | LDY | #0 |
|  490: | C824 B1 22 | LDA | (ADR),Y ; HOUR TEN |
|  500: | C826 38 | SEC |   |
|  510: | C827 E9 30 | SBC | #"0" ; TO HEX |
|  520: | C829 C9 03 | CMP | #3 |

<!-- TOC PAGE_356: Assembly code listing -->

===========================================================
                      PAGE 356 OF 386                       
===========================================================

346

|  530: | C82B | BO | 60 |  | BCS | ILL |
| --- | --- | --- | --- | --- | --- | --- |
|  540: | C82D | OA |  |  | ASL |   |
|  540: | C82E | OA |  |  | ASL |   |
|  540: | C82F | OA |  |  | ASL |   |
|  540: | C830 | OA |  |  | ASL |   |
|  550: | C831 | 85 | FB |  | STA | TEMP |
|  560: | C833 | C8 |  |  | INY |   |
|  570: | C834 | B1 | 22 |  | LDA | (ADR),Y ; STD-ONE |
|  580: | C836 | 38 |  |  | SEC |   |
|  590: | C837 | E9 | 30 |  | SBC | #"0" |
|  600: | C839 | C9 | OA |  | CMP | #10 |
|  610: | C83B | BO | 50 |  | BCS | ILL |
|  620: | C83D | 05 | FB |  | ORA | TEMP |
|  630: | C83F | DO | 04 |  | GNI | NOTZERO |
|  640: | C841 | A9 | 92 |  | LDA | #\10000000 + $12 ; 12 PM |
|  650: | C843 | DO | OF |  | GNI | SETSTD |
|  660: | C845 | C9 | 24 | NOTZERO | CMP | #$24 |
|  670: | C847 | BO | 44 |  | BCS | ILL |
|  680: | C849 | C9 | 13 |  | CMP | #$13 |
|  690: | C84B | 90 | 07 |  | BCC | SETSTD |
|  700: | C84D | 38 |  |  | SEC |   |
|  700: | C84E | F8 |  |  | SED |   |
|  710: | C84F | E9 | 12 |  | SBC | #$12 |
|  710: | C851 | D8 |  |  | CLD |   |
|  720: | C852 | 09 | 80 |  | ORA | #\10000000 ; SET PM |
|  730: | C854 | 8D | OB | DC SETSTD | STA | HOUR |
|  740: | C857 | 20 | FD | C8 | JSR | GET59 ; GET MINUTES |
|  750: | C85A | 8D | OA | DC | STA | MINUTE |
|  760: | C85D | 20 | FD | C8 | JSR | GET59 |
|  770: | C860 | 8D | 09 | DC | STA | SECOND |
|  780: | C863 | A9 | 00 |  | LDA | #0 |
|  790: | C865 | 8D | 08 | DC | STA | TENTH ; START CLOCK |
|  800: | C868 | 20 | 79 | 00 | JSR | CHRGOT |
|  810: | C86B | FO | 0D |  | BEQ | CHGIRQ |

<!-- TOC PAGE_357: Assembly code listing -->===========================================================
                      PAGE 357 OF 386                       
===========================================================

347

|  820: | C86D 20FD AE | JSR | CHKCOM |
| --- | --- | --- | --- |
|  830: | C870 20 9E B7 | JSR | GETBYT ; COLOR |
|  840: | C873 EO 10 | CPX | #16 |
|  850: | C875 BO 16 | BCS | ILL |
|  860: | C877 8E A7 02 | STX | COLOR ; NOTE COLOR CODE |
|  870: | C87A 78 CHGIRQ | BE | ; SWAP IRQ VECTOR |
|  870: | C87B AD 14 03 | LDA | IRQ |
|  880: | C87E 49 A1 | EOR | #< IRQVEC ↑ TIMIRQ |
|  890: | C880 8D 14 03 | STA | IRQ |
|  900: | C883 AD 15 03 | LDA | IRQ + 1 |
|  910: | C886 49 22 | EOR | #> IRQVEC ↑ TIMIRQ |
|  920: | C888 8D 15 03 | STA | IRQ + 1 |
|  930: | C88B 58 | CLI |   |
|  940: | C88C 60 | RTS |   |
|  950: | C88D 4C 48 B2 ILL | JMP | ILLQUAN |
|   |  | ; DISPLAY ROUTINE |   |
|  970: | C890 A5 FB TIMIRQ | LDA | PNT |
|  970: | C892 48 | PHA |   |
|  970: | C893 A5 FC | LDA | PNT+1 ; SAVE POINTERS |
|  970: | C895 48 | PHA |   |
|  970: | C896 AD 88 02 | LDA | VIDEO ; HIGHBYT VIDEO RAM |
|  980: | C899 85FC | STA | PNT+1 |
|  990: | C89B A9 00 | LDA | #0 |
|  1000: | C89D 85FB | STA | PNT ; POINTER TO VIDEO RAM |
|  1010: | C89F AO 1E | LDY | #30 ; 30. COLUMN |
|  1020: | C8A1 AD OB DC | LDA | HOUR |
|  1020: | C8A4 C9 12 | CMP | #$12 |
|  1020: | C8A6 F0 11 | BEQ | ZERO CLOCK |
|  1020: | C8A8 C9 80 | CMP | #$80 |
|  1020: | C8AA 90 OF | BCC | STDOUT ; AM |
|  1030: | C8AC 29 7F | AND | #%1111111 |
|  1030: | C8AE C9 12 | CMP | #$12 |
|  1030: | C8BO F0 09 | BEQ | STDOUT |
|  1040: | C8B2 F8 | SED |   |

<!-- TOC PAGE_358: Assembly code listing -->

===========================================================
                      PAGE 358 OF 386                       
===========================================================

348

|  1040: | C8B3 18 |  | CLC |   |
| --- | --- | --- | --- | --- |
|  1040: | C8B4 69 12 |  | ADC | #$12 |
|  1040: | C8B6 D8 |  | CLD |   |
|  1040: | C8B7 DO 02 |  | GNI | STDOUT |
|  1050: | C8B9 A9 00 | ZERO CLOCK | LDA | #0 |
|  1060: | C8BB 20DB C8 | STDOUT | JSR | PRINT ; VIEW HOUR |
|  1070: | C8BE AD 0A DC |  | LDA | MINUTE |
|  1080: | C8C1 20DB C8 |  | JSR | PRINT ; VIEW MINUTES |
|  1090: | C8C4 AD 09 DC |  | LDA | SECOND |
|  1100: | C8C7 20DB C8 |  | JSR | PRINT ; SHOW SECONDS |
|  1110: | C8CA AD 08 DC |  | LDA | TENTH |
|  1120: | C8CD 09 30 |  | ORA | #"0" |
|  1130: | C8CF 20 F3 C8 |  | JSR | PRINT1 ; SHOW TENTHS |
|  1140: | C8D2 68 |  | PLA |   |
|  1140: | C8D3 85 FC |  | STA | PNT+1 |
|  1140: | C8D5 68 |  | PLA | ; RETURN POINT |
|  1140: | C8D6 85 FB |  | STA | PNT |
|  1140: | C8D8 4C 31 EA |  | JMP | IRQVEC ; TO THE OLD IRQ |
|  1150: | C8DB 48 | PRINT | PHA | ; ADVERTISEMENT |
|  1160: | C8DC 29 FO |  | AND | #%11110000 |
|  1160: | C8DE 4A |  | LSR |   |
|  1160: | C8DF 4A |  | LSR |   |
|  1160: | C8EO 4A |  | LSR |   |
|  1160: | C8E1 4A |  | LSR |   |
|  1170: | C8E2 18 |  | CLC |   |
|  1170: | C8E3 69 30 |  | ADC | #"0" |
|  1180: | C8E5 20 F3 C8 |  | JSR | PRINT1 |
|  1190: | C8E8 68 |  | PLA |   |
|  1200: | C8E9 29 OF |  | AND | #%1111 |
|  1210: | C8EB 18 |  | CLC |   |
|  1210: | C8EC 69 ​​30 |  | ADC | #"0" |
|  1220: | C8EE 20 F3 C8 |  | JSR | PRINT1 |
|  1230: | C8F1 A9 3A |  | LDA | #": " |
|  1240: | C8F3 91 FB | PRINT1 | STA | (PNT),Y ; CHARACTERS |

<!-- TOC PAGE_359: 6502 assembly code listing -->===========================================================
                      PAGE 359 OF 386                       
===========================================================

349

|  1250: | C8F5 AD A7 02 | LDA COLOR |
| --- | --- | --- |
|  1260: | C8F8 99 00 D8 | STA COLOR,Y ; AND COLOR |
|  1270: | C8FB C8 | INY |
|  1270: | C8FC 60 | RTS |
|  1280: | C8FD C8 GET59 | INY |
|  1290: | C8FE B1 22 | LDA (ADR),Y ; TENS |
|  1300: | C900 38 | SEC |
|  1310: | C901 E9 30 | SBC #"0" |
|  1320: | C903 C9 06 | CMP #6 |
|  1330: | C905 B0 86 ILL1 | BCS ILL |
|  1340: | C907 OA | ASL |
|  1340: | C908 OA | ASL |
|  1340: | C909 OA | ASL |
|  1340: | C90A OA | ASL |
|  1350: | C90B 85 FB | STA TEMP |
|  1360: | C90D C8 | INY |
|  1370: | C90E B1 22 | LDA (ADR),Y ; ONE |
|  1380: | C910 38 | SEC |
|  1390: | C911 E9 30 | SBC #"0" |
|  1400: | C913 C9 OA | CMP #10 |
|  1410: | C915 B0 EE | BCS ILL1 |
|  1420: | C917 05 FB | ORA TEMP |
|  1420: | C919 60 | RTS |

If you don't have an assembler or monitor available for your 64, you will then find a loading program in BASIC.

100 FOR I = 51200 TO 51481
110 READ X : POKE I,X : S=S+X : NEXT
120 DATA 173, 14,220, 9,128,141, 14,220,173, 15,220, 41
130 DATA 127,141, 15,220, 32,121, 0,240,101, 32,253,174

<!-- TOC PAGE_360: BASIC program clock display -->

===========================================================
                      PAGE 360 OF 386                       
===========================================================

140 DATA 32,158,173, 32,163,182,201, 6,208,107,160, 0
150 DATA 177, 34, 56,233, 48,201, 3,176, 96, 10, 10, 10
160 DATA 10,133,251,200,177, 34, 56,233, 48,201, 10,176
170 DATA 80, 5,251,208, 4,169,146,208, 15,201, 36,176
180 DATA 68,201, 19,144, 7, 56,248,233, 18,216, 9,128
190 DATA 141, 11,220, 32,253,200,141, 10,220, 32,253,200
200 DATA 141, 9,220,169, 0.141, 8,220, 32,121, 0.240
210 DATA 13, 32,253,174, 32,158,183,224, 16,176, 22,142
220 DATA 167, 2,120,173, 20, 3, 73,161,141, 20, 3,173
230 DATA 21, 3, 73, 34,141, 21, 3, 88, 96, 76, 72,178
240 DATA 165,251, 72,165,252, 72,173,136, 2,133,252,169
250 DATA 0,133,251,160, 30,173, 11,220,201, 18,240, 17
260 DATA 201,128,144, 15, 41,127,201, 18,240, 9,248, 24
270 DATA 105, 18,216,208, 2,169, 0, 32,219,200,173, 10
280 DATA 220, 32,219,200,173, 9,220, 32,219,200,173, 8
290 DATA 220, 9, 48, 32,243,200,104,133,252,104,133,251
300 DATA 76, 49,234, 72, 41,240, 74, 74, 74, 74, 24,105
310 DATA 48, 32,243,200,104, 41, 15, 24,105, 48, 32,243
320 DATA 200,169, 58,145,251,173,167, 2,153, 0,216,200
330 DATA 96,200,177, 34, 56,233, 48,201, 6,176,134, 10
340 DATA 10, 10, 10,133,251,200,177, 34, 56,233, 48,201
350 DATA 10,176,238, 5,251, 96
360 IF S &lt;&gt; 32970 THEN PRINT "ERROR IN DATAS!!" :END
370 PRINT "OK!"

The program for constantly displaying the time is used as follows:

If you want to enter the time and turn on the display, enter the following command:

SYS 51200, "HHMMSS", COLOR

<!-- TOC PAGE_361: Multitasking application programming guide -->

===========================================================
                      PAGE 361 OF 386                       
===========================================================

"HHMMSS" means the time (hour, minute, second) and COLOR means the color code of the displayed time (from 0 to 15). For example, if you want to set the clock to 2 p.m., 30 minutes and 15 seconds and the display should appear yellow, you would enter the following SYS command:

SYS 51200, "143015",7

The current time now appears in the top right corner with hours, minutes, seconds and tenths of a second. You can switch off the display by entering

SYS 51200

Only the display is switched off; the time continues internally. By entering again

SYS 51200

the current time appears again.

And here are some tips for creating your own multitasking applications:

In principle, there are two methods for inserting a second "job":

The first option is to exploit the system interrupt routine, which is called every sixtieth of a second. This alternative was also used in our routine to display the time. To do this, you proceed as follows: You change the interrupt vector so that it points to your own routine. Your own routine must then be completed by jumping to the original interrupt routine so that the computer continues to query the keyboard, for example.

351

<!-- TOC PAGE_362: Commodore 64 interrupt programming guide -->===========================================================
                      PAGE 362 OF 386                       
===========================================================

With the other alternative, the routine to be integrated triggers an interrupt itself. This could be done, for example, when outputting to the printer. For example, you could use the printer's busy line as an interrupt trigger. Every time the printer is ready to accept a character, it triggers an interrupt. In the interrupt routine a character is now sent to the printer and then the normal program continues. Once the printer has processed the character, it triggers another interrupt in which the next character can then be sent. The user of the computer doesn't notice anything.

To program your own applications, you will of course need knowledge of the Commodore 64's operating system, which you will find internally in '64.

352

<!-- TOC PAGE_363: POKE commands memory addresses guide -->

===========================================================
                      PAGE 363 OF 386                       
===========================================================

353

#9.7 POKEs AND THE ZEROPAGE

As you have probably already noticed, there are various addresses that can be useful when programming in both BASIC and machine language. Here is a small excerpt from various addresses:

|  Address: | (possible) application: |
| --- | --- |
|  0000-0001 | By POKE in one or both of these addresses, a specific memory area can be switched off and on again |
|  0043-0044 | This address points to the beginning of the user memory, i.e. to the start of the BASIC program. You can get started with this line: PEEK(43)+256*PEEK(44). On the other hand, you can also use POKE to set the beginning higher and thus use the lower memory area for the remaining sprites.  |
|  0045-0046 | In this address you will find the start of the memory location where the numeric variables begin. This address is usually located directly after the BASIC program memory.  |
|  0047-0048 | This is the start address for the array storage space. All fields (arrays) are stored in this area.  |
|  0049-0050 | This address indicates the end of the array space.  |
|  0051-0052 | The text variables | begin at this address

<!-- TOC PAGE_364: Commodore 64 memory addresses guide -->

===========================================================
                      PAGE 364 OF 386                       
===========================================================

(Strings) of the BASIC program.

0055-0056

Pointer to the end of BASIC RAM. By moving this address, it is possible to protect a specific memory area in the Commodore 64's RAM from being overwritten. This means you can reserve this protected memory area for machine programs, but still have the area from $COO0 to $CFFF free for other purposes. For example: POKE 55.0: POKE 56.64. These POKEs set the BASIC RAM end after $4000.

0115-0138

At this point is the CHRGET routine, which fetches the characters from the individual BASIC lines. To write a BASIC extension, this routine must be changed.

0203

This address contains the code of the currently pressed key. If the value of this address is 64, it means that no key is pressed.

If you would like to take a closer look at the 'inside' of the Commodore 64, we recommend that you read the DATA BECKERS BOOK 64 internally. There you will find out more about programming in machine language and the structure of the Commodore RAM and ROM. Experiment with the different addresses of the Commodore 64 yourself. There's a lot in your 64 - you just have to get it out of it.

<!-- TOC PAGE_365: Text input control guide -->===========================================================
                      PAGE 365 OF 386                       
===========================================================

355

# 9.8 CONTROL OF TEXT ENTRY VIA THE KEYBOARD

A very common problem in data processing is the query and control of input via the keyboard. For this reason, we would like to take a closer look at this problem at this point.

The most common method of entering information from the keyboard is the INPUT command. Although this command is very easy to use, its disadvantage is the insufficient ability to control the characters entered. If you use this command, you should generally do so with a text input (i.e. $), even when entering numbers. This at least ensures that if you enter an incorrect entry, for example a text that requires a number, the program does not start with one

## ?REDO FROM START

Error disrupts the program flow. However, if you use text input and want to enter a number, you must of course first convert this text into a number using the VAL function. Nevertheless, this application is safer than reading a number directly. However, there are some special features that you need to take into account. This is how the result of the function is:

```
A$="123D4": PRINT VAL(A$)
```

the value 123. On the other hand, results in

```
A$="123E2": PRINT VAL(A$)
```

the value 12300. Here the character "E" has the meaning as EXPONENT, i.e. 10↑x. In our example: 123 x 10 ↑ 2. We see that in the "normal case" the value of a text is only output up to the next letter, unless it is an "E". But here too there is an exception. The function:

<!-- TOC PAGE_366: BASIC code for text-to-number conversion -->

===========================================================
                      PAGE 366 OF 386                       
===========================================================

A$="123EE2": PRINT VAL(A$)

in turn results in the value 123. If you ever find yourself in the dilemma of forming a number from a text that was entered via input and you want to ignore all the letters, the following routine will be quite useful to you:

(We assume that the text is stored in the variable A$. You can of course modify the program so that you can also check other variables.)

50000 IF LEN(A$)=0 THEN RETURN: REM NO TEXT AVAILABLE
50005 B$="": DELETE REM TEXT
50010 FOR I=1 TO LEN(A$): TEST REM WHOLE TEXT
50020 TS$=MID$(A$,I,1): REM CHARACTER AT POSITION X
50030 IF TS$&lt;"0" OR TS$&gt;"9" THEN 50050: REM A NUMBER ?
50040 B$=B$+TS$: FORM REM NEW TEXT
50050 NEXT I: REM NEXT CHARACTER
50060 A=VAL(B$): FORM REM VALUE
50070 RETURN: REM BACK TO THE MAIN PROGRAM

If you call this routine from your main program with the passed value A$="123DD4" (GOSUB 50000), the value 1234 in the variable A is returned to the main program. However, the variable A$ remains unchanged. But you have to remember that the exponential information now has no effect. If you want to solve this small problem, you can modify the program as follows:

50025 IF TS$="E" THEN 50040

Now the correct result 12300 is also delivered with the value A$="123E2".

Another problem that can occur when inputting using INPUT is the distinction between lower case and

356

<!-- TOC PAGE_367: Commodore 64 text case handling -->===========================================================
                      PAGE 367 OF 386                       
===========================================================

Uppercase letters, provided you have switched the Commodore 64 to uppercase/lowercase letters using PRINT CHR$(14). These distinctions are often very useful when searching for terms within a text or any other information where you are not sure whether they were entered in uppercase or upper/lowercase. This problem occurs more often with the Commodore 64 because there are two options: uppercase/lowercase font or uppercase/graphics.

Imagine you are looking for the address with the name Meier within an address file. Not only is this name common, it can also be spelled differently, i.e. MEIER or Meier. To find all of these names, we again need to write a little routine that allows us to find both MEIER and Meier.

We already have a similar problem in our first routine for finding letters in numbers. There we examined the entire text (in modern German STRING) for numbers. Now we need to examine the text for either uppercase or lowercase letters. Since the small letters on the Commodore are usually located at the bottom of the character table, we want to check for capital letters, as these are converted into graphic characters after switching to capital/graphics - and this doesn't look particularly nice in normal text display.

As just mentioned, the capital letters are at the top of the character set. The difference between "a" and "A" is exactly 128. "a" is coded as CHR$ 65 and "A" as CHR$ 193. Represented in binary is 65 01000001 and 193 11000001. As you can see, both numbers only differ in the first "1". If you know a little bit about Boolean algebra you will know how to convert this "1" into a "0" so that the 193, i.e. "A", becomes a 65, i.e. "a".

But even if you are not familiar with this calculation method

357

<!-- TOC PAGE_368: Bitwise operation code example -->

===========================================================
                      PAGE 368 OF 386                       
===========================================================

If you are familiar with it, you will immediately understand how this number conversion takes place.

0 1 0 0 0 0 0 1 65 a
1 1 0 0 0 0 0 1 193 A
0 1 1 1 1 1 1 1 127

the result should be:

0 1 0 0 0 0 0 1 65 a

To get this result you have to UNDER the number 65 with the number 127 (AND). Each number only becomes "1" if both digits compared are "1". So we see that the first "1" is simply hidden. Here is the program that turns A$="Meier" into A$="meier".

50000 IF LEN(A$)=0 THEN RETURN: REM NO TEXT AVAILABLE
50002 B$="": REM DELETE THE INTERMEDIATE TEXT
50005 FOR I=1 TO LEN(A$): REM WHOLE TEXT
50010 T$=MID$(A$,I,1): REM CHECK EACH CHARACTER
50020 T=ASC(T$): REM WHAT CODE DOES THIS CHARACTER HAVE?
50030 T=T AND 127: REM HIDE THE FIRST BIT (1)
50040 T$=CHR$(T): FORM CHARACTERS WITH NEW CODE
50050 B$=B$+T$: FORM REM NEW TEXT
50060 NEXT I: REM NEXT CHARACTER
50070 RETURN: REM BACK TO THE MAIN PROGRAM

With this little routine you can easily check all your entries. In theory, the same change would be from uppercase/lowercase to uppercase. To do this you then have to replace the AND 127 with an OR 128. This OR does exactly the opposite of what AND does. Each BIT is then set to "1" if a digit is "1". 128 is represented as 1000000.

358

<!-- TOC PAGE_369: Formatted BASIC program listing tool -->===========================================================
                      PAGE 369 OF 386                       
===========================================================

359

#9.9 - FORMATTED PROGRAM LISTING -

The following small program was originally created to make typing programs easier for you. All programs that were newly written for this 4th expanded edition were written using this routine.

With this program you have a tool at hand that allows you to freely design your program listings (of basic programs) in the print width. All that is required is that after you have loaded this routine, you specify the name of the program to be printed and the desired number of characters per line. The listing is then created by fetching the source code from the diskette one byte at a time and translating it into its print format. Of course, cursor control characters are also printed out. To do this, when the program encounters a quotation mark, the variable "M" is set to "1". All ASC codes read from the diskette are then checked for a control format. If it is a control character, the corresponding inverse print character is inserted into the listing.

```basic
100 REM***
110 REM FORMATTED PRINT
120 REM***
130 DIMK$(75):FORI=1TO75:READK$(I):NEXTI
140 PRINTCHR$(147):INPUT "PROGRAM NAME";
P$
150 INPUT "CHARACTERS PER LINE";J:IFJ=0ORJ&gt;7
9THEN150
160 OPEN1,8,0,P$:OPEN4,4,0
170 GOSUB 480: REM START
180 GOSUB 480 : REM SEQUENCE
190 IF F = 0 THEN CLOSE4:CLOSE1:END
200 GOSUB 480 : REM LINE NO
210 Z$=F$+" "
220 GET#1,A$:IFA$=""THENA$=CHR$(0)
230 A=ASC(A$):IFA=0THENGOSUB590:GOTO180
240 IFM=1THENGOSUB290:GOTO260
250 IFA&gt;127ANDA&lt;203THENZ$=Z$+K$(A-127)
260 IFA&gt;31ANDA&lt;128THENZ$=Z$+CHR$(A)
270 IFA=34THENM=M+1:IFM=2THENM=0
```

<!-- TOC PAGE_370: BASIC programming code listing -->

===========================================================
                      PAGE 370 OF 386                       
===========================================================

280 GOTO 220
290 IFA=5 THENZ$=Z$+"3"
300 IFA=17 THENZ$=Z$+"2"
310 IFA=18 THENZ$=Z$+"3"
320 IFA=160THENZ$=Z$+" "
330 IFA=145THENZ$=Z$+"☐"
340 IFA=19 THENZ$=Z$+"☐"
350 IFA=20 THENZ$=Z$+"☐"
360 IFA=28 THENZ$=Z$+"☐"
370 IFA=29 THENZ$=Z$+"☐"
380 IFA=30 THENZ$=Z$+"☐"
390 IFA=31 THENZ$=Z$+"☐"
400 IFA=144THENZ$=Z$+"■"
410 IFA=146THENZ$=Z$+"☐"
420 IFA=147THENZ$=Z$+"☐"
430 IFA=156THENZ$=Z$+"☐"
440 IFA=157THENZ$=Z$+"☐"
450 IFA=158THENZ$=Z$+"☐"
460 IFA=159THENZ$=Z$+"☐"
470 RETURNS
480 GET#1,A$:IFA$=""THENA$=CHR$<0>
490 FL =ASC(A$)
500 GET#1,A$:IFA$=""THENA$=CHR$<0>
510 FH =ASC(A$)
520 F=FA*256+FL :F$=STR$(F) :F$=RIGHT$(F
$,LEN(F$)-1)
530 RETURN
540 DATAEND,FOR,NEXT,DATA,INPUT#,INPUT,D
IM,READ,LET,GOTO,RUN,IF,RESTORE,GOSUB
550 DATARETURN,REM,STOP,ON,WAIT,LOAD,SAV
E,VERIFY,DEF,POKE,PRINT#,PRINT,CONT
560 DATALIST,CLR,CMD,SYS,OPEN,CLOSE,GET,
NEW,TAB(&lt;,TO,FN,SPC(&lt;,THEN,NOT,STEP
570 DATA+,-*,/,↑,AND,OR,&gt;,=,&lt;,SGN,INT,A
BS,USR,FRE,POS,SQR,RND,LOG,EXP,COS,SIN
580 DATATAN,ATN,PEEK,LEN,STR$,VAL,ASC,CH
R$,LEFT$,RIGHT$,MID$
590 IFLEN(Z$)<j+1THENPRINT#4,z$:RETURN
600 PRINT#4,LEFT$(Z$,J):Z$=RIGHT$(Z$,LEN
(Z$)-J):GOTO590

Listing explanation
---
100-120 program header
130 Creating the strings for the basic keywords
140-150 User input of parameters
160 Open a channel for reading the program

360</j+1THENPRINT#4,z$:RETURN>

<!-- TOC PAGE_371: Program code listing and notes -->===========================================================
                      PAGE 371 OF 386                       
===========================================================

that should be delisted. Open the printer channel

170-210 Preparation of the following address and the line number
220-260 Convert the program byte to a token or the normal character value
270 Check for quotation marks
280 End of loop for next program byte
290-470 Text generation for cursor control characters
480-530 Subprogram for calculating a 2-byte address
540-580 String values for tokens
590-600 Print output of a prepared line

This program may serve as a basic framework for additional functions that are not yet included here. So it might be desirable to take the number of lines per page into account in addition to the number of characters per line. This is relatively easy to implement because only one counter needs to be implemented in the two print output lines. Sometimes the characters for the control characters with the cursor color orange to gray3 are not yet generated. There is already space reserved for this in lines 460 to 470.

Problems can arise if a string in the source text is not delimited by a second quotation mark. But this can be achieved with a small change. Line 180 must be changed as follows:

180 GOSUB 480 : M = 0 : REM sequence

<!-- TOC PAGE_372: Programming warm start guide -->

===========================================================
                      PAGE 372 OF 386                       
===========================================================

9.10 SAVING VARIABLES AND WARM START

Maybe you also know our book 64 internally? There we noted in the address manager map that the program for filtering the redundant combinations ran for several weeks 'at a time'.

You may also have larger tasks to complete, but are afraid to leave the program running unattended.

Here we have the solution for you:

All you need to do is expand your program to include the lines presented here and you can stop the run at any time and continue the next day with the current variable contents.

If you do not have a fixed warm start point in your program, change line 7 to

7 STOP

The associated routines are pleasingly short. Lines 10 ... 140 are for demonstration purposes only and are not needed in the event of an emergency.

Please do not believe that lines 63050 ... 63070 are redundant! They just appear to do the same thing as the three lines before them. Going into the background would go too far at this point.

The application is very simple:

When you think your program has run long enough, simply press the STOP button. Note the line number. the 'BREAK' message!

362

<!-- TOC PAGE_373: Programming warm start instructions manual -->

===========================================================
                      PAGE 373 OF 386                       
===========================================================

Make sure that the termination does not occur in the middle of a line (if there are several commands in one line)!

Then enter: GOTO 63000

That's all.

If you have anchored all string variables as literals in the program itself, as in the example, you can answer the question of whether the strings should also be saved with 'N'. These variables are available again after the warm start.

If you did not answer 'N', it will take a while until you get the 'DONE' message because the entire area from the end of the program to the upper memory limit is saved.

To warm start, load your program and enter:

RUN2

Now it may take some time until the 'BREAK' message comes (or not, depending on what line 7 looks like).

The program itself must not have been changed in the meantime, otherwise the variable area will shift!

Now enter (after 'BREAK'):

GOTO line no.

Line number must be the one that follows the one you remembered when you canceled it, and then it continues.

There is a catch:

Files that may be open when you cancel are now not open! You may have to do this manually after the 'BREAK'. In such cases, it is advisable to design the program specifically for the warm start, i.e. that it only works in the places

363

<!-- TOC PAGE_374: BASIC program tape save code -->===========================================================
                      PAGE 374 OF 386                       
===========================================================

can be interrupted where all files are closed.

By the way, the cold start must be done with:
RUN 10 (or another line number).

```txt
1 goto 3
2 load"var1",8,1
3 poke48,159
4 poke47,z1:poke48,z2
5 poke49,z3:poke50,z4
6 poke51,z5:poke52,z6
7 goto 100
10 a=1:b=2:c=3
20 a$="aa":b$="bb":c$="cc"
30 d$(0)="dd":d$(1)="ee":d$(2)="ff"
40 fori=0to9:d(i)=i:next
50 goto63000
100 printa,b,c
110 printa$,b$,c$
120 printd$(0),d$(1),d$(2)
130 fori=0to9:printd(i),;:next
140 end
63000 ca=827:f$="var1"
63010 input"also strings y/n";re$
63020 z1=peek(47):z2=peek(48)
63030 z3=peek(49):z4=peek(50)
63040 z5=peek(51):z6=peek(52)
63050 z1=peek(47):z2=peek(48)
63060 z3=peek(49):z4=peek(50)
63070 z5=peek(51):z6=peek(52)
63080 open15,8,15,"s0:var1":close15
63090 rem filename after cartridge buffer
63100 fori=1to len(f$):pokeca+i,asc(mid$(f$,i,1)):next
63110 if re$&lt;&gt;"n"then63150
63120 rem end address
63130 z5=peek(55):z6=peek(56)
63140 poke781,peek(49):poke782,peek(50):goto63160
63150 poke781,peek(55):poke782,peek(56)
63160 rem start address and pointer to start address.
63170 poke251,peek(45):poke252,peek(46):poke780,251
63180 rem device address, pointer to filename and length filename
63190 poke186,8:poke187,60:poke188,3:poke183,len(f$)
63200 sys65496:rem save
63210 print "ZefFertig"
```

364

<!-- TOC PAGE_375: Retro database software advertisement -->

===========================================================
                      PAGE 375 OF 386                       
===========================================================

# THAT'S IT

The professional database for Commodore 64 and Apple IIe/IIc

![img-8.jpeg](img-8.jpeg)

![img-9.jpeg](img-9.jpeg)

Anyone who was previously jealous of the performance features of expensive databases for larger computers can now keep up without having to buy a new computer: with SUPERBASE, the professional database for COMMODORE 64 and APPLE IIe/IIc. Here are some of the features of this “super” database:

- maximum data record length 1108 characters, spread over up to 4 screen pages
- up to 127 fields per record, where text fields can be up to 255 characters long
- A total of 15 individual files can be linked to a SUPERBASE database
- Storage capacity limited only by floppy disk
- Extensive evaluation options and convenient report generator
- Calculation options and arithmetic
- import (reading in external data) and export (outputting SUPERBASE files as sequential files) functions enable data exchange with other programs
- Can also be used as a complete application generator thanks to the powerful database language
- German screen dialogs and extensive German manual

SUPERBASE is available for COMMODORE 64 (DM 398,-) and Apple IIe/IIc (DM 498,-) and Apple IIe/IIc (DM 498,-) recommended retail price).

## The expert system

For COMMODORE 64, IBM PC and APPLE IIe/IIc users, the future has already begun. From the end of November we can supply you with the XPER expert system for these computers. XPER is a database based on the principles of artificial intelligence. The principle of an expert system like XPER is simple and impressive at the same time. They “feed” XPER with their knowledge, e.g. B. as a doctor about diseases and symptoms. XPER then helps you later with the diagnosis by asking questions and working through the search tree based on their answers until a satisfactory solution or narrowing down of possible solutions is found. The possible applications of an expert system are practically unlimited and are left to the user's imagination. The XPER versions for the individual computers only differ in the amount of data:

|   | Objects | Criteria | Properties |
| --- | --- | --- | --- |
|  IBM PC | 300 | 50 | 250 |
|  APPLE IIe/IIc | 90 | 30 | 200 |
|  COMMODORE 64 | 100 | 40 | 200 |

The COMMODORE 64 and APPLE versions each cost DM 298 and the IBM version costs DM 498 (recommended retail price).

![img-10.jpeg](img-10.jpeg)

## for your computer

![img-11.jpeg](img-11.jpeg)

<!-- TOC PAGE_376: Commodore 64 machine language books -->===========================================================
                      PAGE 376 OF 386                       
===========================================================

# Machine language

![img-12.jpeg](img-12.jpeg)

The bestseller, which has sold over 40,000 times, provides you with an easy-to-understand and comprehensive introduction to machine language. You will learn about the structure and operation of the 65'10 microprocessor, learn how to enter and start machine programs and learn how to use a monitor, assembler and disassembler. Assembler and disassembler are included in the book as programs, as well as a single-step simulator with which you can execute your programs step by step. Many detailed example programs and routines. With this tried and tested book, it shouldn't be difficult for you to get started with machine language. THE MACHINE LANGUAGE BOOK FOR THE COMMODORE 64, approx. 200 pages, DM 39,-

# No problem!

![img-13.jpeg](img-13.jpeg)
3

Have you gotten started with machine language? Then the “new English” will show you how to become a professional now. From problem analysis to machine language algorithms, you will be comprehensively introduced to the basics of professional machine language programming... Plus many example programs, complete machine routines and important tips &amp; Tricks for machine programming and working with the operating system. THE MACHINE LANGUAGE BOOK FOR POST-ADVANCED STUDENTS, approx. 200 pages, DM 39,-

With the important PEEK and POKE commands, many things can be done from BASIC that would otherwise require complicated machine routines. This book explains how to use PEEKS and POKES in an easy-to-understand manner. With a huge number of important POKES and their possible uses. The structure of the C-64 is well explained: operating system, interpreter, zero page, pointer and stacks, character generator, splash register, programming of interfaces, switching off the interrupt. A first introduction to machine language. Many example programs. PEEKS &amp; POKES FOR THE COMMODORE 64, approx. 170 pages, DM 29,-

![img-14.jpeg](img-14.jpeg)
4

Compilers are one of the most important tools for a programmer. In this book you can see what a successful compiler author is doing. He not only explains the basics, functionality and correct use of compilers, but also shows how a compiler is developed using the example of his own language. Lexical analysis, syntactic analysis, semantic analysis and code generation are described in detail. Many useful programs round out this book tailored to the COMMODORE 64, which should be required reading for every serious programmer. UNDERSTAND COMPILER – USE – DEVELOP, approx. 200 pages, DM 49,-

Release date: December '84

A comprehensive, practice-oriented introduction to the important topic of file management and databases especially for COMMODORE 64 users. File management, databases, database languages ​​and expert systems are explained, as are logical and physical data structures as well as sequential and direct access. Anyone who wants to know how to work with data sets larger than 255 characters, how a hashing file is structured, how direct access works or how to create a complete file management program (included in the book as a detailed listing) needs this new super book. EVERYTHING ABOUT FILE MANAGEMENT AND DATABASES, approx. 200 pages, DM 39,-

![img-15.jpeg](img-15.jpeg)

access works or how to create a complete file management program (included in the book as a detailed listing), you need this new super book. EVERYTHING ABOUT FILE MANAGEMENT AND DATABASES, approx. 200 pages, DM 39,-

![img-16.jpeg](img-16.jpeg)
6

Almost everything you can do with the 64. Written in an easy-to-understand and exciting way. With programs to use and learn:

![img-17.jpeg](img-17.jpeg)
7

Poems from the computer, party invitations, sales letters, car cost calculations, recipe files, health archives, handicraft aids and much more. Absolutely recommended for every 64er user! THE IDEAS BOOK FOR THE COMMODORE 64, 1984, over 200 pages, DM 29,-

![img-18.jpeg](img-18.jpeg)
8

Baden-friendly and successful programming in BASIC is not just for professionals. The software authors from DATA BECKER reveal how to do it: menu control, mask structure,

Parameterization and documentation are the key words. Plus the powerful data management QUANA! with ready-to-run example programs. 64 FOR PROFESSIONALS, 2nd edition 1984, approx. 300 pages, DM 49,-

# Graphics and

The bestseller for graphics programming of the C64 from the author of the famouswith super graphics. For beginners, advanced users and professionals. Brings everything about sprites, high-res

Graphics and multicolor through to 3D and CAD. Countless super programs and routines to type out. THE GRAPHICS BOOK FOR THE COMMODORE 64, 1984, 295 pages, DM 39,-

<!-- TOC PAGE_377: Commodore 64 programming guide books -->===========================================================
                      PAGE 377 OF 386                       
===========================================================

# Lots of tips &amp; Tricks

![img-19.jpeg](img-19.jpeg)

![img-20.jpeg](img-20.jpeg)

![img-21.jpeg](img-21.jpeg)

1) THE BESTSELLER – VOLUME 1

64 Tips &amp; Tricks, the best-selling DATA BECKER BOOK with over 70,000 copies, is a highly interesting collection of suggestions for advanced programming of the COMMODORE 64, POKE's and other useful routines and interesting programs. From the content: 3D graphics in BASIC - Colored bar graphics - Definition of your own character set - Keyboard layout - Simulation of the mouse with a joystick - BASIC for advanced users - C-64 speaks German - CP/M on the COMMODORE 64 - Printer connection via the USER port - Data transfer from and to other computers - Synthesizer in stereo - Saving an improperly closed file - Creating a BASIC line in BASIC - cassette buffer as data storage - multitasking on the COMMODORE 64-POKE's and the zero page - GOTO, GOSUB and RESTORE with calculated cell numbers, INSTR and STRING function - repeat function for all keys. All machine programs with BASIC loading programs. 64 Tips &amp; Tricks is a real treasure trove for every COMMODORE 64 user.

64 TIPS &amp; TRICKS, 1984, over 300 pages, DM 49,-

2) NOW MORE TIPS &amp; TRICKS – VOLUME 2

The second volume of 64 Tips &amp; Tricks is likely to become a bestseller very quickly. The book contains a wealth of high-quality programs, suggestions and routines: an extensive chapter on software protection - command extensions and how to do them - tips &amp; Tricks for programming super games - pointers and their manipulation - more about interrupt handling with many examples - expanded hardware options - copying the operating system into RAM and manipulating it there - as well as many other programs, command extensions and useful routines. If you like programming and want to know more about the COMMODORE 64, you need this new book.

64 TIPS &amp; TRICKS Volume 2, approx. 250 pages, DM 39,-

# sound

![img-22.jpeg](img-22.jpeg)

8 With the music book you can use the sound possibilities of the C64! In addition to a brief introduction to computer music, you will find information about sound registers, ADSR programming, synchronization and ring modulation. Numerous examples of sound and song programming as well as important routines round off the content. THE MUSIC BOOK FOR THE COMMODORE 64, over 200 pages, DM 39.00.

The Schneider CPC 464® not only has an excellent price/performance ratio, but also exceptional graphics and sound capabilities. This book presents the possibilities of the CPC 464 comprehensively and in an easy-to-understand manner. Many useful example programs round off the text. CPC 464 GRAPHICS &amp; SOUND, approx. 200 pages, DM 39,-

Release date: December '84

![img-23.jpeg](img-23.jpeg)

13 Lots of tips and tricks about the CPC 464.

From the hardware structure, operating system, basic tokens, drawing with the joystick, applications of Windmie technology and many interesting programs such as extensive file management, sound editor, comfortable character generator to complete listings of exciting games, the book offers many suggestions and important help. Every CPC 464 owner should have this huge treasure trove! CPC 464 TIPS &amp; TRICKS, 1984, over 250 pages, DM 39,-

14 Particularly important: The APPLE II TIPS &amp; TRICKS book is based on experiences working with the II+, IIe and the new super-compact IIc. Useful PEEKs and POKEs, basics of ASSEMBLER programming, color graphics, and the structure of screen masks are just some of the wide range of topics. An overview of the use of important software for the APPLE II rounds off this new book that every Apple II owner should have. APPLE II TIPS &amp; TRICKS, 1984, over 400 pages, DM 49,-

15 A book with utilities, tricks and many programs. Definitions of new data structures: list, stack, queue. Functional programs: permutations, combinations, factorials, etc. Games, number conversion. Graphics: CAD/CAM and 3D graphics. And the best thing: TEXTOMAT as a convenient editor for PASCAL 64! PASCAL 64 TIPS &amp; TRICKS, 1984, approx. 250 pages, DM 39,-

16 This legendary book on the VC 20 has become more valuable by more than a hundred pages. In addition to the basics that are important for every user, the book contains a wealth of first-class program listings: programming the function keys, autostart, command extensions and user programs. Every VC 20 owner will always find something new in this tome! VC-20 TIPS &amp; TRICKS, 3. extended and exprepared edition, 1984, 324 pages, DM 49, - without illustration:

A real treasure trove for the TI-99 user is the book TI-99 Tips &amp; Tricks. 300 pages, DM 49,-

<!-- TOC PAGE_378: Software product advertisement brochure -->===========================================================
                      PAGE 378 OF 386                       
===========================================================

# Because of game
## The super team

![img-24.jpeg](img-24.jpeg)

## DATAMAT

Germany's best-selling file management offers a lot that previously seemed unimaginable in this price range:
Menu-controlled diskette program, therefore extremely easy to use - for every type of data - completely freely configurable input mask - 50 fields per data record - 253 characters per data record - up to 2000 data records per file depending on the size - interface to TEXTOMAT - runs with 1 or 2 floppies - completely in machine language - extremely fast - German character set also on COMMODORE printers - almost any printer can be connected - prints out via RS 232 - duplicating the data disk - good user guidance - main program completely in memory (no disk change) - integrated mini word processing - German manual with tutorials.

You can:
Search for any data record in 2-3 seconds - select by any fields - sort by all fields at the same time - print lists in a completely free format - print labels. Complete only DM 99,– (recommended retail price)

## TEXTMAT

Germany's best-selling word processor offers professional management at a hobby price:
TEXTOMAT in keywords:
Floppy disk program - menu-controlled throughout - German character set also on COMMODORE printers - calculation functions for all basic arithmetic operations - 24,000 characters per text in memory - texts of any length through linking - horizontal scrolling for 80 characters per line - runs with 1 or 2 floppies - freely programmable control characters - form control for margin adjustment, etc. – complete block processing – block operations, search and replace – writing serial letters with DATAMAT – formatted output on screen – adaptable to almost any printer – detailed German manual with tutorials – complete only DM 99.00 (recommended retail price).

Many DATA BECKER authors even use TEXTOMAT to create entire books because of its versatility and ease of use.

![img-25.jpeg](img-25.jpeg)

## ACCOUNT MACHINE

KONTOMAT is a menu-controlled income surplus program according to § 4(3) EStG with cash book, bank account monitoring, automatic tax booking, AFA table creation, account sheets, determination of VAT advance declaration values and monthly and annual

![img-26.jpeg](img-26.jpeg)

<!-- TOC PAGE_379: KONTOMAT accounting software brochure -->===========================================================
                      PAGE 379 OF 386                       
===========================================================

#stuff...

billing. The new KONTOMAT is fully parameterized and can therefore be adapted to your needs. For all traders who are not obliged to keep accounts according to the German Commercial Code (HGB), KONTOMAT is suitable for commercial use, but also as a learning program or for household accounting.

## ACCOUNT MACHINE in keywords:

Disk program - maximum 120 accounts - Amounts with up to 6 decimal places and 2 decimal places - 4 VAT and input tax rates - Intermittent receipt entry - 4 booking types (DEBIT, CREDIT, DEBIT/CREDIT and CREDIT/DESIGN) - Display of the debit and credit totals for multiple booking records - Convenient receipt entry with date, booking text, tax code and amount - Printing of the journal during receipt entry - Printing of extensive Account sheets - printing of a totals and strings list with monthly and annual sales totals - business evaluation with print output - determination and printout of the sales tax payment branch - storage of fixed assets and automatic depreciation at the end of the year - clear depreciation list - works with 1 or 2 drives - comprehensive German manual. DM 148,– recommended retail price

## PAYMENTS

Extensive payment transactions can become a nuisance. The PAYMENT TRAFFIC software package takes care of most of this work. In addition to the necessary skills for filling out and listing transfers and checks, PAYMENT TRAFFIC is able to independently compile collection lists, collection lists, etc. PAYMENT TRANSACTIONS in keywords: Diskette program – max. 100 payment recipients per diskette – three definable sender banks – 25 payment files – 14 freely definable forms – control printing possible when entering receipts – entry of invoice details

data or a purpose - printout of a collective transfer list - option to correct individual payment files - works with one or two floppies - extensive German manual. DM 148,– recommended retail price

## CALCUMATE

The KALKUMAT software package sets new standards for calculation programs on the Commodore 64. All proven performance features of such programs have been adopted, new ones have been added and the whole thing has been provided with an unusually comfortable user interface. With KALKUMAT you can create tables with up to 255 rows in 63 columns. Each column width can be freely chosen. Values are entered via an edit line just as easily as in BASIC programs; all options are accessible via menus

![img-27.jpeg](img-27.jpeg)

reach. If you are ever unsure, you can call up one of the many help texts. All texts are output in German, and you can also choose between the American and a German character set (with the umlauts). The integrated graphics package is a special treat. Values ​​from an edited worksheet can be displayed graphically in a variety of ways: pie charts, curves, minimum-maximum graphics or column charts. You can label the resulting graphics with different font sizes. In addition, 8 windows can be defined in the graphics program. The KALKUMAT is a problem solver for tasks in both business and private areas. Every 64 owner will find his or her own area of ​​application for the KALKUMAT.

KALKUMAT, on diskette and with detailed manual DM 198, recommended retail price

All programs on diskette

<!-- TOC PAGE_380: FAKTUMAT invoicing software brochure -->===========================================================
                      PAGE 380 OF 386                       
===========================================================

# Programs from a good source.

![img-28.jpeg](img-28.jpeg)

## FACTUMAT

With FAKTUMAT, writing invoices is no longer a nightmare. Instant invoicing with integrated warehouse accounting, individual adjustment of tax rates, units of measurement and company data. Customer and item base can be fully maintained. Quick access to customer and item data using a freely definable 6-digit key. Automatic updating of item and customer data, can be used individually. All in all, the work and time savings you've always wanted.

## FAKTUMAT in keywords:

fully menu-controlled - runs with one or two floppies - diskette change (one floppy) only when changing from the main menu to the subprogram and vice versa - with the exception of switching off the floppy during processing, all errors are intercepted (e.g. printer not switched on - works with 1525, 1526 - MPS 801, EPSON printer and DATA BECKER interface - fully parameterized: company header, VAT and discount rates, size of the files Can be selected as desired - 5 lines for company header, 30 characters each (first line appears on the invoice in wide font - 4 VAT rates; when writing the invoice, items with different VAT rates can be charged - 10 discount rates (discount rate 1 is preset with 0%), when writing the invoice a discount rate can be assigned to each item - a maximum of 1900 items for 50 customers or 950 customers for 100 items (max. items = |1000-customers|2; max. customers = |2000-items|2) - manual entry of items and/or customers during invoice writing - i.e. more items can be invoiced than actually fit in the file (if inventory accounting is not used) or invoices can be written to customers who have not been recorded - integrated inventory accounting with output of an inventory list - invoice amounts and dates are recorded in the customer file - printing of: invoice (with Debiting from warehouse), invoice (without debiting from warehouse), delivery note - German detailed manual with practice and application section - German user guidance within the program (e.g. "Item not available" instead of "RECORD NOT PRESENT").

DM 148,~*

![img-29.jpeg](img-29.jpeg)

## HOUSE MANAGEMENT

Now all homeowners can breathe a sigh of relief: the HOUSE ADMINISTRATION program offers you very convenient management of rental apartments with the COMMODORE 64. All you need is a COMMODORE 64, a 1541 diskette drive, a connectable printer and the above-mentioned HOUSE ADMINISTRATION program. The following and many other powerful features enable extremely efficient management of your rental apartments.

* The prices for programs are recommended retail prices

HOUSE MANAGEMENT in keywords:

Floppy disk program - administration of 50 units per property possible - master data management for houses and tenants - recording rent, additional costs and garage rents - rental account display - house and tenant list - reminders - recording the costs incurred - cost comparison - year-end billing with automatic annual carryover - comprehensive German manual.

DM 198,~*

![img-30.jpeg](img-30.jpeg)

The new FINANZGENIE software package turns your 64 into a property manager. Whether it's fixed income and expenses, loans and savings items or variable amounts, you can feed everything. The FINANZGENIE provides you with the prepared data on the screen or in black and white for filing. The program works in a “deadline-oriented” manner. All dates are found based on their due date. So it goes without saying that the FINANZGENIE has various useful calendar functions. Fixed appointments are monitored and printed out on a personal planner. Of course, the FINANZGENIE also takes care of your banking matters: transfers are prepared and account balances are updated automatically. But you can also get advice from the program. A separate section focuses on the topic of loans and savings. For example, you can calculate and compare loan offers or calculate how much interest your savings account will earn per year. With the FINANCIAL GENIUS you can do a lot of things, except make mistakes; operational safety has been raised to an unusual level. It is practically impossible to make meaningless or inappropriate entries. Every attempt results in an error message. Your 64 with the FINANZGENIE are the team for your private finances and appointments!

FINANCIALNEVER, DM 69,~*

## THE DISK TO THE BOOK

Loading, starting – sure! The diskette for the book with all the important programs is now available for the following books:

64 INTERNAL

64 TIPS &amp; TRICKS

64 FOR PROFESSIONALS

PRINTER BOOK

FLOPPY BOOK

MACHINE LANGUAGE BOOK

MACHINE LANGUAGE FOR

ADVANCED

GRAPHIC BOOK

VC-20 TIPS &amp; TRICKS

TRAINING BOOK DATAMAT

UNDERSTAND COMPILER APPLY DEVELOP

APPLE II TIPS &amp; TRICKS

PASCAL 64 TIPS &amp; TRICKS

Price each DM 39,~*

![img-31.jpeg](img-31.jpeg)

Floppy disk for the COMMODORE 64 SCHOOL BOOK with 14 additional programs and 70-page manual DM 49,~*

<!-- TOC PAGE_381: Commodore 64 programming tools guide -->===========================================================
                      PAGE 381 OF 386                       
===========================================================

# The C64 doesn't just speak Basic...

## PROFIMAT

![img-32.jpeg](img-32.jpeg)

Anyone who wants to delve deeper into the innards of the computer cannot do without special tools. On the one hand, full insight into all memory areas must be possible, and on the other hand, handling machine programs should be as convenient as possible.

PROFIMAT has solutions for both problems: The machine language monitor PROFI-MON offers all the tools for dealing with machine programs; PROFI-ASS is a macro assembler that makes writing machine programs almost as easy as programming in BASIC.

### PROFIMAT in keywords:

Show register contents and flags - Show memory contents - Load, execute and save machine programs - Search, compare, fill and move memory areas - True single-step mode - Set breakpoints - Fast trace mode - Return to BASIC - Format-free input - Chaining of any number of Gueli programs - Generated object code can go into memory or on diskette - Formatted assembler listing - Loadable symbol tables - Redefinable symbols - Operators - Support of Floating point arithmetic – conditional assembly – assembly loops – MACROS with arbitrary parameters. DM 99,– *

![img-33.jpeg](img-33.jpeg)

MASTER 64 is a professional program development system for the C-64 that allows you to reduce program development time to a fraction of the usual time. MASTER 64 offers a program convenience that you should take advantage of.

### MASTER 64 in keywords:

70 additional commands - screen mask generator - defining screen zones - input from zones - formatted output - saving screen contents - working with multiple screen masks - ISAM file management in which data records can be addressed via an access key - data records up to 254 characters - key length up to 30 characters - file size only dependent on diskette capacity - access via keys and selection masks - screen and print mask generator - creation of any forms and output masks - BASIC extensions – Toolkit functions – Multiple precision arithmetic (calculating with 22 digits of precision). DM 198,– *

##ADA

This programming language of the future, which was commissioned by the Pentagon, is now being made accessible to C-64 users by DATA BECKER through the ADA TRAINING COURSE, which offers a very good introduction to this super language. The compiler supplied provides an extensive subset of the language.

### ADA in keywords:

Block-structured programs - modular structure of the programs - enables the handling of exceptions - error checking during compilation and at runtime - enables easy integration of machine programs - very easy to work with program libraries - program disk contains editor, translator, assembler and disassembler - extensive German manual. DM 198,– *

![img-34.jpeg](img-34.jpeg)

## STRUCTO 64

STRUKTO 64 is a fantastic new programming language for structured programming with the C-64 and is suitable for all programmers who want to use the C-64 as an all-round computer and easily create sophisticated programs.

### STRUKTO 64 in keywords:

Interpreter language that combines the advantages of BASIC and PASCAL - structured programming - clear programs - easy to learn - simple operation - built-in toolkit makes it easier to enter and improve programs - easier to work with the floppy - sprite editor allows the sprite shapes to be read directly from the screen - graphic operation is supported with well thought-out commands - playing music is possible independently of the program flow - approx. 80 new commands - available as a diskette program – detailed German manual. DM 99,– *

![img-35.jpeg](img-35.jpeg)
All programs on diskette

* The prices for programs are recommended retail prices

<!-- TOC PAGE_382: BASIC 64 compiler documentation -->===========================================================
                      PAGE 382 OF 386                       
===========================================================

![img-36.jpeg](img-36.jpeg)

#BASIC 64

The BASIC 64 compiler offers the option of translating BASIC programs either into machine language or into a so-called speed code. Both variants ensure that your programs run 4 to 14 times faster. Use BASIC 64 to edit all programs that have always been too slow for you. With the compact speed code you can reduce the memory requirement of your program by 25%, while the more memory-intensive machine code brings additional speed increases. BASIC 64 can process any program that was written in COMMODORE 64 BASIC (exception: individual POKE commands) and partially also supports the well-known command extensions. Additionally, BASIC 64 allows you to expand data storage space by 24K. BASIC 64 also does some work for you: transforming mathematical expressions, using memory space as economically as possible and integer arithmetic. By completely changing string handling, the dreaded garbage collection shrinks to just a few seconds. All options are called up via the menu and entries are checked for correctness. With BASIC 64 you have a tool in your hand that makes your BASIC programs faster than you previously thought possible. DM 99,- (recommended retail price)

# PASCAL 64

PASCAL 64 is a PASCAL compiler for the COMMODORE 64 with the following features: very extensive command set - allows interrupt programming and

# This is how learning gets done right
# Fun

![img-37.jpeg](img-37.jpeg)
All programs on diskette

offers interfaces to monitor and assembler - generates very fast programs in pure machine code - supports relative file management, graphics and sound - offers the data types REAL, INTEGER, CHAR and BOOLEAN as well as enumeration types and pointers that can be combined into data structures RECORD, SET, ARRAY and PACKED ARRAY - allows early completion of procedures with EXIT, unrestricted recursions and convenient processing of subfields (strings) - is a sophisticated, German product and comes with a detailed manual. DM 99,- (recommended retail price)

![img-38.jpeg](img-38.jpeg)

# DISCOMAT

![img-39.jpeg](img-39.jpeg)

For many people, dealing with floppy disk drives is still shrouded in mystery. Others are bothered by the inconvenient floppy disk commands of BASIC V2. DISKOMAT brings relief; All BASIC 4.0 diskette commands are available. In addition, the SUPERTWIN program can be used to manage two 1541 drives like a double drive. For users who want to fully exploit the capabilities of the Floppy 1541, the DISK MONITOR is available; It finally makes it possible to access individual blocks easily and conveniently.

# DISKOMAT in keywords:

Disk program - DISK BASIC supports BASIC 4.0 disk commands (CONCAT, HEADER, APPEND, RENAME, OPEN, COLLECT, DSAVE, SCRATCH, DCLOSE, BACKUP, DLOAD, DIRECTORY, RECORD, COPY, CATALOG, DS &amp; DSS) - SUPER TWIN treats 2 drives 1541 like a double drive - DISK MONITOR enables direct analysis and manipulation of floppy disks (direct reading and writing of individual blocks, changing blocks using the screen editor, displaying the floppy disk status, direct sending of floppy disk commands) - detailed German manual describes each of the 3 program parts. DM 99,- recommended retail price

# Brush up your English!

Can you imagine a more patient teacher than your computer? Hardly. The new learning program “BRUSH UP YOUR ENGLISH” always has time for you, helps you and knows what you have already learned. A prerequisite is knowledge of English, regardless of quality. The program will ask you various questions that you can answer. “BRUSH UP...” draws on a vocabulary of 1,500 words that can be used to formulate over 700 tasks. If you don't know what to do, select the HELP function and you will be given a hint about the solution. If that is not enough, the answer appears. It is also possible to skip a question or delete it completely from the current lesson. This all takes place in a simulated course. You determine the level of difficulty and the pace, the computer evaluates your performance, monitors your daily workload and alerts you to any gaps. With the new learning program “BRUSH UP YOUR ENGLISH” you can brush up on your various language skills again! The complete course consists of three partslen, which differ in the different word fields. Each diskette can be used alone.

BRUSH UP YOUR ENGLISH, parts 1, 2 and 3 each DM 49,- recommended retail price

<!-- TOC PAGE_383: Junior mathematics learning program description -->===========================================================
                      PAGE 383 OF 386                       
===========================================================

![img-40.jpeg](img-40.jpeg)

Learning while playing is not a buzzword in the new JUNIOR MATHEMAT learning program. Students from lower grades I to 4th grade can practice arithmetic without dogged seriousness or excessive demands. The tasks are embedded in a small video game that acts as a reward and motivation. The exercises are adapted to the official curricula at every level of difficulty. Grading is also based on this standard. Your child can learn and play independently with the JUNIOR MATHEMAT. However, you have the opportunity to check the performance level. All tasks are clearly presented and can be solved in several attempts. If it doesn't work the first time, the program gives careful help and - depending on the type of task - only gives an answer a minus point after the third failed attempt. This method helps children to cope with failures. In addition, the individual training units are so limited that the child can actually stay focused in the allotted time. Try solving set theory problems too! You may then need to take tutoring. The JUNIOR MATHEMAT is the right program for parents of primary school children. With the easy-to-understand manual, adults and children can get started right away. JUNIOR MATHEMAT, DM 69.–*

![img-41.jpeg](img-41.jpeg)

A new series of easy-to-understand learning programs, developed by experienced educators and programmers, on the central topics of secondary school mathematics. Each module has an introductory section that clarifies the subject area and explains the necessary terms, technical terms and symbols. The graphic possibilities of the C-64 are fully exploited to clearly awaken understanding of mathematical relationships.

Rules and laws are developed gradually. If necessary, additional explanations can be obtained using the question button. The computer provides an unlimited number of exercises. Each task can be calculated in detail upon request. You can also take tests and be graded by the computer. The “Help with homework” part of the program allows the user to set tasks that the computer solves.

Each course part on diskette for C-64 only DM 49.–* Now available: ALGEBRA I (introduction to equation theory), ALGEBRA II (linear systems of equations of two equations with two variables), ALGEBRA III (quadratic equations), ALGEBRA IV (powers, exponential functions, logarithms).

![img-42.jpeg](img-42.jpeg)

Whether at school, at university or at work: you can finally leave logarithm tables and collections of formulas in the drawer. This tool and much more replaces the MATHEMAT software package. For simple mathematical calculations, this program turns your computer into a calculator with all basic arithmetic operations and exponentiation, root extraction, percentage calculations and logarithms. The arithmetic shortcomings of the C-64 have been ironed out and the calculation accuracy is 10 decimal places externally. Almost all algebraic tasks can be calculated using MATHEMAT. MATHEMAT is also at home in differential and integral calculations. The integrated program for graphical representation is a chapter in itself. Any function graph can be drawn on the screen; Depending on the monitor, also multicolored if desired. The skills of the MATHEMAT in the field of geometry belong to the same topic. The MATHEMAT has all conceivable surfaces and bodies under control. The MATHEMAT does not have to capitulate to vector geometry either, all variants are implemented. In addition, the software package offers a complete mathematics lexicon with the most important terms, formulas and solution approaches. Any mathematical problem can be solved using MATHEMAT. There are no limits to the applications! MATHEMAT, DM 99.–*

# EXCESS, GAMES and SPORTS

Are you looking for the best games possible for as little money as possible? Here you go! SUPER 4 offers four absolute top games for just 49 marks: STAR CHRASH – a fascinating space adventure. SPUK – a great climbing and ladder game with 29 different pictures. PANCHO – an action game with a little Mexican. CROWN – a slot machine of the best variety with a risk button and a golden series. All games have not yet been published in Germany and were selected by us from over 100 games for you.

![img-43.jpeg](img-43.jpeg)

The SUPER 4 disk with the four super games is now available from your dealer for only DM 49.–*

TodayAlready know tomorrow's Bundesliga table, that's possible with UNI-TAB. All calculations that you would never do without this program can be carried out in a matter of seconds. If you want, you can predict the ’86 world champion using simulated game results. But not only football leagues can be recorded in tables, almost all sports are UNI-TAB compatible. A side joke: the well-known pictograms are available for many sports. UNI-TAB in keywords: Menu control via the function keys with easy-to-understand selection options - User-friendly (teams are controlled via key figures) - Leagues with 3 to 20 teams can be managed (3 to 38 match days possible) - Nonsensical leagues (e.g. 13 teams should play 5 match days) are excluded - Favorite team can be marked in reverse display during the program run - Table can be changed

(important in the case of game cancellations) - three different types of tables can be saved and read in later (the current table (regardless of the completeness of a match day), the complete match day (completeness and number of the match day are automatically calculated), the simulated table (the user can play fate himself and later compare his tip with the actual events)) - two different types of season overview (the statistical overview shows which place in the table the respective team is with what points and goal difference on the individual match days the graphic overview shows the performance curve of each team) - all tables and graphics can be displayed as hard copies on a printer - in the event of incorrect operation (e.g. desired print output when the printer is not switched on), easy-to-understand German error messages appear. DM 69.–*

All programs on diskette

* The prices for programs are recommended retail prices

<!-- TOC PAGE_384: Software training book catalog -->===========================================================
                      PAGE 384 OF 386                       
===========================================================

![img-44.jpeg](img-44.jpeg)
THE TRAINING BOOK FOR TURBO PASCAL, approx. 220 pages, DM 39,-

![img-45.jpeg](img-45.jpeg)
THE FORTH TRAINING BOOK, approx. 250 pages, DM 39,-

![img-46.jpeg](img-46.jpeg)
THE TRAINING BOOK FOR LOGO, approx. 200 pages, DM 39,-

![img-47.jpeg](img-47.jpeg)
THE TRAINING BOOK FOR WORDSTAR/MALMERGE, approx. 270 pages, DM 39,-

![img-48.jpeg](img-48.jpeg)
THE TRAINING BOOK FOR PASCAL, 250 pages, DM 39,-

![img-49.jpeg](img-49.jpeg)
THE TRAINING BOOK FOR MULTIPLAN, 250 pages, DM 49,-

# Optimal software training

Using software correctly is not difficult – if you know how to do it. Unfortunately, very few users of the highly praised standard programs are still able to cope with the manufacturer's supplied manuals alone. This is not only due to the manuals, but also because software users often lack the necessary basic knowledge.

DATA BECKER has therefore created the extremely popular and successful series of software training books. These books not only provide an easy-to-understand introduction to the respective program, but also provide the necessary tools to use the programs sensibly and successfully. Advanced users will also find many important tips &amp; Tricks. The authors of this book series not only have extensive experience with the correct use of the programs, but also generally know the concerns and wishes of their readers due to their intensive seminar experience as speakers.

THE TRAINING BOOK FOR TEXTOMAT, 200 pages, DM 39,-

![img-50.jpeg](img-50.jpeg)

![img-51.jpeg](img-51.jpeg)
THE TRAINING BOOK FOR SIMON'S BASIC, 380 pages, DM 49,-

![img-52.jpeg](img-52.jpeg)
THE TRAINING BOOK FOR dBASE, 250 pages, DM 49,-

![img-53.jpeg](img-53.jpeg)
THE DATAMAT TRAINING BOOK, 200 pages, DM 39,-

<!-- TOC PAGE_385: Blank document page -->

===========================================================
                      PAGE 385 OF 386                       
===========================================================

.

<!-- TOC PAGE_386: Commodore 64 programming guide -->

===========================================================
                      PAGE 386 OF 386                       
===========================================================

# THIS IS WHAT IT SAYS:

64 Tips &amp; Tricks Vol. 1, a bestseller from DATA BECKER with well over 70,000 copies sold, is a real treasure trove for every COMMODORE 64 user. With POKEs and other useful routines, interesting programs as well as important programming tips &amp; -tricks.

## From the content:

- Definition of your own character set
- Keyboard layout and its changes
- Data entry with comfort
- Simulation of the mouse with a joystick
- BASIC for advanced users
- CP/M on the COMMODORE 64
- Printer connection via the USER port
- Data transfer from and to other computers
- Expansion port
- Stereo synthesizer
- Rescuing an improperly closed file
- Creating a BASIC line in BASIC
- Cassette buffer as data storage
- Sorting string fields
- Multitasking on the COMMODORE 64
- POKE’s and the zeropage
- Repeat function for all buttons and much more...

# AND WRITTEN THIS BOOK:

The proven DATA-BECKER team of authors with Michael Angerhausen, Lothar Englisch, Klaus Gerits and Frank Thrun. Not only are they all enthusiastic programmers who know their 64 inside and out, but they are also well-known authors of many other books.

ISBN 3-89011-001-0